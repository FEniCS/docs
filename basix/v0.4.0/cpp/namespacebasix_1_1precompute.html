<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="https://fenicsproject.org/assets/css/style.css">
    <link rel="apple-touch-icon" sizes="57x57" href="https://fenicsproject.org/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://fenicsproject.org/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://fenicsproject.org/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://fenicsproject.org/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://fenicsproject.org/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://fenicsproject.org/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://fenicsproject.org/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://fenicsproject.org/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://fenicsproject.org/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://fenicsproject.org/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://fenicsproject.org/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://fenicsproject.org/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://fenicsproject.org/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="https://fenicsproject.org/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#555555">
    <meta name="msapplication-TileImage" content="https://fenicsproject.org/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#555555">
    <link rel="stylesheet" type="text/css" href="https://fenicsproject.org/assets/css/customsty.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://kit.fontawesome.com/5506de0e1b.js" crossorigin="anonymous"></script>
    <script type='text/javascript'>
document.getElementById("MathJax-script").addEventListener('load', function () {
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['[[',']]']]
  },
  svg: {
    fontCache: 'global'
  }
}});
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basix: basix::precompute Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
  </head>
<body>
<!-- HEADER -->
<div id="nav_head">
  <header class="inner" id="nav_head_inner">
    <a id="logo" href="/"><img src="https://fenicsproject.org/assets/img/fenics-logo-small.png"></a>
    <div class="top-navigation">
  <nav role="navigation" id="site-nav" class="nav">
    <ul>
        <li><a href="https://fenicsproject.org/people-of-fenics">People of FEniCS</a></li>
        <li><a href="https://fenicsproject.org/roadmap">Roadmap 2021-</a></li>
        <li><a href="https://fenicsproject.org/fenics-2022">FEniCS 2022</a></li>
        <li><a href="https://fenicsproject.org/download">Download</a></li>
        <li><a href="https://fenicsproject.org/documentation">Documentation</a></li>
        <li><a href="https://fenicsproject.org/community">Community</a></li>
        <li><a href="https://fenicsproject.org/governance">Governance</a></li>
        <li><a href="https://fenicsproject.org/citing">Citing</a></li>
        <li><a href="https://numfocus.salsalabs.org/donate-to-fenics/index.html">Donate</a></li>
    </ul>
  </nav>
</div>
  </header>
</div>
  <div id="header_wrap" class="outer" style="background-image:url(https://fenicsproject.org/assets/img/default-bg.png);background-repeat:repeat">
  <header class="inner">
  <h1 id="project_title">Basix 0.4.0
</h1>
  </header>
</div>
<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner"><h2 id="project_subtitle"><a class='fenicsnav' href='https://docs.fenicsproject.org/basix/v0.4.0/index.html'>Home</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/v0.4.0/install.html'>Installation</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/v0.4.0/python/demo'>Demos</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/v0.4.0/cpp'>C++ docs</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/v0.4.0/python'>Python docs</a>
</h2>  </section>
</div><div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="namespacebasix_1_1precompute.html">precompute</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">basix::precompute Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix and permutation precomputation.  
<a href="namespacebasix_1_1precompute.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada081b03020c8ef06aedffb5acd59f3f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#ada081b03020c8ef06aedffb5acd59f3f">prepare_permutation</a> (const std::vector&lt; std::size_t &gt; &amp;perm)</td></tr>
<tr class="separator:ada081b03020c8ef06aedffb5acd59f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7539befcd08dfe18fd219f09e7e2d6ca"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a7539befcd08dfe18fd219f09e7e2d6ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#a7539befcd08dfe18fd219f09e7e2d6ca">apply_permutation</a> (const std::vector&lt; std::size_t &gt; &amp;perm, const xtl::span&lt; E &gt; &amp;data, std::size_t offset=0, std::size_t block_size=1)</td></tr>
<tr class="separator:a7539befcd08dfe18fd219f09e7e2d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5aa3c74e2e0a1b18ccf4416c97d0ae"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a7e5aa3c74e2e0a1b18ccf4416c97d0ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#a7e5aa3c74e2e0a1b18ccf4416c97d0ae">apply_permutation_to_transpose</a> (const std::vector&lt; std::size_t &gt; &amp;perm, const xtl::span&lt; E &gt; &amp;data, std::size_t offset=0, std::size_t block_size=1)</td></tr>
<tr class="separator:a7e5aa3c74e2e0a1b18ccf4416c97d0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ec6c149ed1531a21cecce0857fec58"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; double &gt;, xt::xtensor&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#a59ec6c149ed1531a21cecce0857fec58">prepare_matrix</a> (const xt::xtensor&lt; double, 2 &gt; &amp;matrix)</td></tr>
<tr class="separator:a59ec6c149ed1531a21cecce0857fec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa6680cac532cbb62b6fc037555c093"><td class="memTemplParams" colspan="2">template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a8aa6680cac532cbb62b6fc037555c093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#a8aa6680cac532cbb62b6fc037555c093">apply_matrix</a> (const std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; T &gt;, xt::xtensor&lt; T, 2 &gt;&gt; &amp;matrix, const xtl::span&lt; E &gt; &amp;data, std::size_t offset=0, std::size_t block_size=1)</td></tr>
<tr class="separator:a8aa6680cac532cbb62b6fc037555c093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9599daaf6abf03ed6f8e70b1e0ff587"><td class="memTemplParams" colspan="2">template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ab9599daaf6abf03ed6f8e70b1e0ff587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebasix_1_1precompute.html#ab9599daaf6abf03ed6f8e70b1e0ff587">apply_matrix_to_transpose</a> (const std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; T &gt;, xt::xtensor&lt; T, 2 &gt;&gt; &amp;matrix, const xtl::span&lt; E &gt; &amp;data, std::size_t offset=0, std::size_t block_size=1)</td></tr>
<tr class="separator:ab9599daaf6abf03ed6f8e70b1e0ff587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrix and permutation precomputation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8aa6680cac532cbb62b6fc037555c093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa6680cac532cbb62b6fc037555c093">&#9670;&nbsp;</a></span>apply_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::precompute::apply_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; T &gt;, xt::xtensor&lt; T, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a (precomputed) matrix</p>
<p>This uses the representation returned by <code><a class="el" href="namespacebasix_1_1precompute.html#a59ec6c149ed1531a21cecce0857fec58">prepare_matrix()</a></code> to apply a matrix without needing any temporary memory.</p>
<p>In pseudo code, this function does the following:</p>
<div class="fragment"><div class="line">perm, diag, mat = matrix</div>
<div class="line">apply_permutation(perm, data)</div>
<div class="line">FOR index IN RANGE(dim):</div>
<div class="line">    data[index] *= diag[index]</div>
<div class="line">    FOR j IN RANGE(dim):</div>
<div class="line">        data[index] *= mat[index, j] * data[j]</div>
</div><!-- fragment --><p>If <code>block_size</code> is set, this will apply the permutation to every block. The <code>offset</code> is set, this will start applying the permutation at the <code>offset</code>th block.</p>
<h2>Example </h2>
<p>As an example, consider the matrix \(A = \) <code>[[-1, 0, 1], [1, 1, 0], [2, 0, 2]]</code>. In the documentation of <code><a class="el" href="namespacebasix_1_1precompute.html#a59ec6c149ed1531a21cecce0857fec58">prepare_matrix()</a></code>, we saw that the precomputed representation of this matrix is the identity permutation, </p><p class="formulaDsp">
\begin{align*} D &amp;= \begin{bmatrix}-1\\1\\4\end{bmatrix},\\ \quad M &amp;= \begin{bmatrix} 0&amp;0&amp;1\\ -1&amp;0&amp;1\\ -2&amp;0&amp;0 \end{bmatrix}. \end{align*}
</p>
<p> In this example, we look at how this representation can be used to apply this matrix to the vector \(v = \) <code>[3, -1, 2]</code>.</p>
<p>No permutation is necessary, so first, we multiply \(v_0\) by \(D_0=-1\). After this, \(v\) is <code>[-3, -1, 2]</code>.</p>
<p>Next, we add \(M_{0,i}v_i\) to \(v_0\) for all \(i\): in this case, we add \(0\times-3 + 0\times-1 + 1\times2 = 2\). After this, \(v\) is <code>[-1, -1, 2]</code>.</p>
<p>Next, we multiply \(v_1\) by \(D_1=1\). After this, \(v\) is <code>[-1, -1, 2]</code>.</p>
<p>Next, we add \(M_{1,i}v_i\) to \(v_1\) for all \(i\): in this case, we add \(-1\times-1 + 0\times-1 + 1\times2 = 3\). After this, \(v\) is <code>[-1, 2, 2]</code>.</p>
<p>Next, we multiply \(v_2\) by \(D_2=4\). After this, \(v\) is <code>[-1, 2, 8]</code>.</p>
<p>Next, we add \(M_{2,i}v_i\) to \(v_2\) for all \(i\): in this case, we add \(-2\times-1 + 0\times2 + 0\times8 = 2\). After this, \(v\) is <code>[-1, 2, 10]</code>. This final value of \(v\) is what the result of \(Av\)</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A matrix in precomputed form (as returned by <code><a class="el" href="namespacebasix_1_1precompute.html#a59ec6c149ed1531a21cecce0857fec58">prepare_matrix()</a></code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to apply the permutation to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The position in the data to start applying the permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>The block size of the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9599daaf6abf03ed6f8e70b1e0ff587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9599daaf6abf03ed6f8e70b1e0ff587">&#9670;&nbsp;</a></span>apply_matrix_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::precompute::apply_matrix_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; T &gt;, xt::xtensor&lt; T, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a (precomputed) matrix to some transposed data.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<p>See <code><a class="el" href="namespacebasix_1_1precompute.html#a8aa6680cac532cbb62b6fc037555c093">apply_matrix()</a></code>. </p>

</div>
</div>
<a id="a7539befcd08dfe18fd219f09e7e2d6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7539befcd08dfe18fd219f09e7e2d6ca">&#9670;&nbsp;</a></span>apply_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::precompute::apply_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a (precomputed) permutation</p>
<p>This uses the representation returned by <code><a class="el" href="namespacebasix_1_1precompute.html#ada081b03020c8ef06aedffb5acd59f3f">prepare_permutation()</a></code> to apply a permutation without needing any temporary memory.</p>
<p>In pseudo code, this function does the following:</p>
<div class="fragment"><div class="line">FOR index, entry IN perm:</div>
<div class="line">    SWAP(data[index], data[entry])</div>
</div><!-- fragment --><p>If <code>block_size</code> is set, this will apply the permutation to every block. The <code>offset</code> is set, this will start applying the permutation at the <code>offset</code>th block.</p>
<h2>Example </h2>
<p>As an example, consider the permutation <code>P = [1, 4, 0, 5, 2, 3]</code>. In the documentation of <code><a class="el" href="namespacebasix_1_1precompute.html#ada081b03020c8ef06aedffb5acd59f3f">prepare_permutation()</a></code>, we saw that the precomputed representation of this permutation is <code>P2 = [1, 4, 4, 5, 4, 5]</code>. In this example, we look at how this representation can be used to apply this permutation to the array <code>A = [a, b, c, d, e, f]</code>.</p>
<p><code>P2[0]</code> is 1, so we swap <code>A[0]</code> and <code>A[1]</code>. After this, <code>A = [b, a, c, d, e, f]</code>.</p>
<p><code>P2[1]</code> is 4, so we swap <code>A[1]</code> and <code>A[4]</code>. After this, <code>A = [b, e, c, d, a, f]</code>.</p>
<p><code>P2[2]</code> is 4, so we swap <code>A[2]</code> and <code>A[4]</code>. After this, <code>A = [b, e, a, d, c, f]</code>.</p>
<p><code>P2[3]</code> is 5, so we swap <code>A[3]</code> and <code>A[5]</code>. After this, <code>A = [b, e, a, f, c, d]</code>.</p>
<p><code>P2[4]</code> is 4, so we swap <code>A[4]</code> and <code>A[4]</code>. This changes nothing.</p>
<p><code>P2[5]</code> is 5, so we swap <code>A[5]</code> and <code>A[5]</code>. This changes nothing.</p>
<p>Therefore the result of applying this permutation is <code>[b, e, a, f, c, d]</code> (which is what we get if we apply the permutation directly).</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>A permutation in precomputed form (as returned by <code><a class="el" href="namespacebasix_1_1precompute.html#ada081b03020c8ef06aedffb5acd59f3f">prepare_permutation()</a></code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to apply the permutation to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The position in the data to start applying the permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>The block size of the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e5aa3c74e2e0a1b18ccf4416c97d0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5aa3c74e2e0a1b18ccf4416c97d0ae">&#9670;&nbsp;</a></span>apply_permutation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::precompute::apply_permutation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a (precomputed) permutation to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<p>see <code><a class="el" href="namespacebasix_1_1precompute.html#a7539befcd08dfe18fd219f09e7e2d6ca">apply_permutation()</a></code>. </p>

</div>
</div>
<a id="a59ec6c149ed1531a21cecce0857fec58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ec6c149ed1531a21cecce0857fec58">&#9670;&nbsp;</a></span>prepare_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; double &gt;, xt::xtensor&lt; double, 2 &gt; &gt; basix::precompute::prepare_matrix </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a matrix</p>
<p>This computes a representation of the matrix that allows the matrix to be applied without any temporary memory assignment.</p>
<p>This function will first permute the matrix's columns so that the top left \(n\times n\) blocks are invertible (for all \(n\)). Let \(A\) be the input matrix after the permutation is applied. The output vector \(D\) and matrix \(M\) are then given by: </p><p class="formulaDsp">
\begin{align*} D_i &amp;= \begin{cases} A_{i, i} &amp; i = 0\\ A_{i, i} - A_{i,:i}A_{:i,:i}^{-1}A_{:i,i} &amp; i \not= 0 \end{cases},\\ M_{i,j} &amp;= \begin{cases} A_{i,:i}A_{:i,:i}^{-1}e_j &amp; j &lt; i\\ 0 &amp; j = i\\ A_{i, i} - A_{i,:i}A_{:i,:i}^{-1}A_{:i,j} &amp; j &gt; i = 0 \end{cases}, \end{align*}
</p>
<p> where \(e_j\) is the \(j\)th coordinate vector, we index all the matrices and vector starting at 0, and we use numpy-slicing-stying notation in the subscripts: for example, \(A_{:i,j}\) represents the first \(i\) entries in the \(j\)th column of \(A\)</p>
<p>This function returns the permutation (precomputed as in <code><a class="el" href="namespacebasix_1_1precompute.html#ada081b03020c8ef06aedffb5acd59f3f">prepare_permutation()</a></code>), the vector \(D\), and the matrix \(M\) as a tuple.</p>
<h2>Example </h2>
<p>As an example, consider the matrix \(A = \) <code>[[-1, 0, 1], [1, 1, 0], [2, 0, 2]]</code>. For this matrix, no permutation is needed, so the first item in the output will represent the identity permutation. We now compute the output vector \(D\) and matrix \(M\).</p>
<p>First, we set \(D_0 = A_{0,0}=-1\), set the diagonal of \(M\) to be 0 and set \(M_{0, 1:} = A_{0, 1:}=\begin{bmatrix}0&amp;1\end{bmatrix}\). The output so far is </p><p class="formulaDsp">
\begin{align*} D &amp;= \begin{bmatrix}-1\\?\\?\end{bmatrix},\\ \quad M &amp;= \begin{bmatrix} 0&amp;0&amp;1\\ ?&amp;0&amp;?\\ ?&amp;?&amp;0 \end{bmatrix}. \end{align*}
</p>
<p>Next, we set: </p><p class="formulaDsp">
\begin{align*} D_1 &amp;= A_{1,1} - A_{1, :1}A_{:1,:1}^{-1}A_{:1, 1}\\ &amp;= 1 - \begin{bmatrix}-1\end{bmatrix}\cdot\begin{bmatrix}0\end{bmatrix}\\ &amp;= 1,\\ M_{2,0} &amp;= A_{1, :1}A_{:1,:1}^{-1}e_0\\ &amp;= \begin{bmatrix}1\end{bmatrix}\begin{bmatrix}-1\end{bmatrix}^{-1} \begin{bmatrix}1\end{bmatrix}\\ &amp;= \begin{bmatrix}-1\end{bmatrix} M_{2,3} &amp;= A_{1,2}-A_{1, :1}A_{:1,:1}^{-1}A_{:1, 1}\\ &amp;= 0-\begin{bmatrix}1\end{bmatrix}\begin{bmatrix}-1\end{bmatrix}^{-1} \begin{bmatrix}1\end{bmatrix},\\ &amp;= 1. \end{align*}
</p>
<p> The output so far is </p><p class="formulaDsp">
\begin{align*} D &amp;= \begin{bmatrix}-1\\1\\?\end{bmatrix},\\ \quad M &amp;= \begin{bmatrix} 0&amp;0&amp;1\\ -1&amp;0&amp;1\\ ?&amp;?&amp;0 \end{bmatrix}. \end{align*}
</p>
<p>Next, we set: </p><p class="formulaDsp">
\begin{align*} D_2 &amp;= A_{2,2} - A_{2, :2}A_{:2,:2}^{-1}A_{:2, 2}\\ &amp;= 2 - \begin{bmatrix}2&amp;0\end{bmatrix} \begin{bmatrix}-1&amp;0\\1&amp;1\end{bmatrix}^{-1} \begin{bmatrix}1\\0\end{bmatrix}\\ &amp;= 4,\\ M_{2,0} &amp;= A_{2, :2}A_{:2,:2}^{-1}e_0\\ &amp;= -2.\\ M_{2,1} &amp;= A_{2, :2}A_{:2,:2}^{-1}e_1\\ &amp;= 0.\\ \end{align*}
</p>
<p> The output is </p><p class="formulaDsp">
\begin{align*} D &amp;= \begin{bmatrix}-1\\1\\4\end{bmatrix},\\ \quad M &amp;= \begin{bmatrix} 0&amp;0&amp;1\\ -1&amp;0&amp;1\\ -2&amp;0&amp;0 \end{bmatrix}. \end{align*}
</p>
<p>For an example of how the permutation in this form is applied, see <code><a class="el" href="namespacebasix_1_1precompute.html#a8aa6680cac532cbb62b6fc037555c093">apply_matrix()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The precomputed representation of the matrix </dd></dl>

</div>
</div>
<a id="ada081b03020c8ef06aedffb5acd59f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada081b03020c8ef06aedffb5acd59f3f">&#9670;&nbsp;</a></span>prepare_permutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; basix::precompute::prepare_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a permutation</p>
<p>This computes a representation of the permutation that allows the permutation to be applied without any temporary memory assignment.</p>
<p>In pseudo code, this function does the following:</p>
<div class="fragment"><div class="line">FOR index, entry IN perm:</div>
<div class="line">    new_index = entry</div>
<div class="line">    WHILE new_index &lt; index:</div>
<div class="line">        new_index = perm[new_index]</div>
<div class="line">    OUT[index] = new_index</div>
</div><!-- fragment --><h2>Example </h2>
<p>As an example, consider the permutation <code>P = [1, 4, 0, 5, 2, 3]</code>.</p>
<p>First, we look at the 0th entry. <code>P[0]</code> is 1. This is greater than 0, so the 0th entry of the output is 1.</p>
<p>Next, we look at the 1st entry. <code>P[1]</code> is 4. This is greater than 1, so the 1st entry of the output is 4.</p>
<p>Next, we look at the 2nd entry. <code>P[2]</code> is 0. This is less than 2, so we look at <code>P[0].</code>P[0]<code>is 1. This is less than 2, so we look at</code>P[1]<code>.</code>P[1]` is 4. This is greater than 2, so the 2nd entry of the output is 4.</p>
<p>Next, we look at the 3rd entry. <code>P[3]</code> is 5. This is greater than 3, so the 3rd entry of the output is 5.</p>
<p>Next, we look at the 4th entry. <code>P[4]</code> is 2. This is less than 4, so we look at <code>P[2]</code>. <code>P[2]</code> is 0. This is less than 4, so we look at <code>P[0]</code>. <code>P[0]</code> is 1. This is less than 4, so we look at <code>P[1]</code>. <code>P[1]</code> is 4. This is greater than (or equal to) 4, so the 4th entry of the output is 4.</p>
<p>Next, we look at the 5th entry. <code>P[5]</code> is 3. This is less than 5, so we look at <code>P[3]</code>. <code>P[3]</code> is 5. This is greater than (or equal to) 5, so the 5th entry of the output is 5.</p>
<p>Hence, the output of this function in this case is <code>[1, 4, 4, 5, 4, 5]</code>.</p>
<p>For an example of how the permutation in this form is applied, see <code><a class="el" href="namespacebasix_1_1precompute.html#a7539befcd08dfe18fd219f09e7e2d6ca">apply_permutation()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>A permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The precomputed representation of the permutation </dd></dl>

</div>
</div>
</div><!-- contents -->

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    &copy; FEniCS Project 2021. Changes to this website can be made/suggested on <a href='https://github.com/FEniCS/web'>GitHub</a>.
  </footer>
</div>
</body>
</html>

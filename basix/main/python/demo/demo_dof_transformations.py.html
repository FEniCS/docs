
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>DOF permutations and transformations &#8212; Basix 0.7.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Creating a custom element" href="demo_custom_element.py.html" />
    <link rel="prev" title="Variants of Lagrange elements" href="demo_lagrange_variants.py.html" />

    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="https://fenicsproject.org/assets/css/style.css">

    <link rel="apple-touch-icon" sizes="57x57" href="https://fenicsproject.org/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://fenicsproject.org/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://fenicsproject.org/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://fenicsproject.org/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://fenicsproject.org/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://fenicsproject.org/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://fenicsproject.org/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://fenicsproject.org/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://fenicsproject.org/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://fenicsproject.org/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://fenicsproject.org/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://fenicsproject.org/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://fenicsproject.org/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="https://fenicsproject.org/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#555555">
    <meta name="msapplication-TileImage" content="https://fenicsproject.org/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#555555">

    <link rel="stylesheet" type="text/css" href="https://fenicsproject.org/assets/css/customsty.css">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://kit.fontawesome.com/5506de0e1b.js" crossorigin="anonymous"></script>
    <script type='text/javascript'>
document.getElementById("MathJax-script").addEventListener('load', function () {
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['[[',']]']]
  },
  svg: {
    fontCache: 'global'
  }
}});
</script>


  
  
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />


  </head><body>

<!-- HEADER -->
<div id="nav_head">
  <header class="inner" id="nav_head_inner">
    <a id="logo" href="/"><img src="https://fenicsproject.org/assets/img/fenics-logo-small.png"></a>
    <div class="top-navigation">
  <nav role="navigation" id="site-nav" class="nav">
    <ul>
      
        <li><a href="https://fenicsproject.org/fenics-2023">FEniCS 2023</a></li>
      
        <li><a href="https://fenicsproject.org/download">Download</a></li>
      
        <li><a href="https://fenicsproject.org/documentation">Documentation</a></li>
      
        <li><a href="https://fenicsproject.org/community">Community</a></li>
      
        <li><a href="https://fenicsproject.org/citing">Citing</a></li>
      
        <li><a href="https://numfocus.salsalabs.org/donate-to-fenics/index.html">Donate</a></li>
      
    </ul>
  </nav>
</div>

  </header>
</div>

  <div id="header_wrap" class="outer" style="background-image:url(https://fenicsproject.org/assets/img/default-bg.png);background-repeat:repeat">

  <header class="inner">
  <h1 id="project_title">Basix 0.7.0.0
</h1>
  </header>
</div>


<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner"><h2 id="project_subtitle"><a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/index.html'>Home</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/install.html'>Installation</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python/demo'>Demos</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/cpp'>C++ docs</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python'>Python docs</a>
</h2>  </section>
</div>
    
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="dof-permutations-and-transformations">
<h1>DOF permutations and transformations<a class="headerlink" href="#dof-permutations-and-transformations" title="Permalink to this heading">¶</a></h1>
<p>When using high degree finite elements on general meshes, adjustments
may need to be made to correct for differences in the orientation of
mesh entities on the mesh and on the reference cell. For example, in
a degree 4 Lagrange element on a triangle, there are 3 degrees of
freedom (DOFs) associated with each edge. If two neighbouring cells in
a mesh disagree on the direction of the edge, they could put an
incorrectly combine the local basis functions to give the wrong global
basis function.</p>
<p>This issue and the use of permutations and transformations to correct
it is discussed in detail in <a class="reference external" href="https://arxiv.org/abs/2102.11901">Construction of arbitrary order finite
element degree-of-freedom maps on polygonal and polyhedral cell
meshes (Scroggs, Dokken, Richardons, Wells,
2021)</a>.</p>
<p>Functions to permute and transform high degree elements are
provided by Basix. In this demo, we show how these can be used.</p>
<p>First, we import Basix and Numpy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">basix</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">basix</span> <span class="kn">import</span> <span class="n">ElementFamily</span><span class="p">,</span> <span class="n">CellType</span><span class="p">,</span> <span class="n">LagrangeVariant</span><span class="p">,</span> <span class="n">LatticeType</span>
</pre></div>
</div>
<section id="degree-5-lagrange-element">
<h2>Degree 5 Lagrange element<a class="headerlink" href="#degree-5-lagrange-element" title="Permalink to this heading">¶</a></h2>
<p>We create a degree 5 Lagrange element on a triangle, then print the
values of the attributes <cite>dof_transformations_are_identity</cite> and
<cite>dof_transformations_are_permutations</cite>.</p>
<p>The value of <cite>dof_transformations_are_identity</cite> is False: this tells
us that permutations or transformations are needed for this element.</p>
<p>The value of <cite>dof_transformations_are_permutations</cite> is True: this
tells us that for this element, all the corrections we need to apply
permutations. This is the simpler case, and means we make the
orientation corrections by applying permutations when creating the
DOF map.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lagrange</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">create_element</span><span class="p">(</span>
    <span class="n">ElementFamily</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">CellType</span><span class="o">.</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">LagrangeVariant</span><span class="o">.</span><span class="n">equispaced</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lagrange</span><span class="o">.</span><span class="n">dof_transformations_are_identity</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lagrange</span><span class="o">.</span><span class="n">dof_transformations_are_permutations</span><span class="p">)</span>
</pre></div>
</div>
<p>We can apply permutations by using the matrices returned by the
method <cite>base_transformations</cite>. This method will return one matrix
for each edge of the cell (for 2D and 3D cells), and two matrices
for each face of the cell (for 3D cells). These describe the effect
of reversing the edge or reflecting and rotating the face.</p>
<p>For this element, we know that the base transformations will be
permutation matrices.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lagrange</span><span class="o">.</span><span class="n">base_transformations</span><span class="p">())</span>
</pre></div>
</div>
<p>The matrices returned by <cite>base_transformations</cite> are quite large, and
are equal to the identity matrix except for a small block of the
matrix. It is often easier and more efficient to use the matrices
returned by the method <cite>entity_transformations</cite> instead.</p>
<p><cite>entity_transformations</cite> returns a dictionary that maps the type
of entity (<cite>“interval”</cite>, <cite>“triangle”</cite>, <cite>“quadrilateral”</cite>) to a
matrix describing the effect of permuting that entity on the DOFs
on that entity.</p>
<p>For this element, we see that this method returns one matrix for
an interval: this matrix reverses the order of the four DOFs
associated with that edge.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lagrange</span><span class="o">.</span><span class="n">entity_transformations</span><span class="p">())</span>
</pre></div>
</div>
<p>In orders to work out which DOFs are associated with each edge,
we use the attribute <cite>entity_dofs</cite>. For example, the following can
be used to see which DOF numbers are associated with edge (dim 1)
number 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lagrange</span><span class="o">.</span><span class="n">entity_dofs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="degree-2-lagrange-element">
<h2>Degree 2 Lagrange element<a class="headerlink" href="#degree-2-lagrange-element" title="Permalink to this heading">¶</a></h2>
<p>For a degree 2 Lagrange element, no permutations or transformations
are needed. We can verify this by checking that
<cite>dof_transformations_are_identity</cite> is <cite>True</cite>. To confirm that the
transformations are identity matrices, we also print the base
transformations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lagrange_degree_2</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">create_element</span><span class="p">(</span>
    <span class="n">ElementFamily</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">CellType</span><span class="o">.</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">LagrangeVariant</span><span class="o">.</span><span class="n">equispaced</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lagrange_degree_2</span><span class="o">.</span><span class="n">dof_transformations_are_identity</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lagrange_degree_2</span><span class="o">.</span><span class="n">base_transformations</span><span class="p">())</span>
</pre></div>
</div>
</section>
<section id="degree-2-nedelec-element">
<h2>Degree 2 Nédélec element<a class="headerlink" href="#degree-2-nedelec-element" title="Permalink to this heading">¶</a></h2>
<p>For a degree 2 Nédélec (first kind) element on a tetrahedron, the
corrections are not all permutations, so both
<cite>dof_transformations_are_identity</cite> and
<cite>dof_transformations_are_permutations</cite> are <cite>False</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nedelec</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">create_element</span><span class="p">(</span><span class="n">ElementFamily</span><span class="o">.</span><span class="n">N1E</span><span class="p">,</span> <span class="n">CellType</span><span class="o">.</span><span class="n">tetrahedron</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nedelec</span><span class="o">.</span><span class="n">dof_transformations_are_identity</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nedelec</span><span class="o">.</span><span class="n">dof_transformations_are_permutations</span><span class="p">)</span>
</pre></div>
</div>
<p>For this element, <cite>entity_transformations</cite> returns a dictionary
with two entries: a matrix for an interval that describes
the effect of reversing the edge; and an array of two matrices
for a triangle. The first matrix for the triangle describes
the effect of rotating the triangle. The second matrix describes
the effect of reflecting the triangle.</p>
<p>For this element, the matrix describing the effect of rotating
the triangle is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left(\begin{array}{cc}-1&amp;-1\\1&amp;0\end{array}\right).\end{split}\]</div>
<p>This is not a permutation, so this must be applied when assembling
a form and cannot be applied to the DOF numbering in the DOF map.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">nedelec</span><span class="o">.</span><span class="n">entity_transformations</span><span class="p">())</span>
</pre></div>
</div>
<p>To demonstrate how these transformations can be used, we create a
lattice of points where we will tabulate the element.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">create_lattice</span><span class="p">(</span>
    <span class="n">CellType</span><span class="o">.</span><span class="n">tetrahedron</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">LatticeType</span><span class="o">.</span><span class="n">equispaced</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If (for example) the direction of edge 2 in the physical cell does
not match its direction on the reference, then we need to adjust the
tabulated data.</p>
<p>As the cell sub-entity that we are correcting is an interval, we
get the <cite>“interval”</cite> item from the entity transformations dictionary.
We use <cite>entity_dofs[1][2]</cite> (1 is the dimension of an edge, 2 is the
index of the edge we are reversing) to find out which dofs are on
our edge.</p>
<p>To adjust the tabulated data, we loop over each point in the lattice
and over the value size. For each of these values, we apply the
transformation matrix to the relevant DOFs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">nedelec</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

<span class="n">transformation</span> <span class="o">=</span> <span class="n">nedelec</span><span class="o">.</span><span class="n">entity_transformations</span><span class="p">()[</span><span class="s2">&quot;interval&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dofs</span> <span class="o">=</span> <span class="n">nedelec</span><span class="o">.</span><span class="n">entity_dofs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>More efficient functions that apply the transformations and
permutations directly to data can be used via Basix’s C++
interface.</p>
</section>
<section id="c-demo">
<h2>C++ demo<a class="headerlink" href="#c-demo" title="Permalink to this heading">¶</a></h2>
<p>The following C++ code runs the same demo using Basix’s C++ interface:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ====================================</span>
<span class="c1">// DOF permutations and transformations</span>
<span class="c1">// ====================================</span>

<span class="c1">// When using high degree finite elements on general meshes, adjustments</span>
<span class="c1">// may need to be made to correct for differences in the orientation of</span>
<span class="c1">// mesh entities on the mesh and on the reference cell. For example, in</span>
<span class="c1">// a degree 4 Lagrange element on a triangle, there are 3 degrees of</span>
<span class="c1">// freedom (DOFs) associated with each edge. If two neighbouring cells in</span>
<span class="c1">// a mesh disagree on the direction of the edge, they could put an</span>
<span class="c1">// incorrectly combine the local basis functions to give the wrong global</span>
<span class="c1">// basis function.</span>

<span class="c1">// This issue and the use of permutations and transformations to correct</span>
<span class="c1">// it is discussed in detail in `Construction of arbitrary order finite</span>
<span class="c1">// element degree-of-freedom maps on polygonal and polyhedral cell</span>
<span class="c1">// meshes (Scroggs, Dokken, Richardons, Wells,</span>
<span class="c1">// 2021) &lt;https://arxiv.org/abs/2102.11901&gt;`_.</span>

<span class="c1">// Functions to permute and transform high degree elements are</span>
<span class="c1">// provided by Basix. In this demo, we show how these can be used from C++.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;basix/finite-element.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;basix/lattice.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iomanip&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">type_to_name</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;point&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">interval</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;interval&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">triangle</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;triangle&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">tetrahedron</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tetrahedron&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">quadrilateral</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;quadrilateral&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">pyramid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pyramid&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">prism</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;prism&quot;</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">hexahedron</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hexahedron&quot;</span><span class="p">}};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Degree 5 Lagrange element</span>
<span class="w">  </span><span class="c1">// =========================</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Degree 5 Lagrange element&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create a degree 5 Lagrange element on a triangle</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">family</span><span class="o">::</span><span class="n">P</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">cell_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">triangle</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">degree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">variant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">lagrange_variant</span><span class="o">::</span><span class="n">equispaced</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create the lagrange element</span>
<span class="w">    </span><span class="n">basix</span><span class="o">::</span><span class="n">FiniteElement</span><span class="w"> </span><span class="n">lagrange</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">create_element</span><span class="p">(</span><span class="n">family</span><span class="p">,</span><span class="w"> </span><span class="n">cell_type</span><span class="p">,</span><span class="w"> </span><span class="n">degree</span><span class="p">,</span><span class="w"> </span><span class="n">variant</span><span class="p">,</span>
<span class="w">                                </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">dpc_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print bools as true/false instead of 0/1</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The value of `dof_transformations_are_identity` is `false`: this tells</span>
<span class="w">    </span><span class="c1">// us that permutations or transformations are needed for this element.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are identity: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">dof_transformations_are_identity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The value of `dof_transformations_are_permutations` is `true`: this</span>
<span class="w">    </span><span class="c1">// tells us that for this element, all the corrections we need to apply</span>
<span class="w">    </span><span class="c1">// permutations. This is the simpler case, and means we make the</span>
<span class="w">    </span><span class="c1">// orientation corrections by applying permutations when creating the</span>
<span class="w">    </span><span class="c1">// DOF map.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are permutations: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">dof_transformations_are_permutations</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// We can apply permutations by using the matrices returned by the</span>
<span class="w">    </span><span class="c1">// method `base_transformations`. This method will return one matrix</span>
<span class="w">    </span><span class="c1">// for each edge of the cell (for 2D and 3D cells), and two matrices</span>
<span class="w">    </span><span class="c1">// for each face of the cell (for 3D cells). These describe the effect</span>
<span class="w">    </span><span class="c1">// of reversing the edge or reflecting and rotating the face.</span>

<span class="w">    </span><span class="c1">// For this element, we know that the base transformations will be</span>
<span class="w">    </span><span class="c1">// permutation matrices.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">trans</span><span class="p">,</span><span class="w"> </span><span class="n">tshape</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">base_transformations</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// std::cout &lt;&lt; std::endl &lt;&lt; &quot;Base transformations:&quot; &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// std::cout &lt;&lt; xt::adapt(trans, tshape) &lt;&lt; std::endl;</span>

<span class="w">    </span><span class="c1">// The matrices returned by `base_transformations` are quite large, and</span>
<span class="w">    </span><span class="c1">// are equal to the identity matrix except for a small block of the</span>
<span class="w">    </span><span class="c1">// matrix. It is often easier and more efficient to use the matrices</span>
<span class="w">    </span><span class="c1">// returned by the method `entity_transformations` instead.</span>

<span class="w">    </span><span class="c1">// `entity_transformations` returns a dictionary that maps the type</span>
<span class="w">    </span><span class="c1">// of entity (`&quot;interval&quot;`, `&quot;triangle&quot;`, `&quot;quadrilateral&quot;`) to a</span>
<span class="w">    </span><span class="c1">// matrix describing the effect of permuting that entity on the DOFs</span>
<span class="w">    </span><span class="c1">// on that entity.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">entity_transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">entity_transformations</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// std::cout &lt;&lt; std::endl &lt;&lt; &quot;Entity transformations:&quot; &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// for (auto const&amp; [cell, transformation] : entity_transformation)</span>
<span class="w">    </span><span class="c1">// {</span>
<span class="w">    </span><span class="c1">//   std::cout &lt;&lt; &quot; -&quot; &lt;&lt; type_to_name.at(cell) &lt;&lt; &quot;:&quot; &lt;&lt; std::endl</span>
<span class="w">    </span><span class="c1">//             &lt;&lt; xt::adapt(transformation.first, transformation.second)</span>
<span class="w">    </span><span class="c1">//             &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// }</span>

<span class="w">    </span><span class="c1">// For this element, we see that this method returns one matrix for</span>
<span class="w">    </span><span class="c1">// an interval: this matrix reverses the order of the four DOFs</span>
<span class="w">    </span><span class="c1">// associated with that edge.</span>

<span class="w">    </span><span class="c1">// In orders to work out which DOFs are associated with each edge,</span>
<span class="w">    </span><span class="c1">// we use the attribute `entity_dofs`. For example, the following can</span>
<span class="w">    </span><span class="c1">// be used to see which DOF numbers are associated with edge (dim 1)</span>
<span class="w">    </span><span class="c1">// number 2:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">edge_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">entity_dofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">entity_dofs</span><span class="p">()[</span><span class="n">dim</span><span class="p">][</span><span class="n">edge_num</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Entity dofs of Edge number 2: &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">dof</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">entity_dofs</span><span class="p">)</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dof</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Degree 2 Lagrange element</span>
<span class="w">  </span><span class="c1">// =========================</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// For a degree 2 Lagrange element, no permutations or transformations</span>
<span class="w">    </span><span class="c1">// are needed.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Degree 2 Lagrange element&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">family</span><span class="o">::</span><span class="n">P</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">cell_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">triangle</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">degree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">variant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">lagrange_variant</span><span class="o">::</span><span class="n">equispaced</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create the lagrange element</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lagrange</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">create_element</span><span class="p">(</span><span class="n">family</span><span class="p">,</span><span class="w"> </span><span class="n">cell_type</span><span class="p">,</span><span class="w"> </span><span class="n">degree</span><span class="p">,</span><span class="w"> </span><span class="n">variant</span><span class="p">,</span>
<span class="w">                                </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">dpc_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// We can verify this by checking that`dof_transformations_are_identity` is</span>
<span class="w">    </span><span class="c1">// `True`. To confirm that the transformations are identity matrices, we</span>
<span class="w">    </span><span class="c1">// also print the base transformations.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are identity: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">dof_transformations_are_identity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are permutations: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lagrange</span><span class="p">.</span><span class="n">dof_transformations_are_permutations</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Degree 2 Nédélec element</span>
<span class="w">  </span><span class="c1">// ========================</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Degree 2 Nedelec element&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// For a degree 2 Nédélec (first kind) element on a tetrahedron, the</span>
<span class="w">    </span><span class="c1">// corrections are not all permutations, so both</span>
<span class="w">    </span><span class="c1">// `dof_transformations_are_identity` and</span>
<span class="w">    </span><span class="c1">// `dof_transformations_are_permutations` are `False`.</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">family</span><span class="o">::</span><span class="n">N1E</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">cell_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">tetrahedron</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">degree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">nedelec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">create_element</span><span class="p">(</span>
<span class="w">        </span><span class="n">family</span><span class="p">,</span><span class="w"> </span><span class="n">cell_type</span><span class="p">,</span><span class="w"> </span><span class="n">degree</span><span class="p">,</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">lagrange_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span>
<span class="w">        </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">dpc_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are identity: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nedelec</span><span class="p">.</span><span class="n">dof_transformations_are_identity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dof transformations are permutations: &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nedelec</span><span class="p">.</span><span class="n">dof_transformations_are_permutations</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For this element, `entity_transformations` returns a map</span>
<span class="w">    </span><span class="c1">// with two entries: a matrix for an interval that describes</span>
<span class="w">    </span><span class="c1">// the effect of reversing the edge; and an array of two matrices</span>
<span class="w">    </span><span class="c1">// for a triangle. The first matrix for the triangle describes</span>
<span class="w">    </span><span class="c1">// the effect of rotating the triangle. The second matrix describes</span>
<span class="w">    </span><span class="c1">// the effect of reflecting the triangle.</span>

<span class="w">    </span><span class="c1">// For this element, the matrix describing the effect of rotating</span>
<span class="w">    </span><span class="c1">// the triangle is</span>

<span class="w">    </span><span class="c1">// .. math::</span>
<span class="w">    </span><span class="c1">//    \left(\begin{array}{cc}-1&amp;-1\\1&amp;0\end{array}\right).</span>

<span class="w">    </span><span class="c1">// This is not a permutation, so this must be applied when assembling</span>
<span class="w">    </span><span class="c1">// a form and cannot be applied to the DOF numbering in the DOF map.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">entity__transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nedelec</span><span class="p">.</span><span class="n">entity_transformations</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// std::cout &lt;&lt; std::endl &lt;&lt; &quot;Entity transformations:&quot; &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// for (auto&amp; [cell, transformation] : entity__transformation)</span>
<span class="w">    </span><span class="c1">// {</span>
<span class="w">    </span><span class="c1">//   std::cout &lt;&lt; &quot; -&quot; &lt;&lt; type_to_name.at(cell) &lt;&lt; &quot;:&quot; &lt;&lt; std::endl</span>
<span class="w">    </span><span class="c1">//             &lt;&lt; xt::adapt(transformation.first, transformation.second)</span>
<span class="w">    </span><span class="c1">//             &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="c1">// }</span>

<span class="w">    </span><span class="c1">// To demonstrate how these transformations can be used, we create a</span>
<span class="w">    </span><span class="c1">// lattice of points where we will tabulate the element.</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">pdata</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">lattice</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">cell_type</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">lattice</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">equispaced</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">mdspan</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span>
<span class="w">                              </span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">dextents</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="w">        </span><span class="n">points</span><span class="p">(</span><span class="n">pdata</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">shape</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If (for example) the direction of edge 2 in the physical cell does</span>
<span class="w">    </span><span class="c1">// not match its direction on the reference, then we need to adjust the</span>
<span class="w">    </span><span class="c1">// tabulated data.</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">original_data</span><span class="p">,</span><span class="w"> </span><span class="n">orig_shape</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nedelec</span><span class="p">.</span><span class="n">tabulate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">points</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">mod_data</span><span class="p">,</span><span class="w"> </span><span class="n">mod_shape</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nedelec</span><span class="p">.</span><span class="n">tabulate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">points</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">mod_data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">mod_data</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// If the direction of edge 2 in the physical cell is reflected, it has</span>
<span class="w">    </span><span class="c1">// cell permutation info `....000010` so (from right to left):</span>
<span class="w">    </span><span class="c1">//      - edge 0 is not permuted (0)</span>
<span class="w">    </span><span class="c1">//      - edge 1 is reflected (1)</span>
<span class="w">    </span><span class="c1">//      - edge 2 is not permuted (0)</span>
<span class="w">    </span><span class="c1">//      - edge 3 is not permuted (0)</span>
<span class="w">    </span><span class="c1">//      - edge 4 is not permuted (0)</span>
<span class="w">    </span><span class="c1">//      - edge 5 is not permuted (0)</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cell_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b000010</span><span class="p">;</span>
<span class="w">    </span><span class="n">nedelec</span><span class="p">.</span><span class="n">apply_dof_transformation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">num_points</span><span class="p">,</span><span class="w"> </span><span class="n">cell_info</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// std::cout &lt;&lt; std::endl</span>
<span class="w">    </span><span class="c1">//           &lt;&lt; &quot;Tabulated data is equal: &quot;</span>
<span class="w">    </span><span class="c1">//           &lt;&lt; xt::allclose(xt::adapt(original_data), xt::adapt(mod_data))</span>
<span class="w">    </span><span class="c1">//           &lt;&lt; std::endl;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Basix</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_autosummary/basix.html">basix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Demos</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="demo_create_and_tabulate.py.html">Creating and tabulating an element</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_quadrature.py.html">Creating and using a quadrature rule</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_facet_integral.py.html">Computing a facet integral</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_lagrange_variants.py.html">Variants of Lagrange elements</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">DOF permutations and transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#degree-5-lagrange-element">Degree 5 Lagrange element</a></li>
<li class="toctree-l3"><a class="reference internal" href="#degree-2-lagrange-element">Degree 2 Lagrange element</a></li>
<li class="toctree-l3"><a class="reference internal" href="#degree-2-nedelec-element">Degree 2 Nédélec element</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-demo">C++ demo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="demo_custom_element.py.html">Creating a custom element</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_custom_element_conforming_cr.py.html">Defining conforming Crouzeix–Raviart elements</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Demos</a><ul>
      <li>Previous: <a href="demo_lagrange_variants.py.html" title="previous chapter">Variants of Lagrange elements</a></li>
      <li>Next: <a href="demo_custom_element.py.html" title="next chapter">Creating a custom element</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    &copy; FEniCS Project 2021. Changes to this website can be made/suggested on <a href='https://github.com/FEniCS/web'>GitHub</a>.
  </footer>
</div>




    <div class="footer">
      &copy;2023, FEniCS Project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/demo/demo_dof_transformations.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
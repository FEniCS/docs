<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="https://fenicsproject.org/assets/css/style.css?v=2023-12-11">
    <link rel="apple-touch-icon" sizes="57x57" href="https://fenicsproject.org/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://fenicsproject.org/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://fenicsproject.org/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://fenicsproject.org/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://fenicsproject.org/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://fenicsproject.org/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://fenicsproject.org/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://fenicsproject.org/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://fenicsproject.org/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://fenicsproject.org/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://fenicsproject.org/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://fenicsproject.org/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://fenicsproject.org/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="https://fenicsproject.org/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#555555">
    <meta name="msapplication-TileImage" content="https://fenicsproject.org/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#555555">
    <link rel="stylesheet" type="text/css" href="https://fenicsproject.org/assets/css/customsty.css">
   <link rel="stylesheet" type="text/css" href="/assets/sty.css">
    <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://fenicsproject.org/assets/fontawesome/js/fontawesome.js"></script>
    <script src="https://fenicsproject.org/assets/fontawesome/js/brands.js"></script>
    <script src="https://fenicsproject.org/assets/fontawesome/js/solid.js"></script>
    <script type='text/javascript'>
document.getElementById("MathJax-script").addEventListener('load', function () {
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['[[',']]']]
  },
  svg: {
    fontCache: 'global'
  }
}});
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basix: basix::FiniteElement&lt; F &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
  </head>
<body>
<!-- HEADER -->
<div id="nav_head">
  <header class="inner" id="nav_head_inner">
    <a id="logo" href="https://fenicsproject.org/"><img src="https://fenicsproject.org/assets/img/fenics-logo-small.png"></a>
    <div class="top-navigation">
  <nav role="navigation" id="site-nav" class="nav">
    <ul>
        <li><a href="https://fenicsproject.org/">Home</a></li>
        <li><a href="https://fenicsproject.org/fenics-2026">FEniCS 2026</a></li>
        <li><a href="https://fenicsproject.org/download">Download</a></li>
        <li><a href="https://fenicsproject.org/documentation">Documentation</a></li>
        <li><a href="https://fenicsproject.org/community">Community</a></li>
        <li><a href="https://fenicsproject.org/citing">Citing</a></li>
        <li><a href="https://numfocus.org/donate-to-fenics"><i class="fa-solid fa-arrow-up-right-from-square"></i> Donate</a></li>
    </ul>
  </nav>
</div>
  </header>
</div>
  <div id="header_wrap" class="outer" style="background-image:url(https://fenicsproject.org/assets/img/headers/fenics_fire.png);background-repeat:repeat">
  <header class="inner lesstall">
  <h1 id="project_title">Basix 0.10.0.dev0</h1>
  </header>
</div>
<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <h2 id="project_subtitle"><a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/index.html'>Home</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/install.html'>Installation</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python/demo'>Demos</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/cpp'>C++ docs</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python'>Python docs</a>
</h2><div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbasix_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basix::FiniteElement&lt; F &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A finite element.  
 <a href="classbasix_1_1FiniteElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="finite-element_8h_source.html">finite-element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a69874abe87cbb9a42218c987747c1fde"><td class="memItemLeft" align="right" valign="top"><a id="a69874abe87cbb9a42218c987747c1fde"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a69874abe87cbb9a42218c987747c1fde">scalar_type</a> = F</td></tr>
<tr class="memdesc:a69874abe87cbb9a42218c987747c1fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type. <br /></td></tr>
<tr class="separator:a69874abe87cbb9a42218c987747c1fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f8794de82cfc63ce8e40fad99802dfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a5f8794de82cfc63ce8e40fad99802dfe">FiniteElement</a> (<a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> <a class="el" href="classbasix_1_1FiniteElement.html#af632d219b4c4b9f6a23ea124208c678e">family</a>, <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#ad2854ed6e5dc06d0ed73420909ac407e">cell_type</a>, <a class="el" href="namespacebasix_1_1polyset.html#a04ec1a9561f875220b50ad2076cd35c2">polyset::type</a> poly_type, int <a class="el" href="classbasix_1_1FiniteElement.html#a8be3154c07a9cc7aa2bb2233ae191590">degree</a>, const std::vector&lt; std::size_t &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a8b157bb6a943f276989823dac4dd9884">value_shape</a>, mdspan_t&lt; const F, 2 &gt; <a class="el" href="classbasix_1_1FiniteElement.html#a1d09752dd03b15e15fdfb50a38ba9814">wcoeffs</a>, const std::array&lt; std::vector&lt; mdspan_t&lt; const F, 2 &gt;&gt;, 4 &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a>, const std::array&lt; std::vector&lt; mdspan_t&lt; const F, 4 &gt;&gt;, 4 &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a1e7f2fed5734ed3118a74cb836370611">M</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a51b364ec6c8681526d3f6a15802e21c1">interpolation_nderivs</a>, <a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#ade11e85f802d692a00c0368490fbf25d">map_type</a>, <a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a> <a class="el" href="classbasix_1_1FiniteElement.html#a9b69240399a8db8705ba4305e88e34d1">sobolev_space</a>, bool <a class="el" href="classbasix_1_1FiniteElement.html#ad8f6272cb60e88215d3a85d058d87b9a">discontinuous</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a41f96560b78b0cc38a3ae7d5eb45eec3">embedded_subdegree</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a555d2234569e64d1983d8cf9a1fcf48c">embedded_superdegree</a>, <a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a> lvariant, <a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a> dvariant, std::vector&lt; int &gt; <a class="el" href="classbasix_1_1FiniteElement.html#a12145f082817587bd17ede85cb251706">dof_ordering</a>={})</td></tr>
<tr class="memdesc:a5f8794de82cfc63ce8e40fad99802dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a finite element.  <a href="classbasix_1_1FiniteElement.html#a5f8794de82cfc63ce8e40fad99802dfe">More...</a><br /></td></tr>
<tr class="separator:a5f8794de82cfc63ce8e40fad99802dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f059df079ea875e2768b650ef71ac3b"><td class="memItemLeft" align="right" valign="top"><a id="a9f059df079ea875e2768b650ef71ac3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9f059df079ea875e2768b650ef71ac3b">FiniteElement</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a9f059df079ea875e2768b650ef71ac3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a9f059df079ea875e2768b650ef71ac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a61c4b3ff76e3136c87c998674be332"><td class="memItemLeft" align="right" valign="top"><a id="a4a61c4b3ff76e3136c87c998674be332"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4a61c4b3ff76e3136c87c998674be332">FiniteElement</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a4a61c4b3ff76e3136c87c998674be332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a4a61c4b3ff76e3136c87c998674be332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa215db93b256313aeffdc5a85ea4780"><td class="memItemLeft" align="right" valign="top"><a id="afa215db93b256313aeffdc5a85ea4780"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#afa215db93b256313aeffdc5a85ea4780">~FiniteElement</a> ()=default</td></tr>
<tr class="memdesc:afa215db93b256313aeffdc5a85ea4780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:afa215db93b256313aeffdc5a85ea4780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc7f3a482d24985b474a8b061dc41b"><td class="memItemLeft" align="right" valign="top"><a id="a98bc7f3a482d24985b474a8b061dc41b"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a98bc7f3a482d24985b474a8b061dc41b">operator=</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a98bc7f3a482d24985b474a8b061dc41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a98bc7f3a482d24985b474a8b061dc41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4844b665541542aa3d0bc5b60ee5cce"><td class="memItemLeft" align="right" valign="top"><a id="ad4844b665541542aa3d0bc5b60ee5cce"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad4844b665541542aa3d0bc5b60ee5cce">operator=</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:ad4844b665541542aa3d0bc5b60ee5cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:ad4844b665541542aa3d0bc5b60ee5cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c8049d19ca40e09189498feeee720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a369c8049d19ca40e09189498feeee720">operator==</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;e) const</td></tr>
<tr class="memdesc:a369c8049d19ca40e09189498feeee720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are the same.  <a href="classbasix_1_1FiniteElement.html#a369c8049d19ca40e09189498feeee720">More...</a><br /></td></tr>
<tr class="separator:a369c8049d19ca40e09189498feeee720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681d4d8877ceb0c66be098804ce19a4e"><td class="memItemLeft" align="right" valign="top"><a id="a681d4d8877ceb0c66be098804ce19a4e"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a681d4d8877ceb0c66be098804ce19a4e">hash</a> () const</td></tr>
<tr class="memdesc:a681d4d8877ceb0c66be098804ce19a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unique hash of this element. <br /></td></tr>
<tr class="separator:a681d4d8877ceb0c66be098804ce19a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bfad3598917d05db627e06c8fe4399"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::size_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a97bfad3598917d05db627e06c8fe4399">tabulate_shape</a> (std::size_t nd, std::size_t num_points) const</td></tr>
<tr class="memdesc:a97bfad3598917d05db627e06c8fe4399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array shape for tabulate basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a97bfad3598917d05db627e06c8fe4399">More...</a><br /></td></tr>
<tr class="separator:a97bfad3598917d05db627e06c8fe4399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b81aa1517fa85f40ab8d7e763627d4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a53b81aa1517fa85f40ab8d7e763627d4">tabulate</a> (int nd, impl::mdspan_t&lt; const F, 2 &gt; <a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a>) const</td></tr>
<tr class="memdesc:a53b81aa1517fa85f40ab8d7e763627d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a53b81aa1517fa85f40ab8d7e763627d4">More...</a><br /></td></tr>
<tr class="separator:a53b81aa1517fa85f40ab8d7e763627d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bbbe513ce61cfe4df1e630f2534832"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a27bbbe513ce61cfe4df1e630f2534832">tabulate</a> (int nd, std::span&lt; const F &gt; <a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a>, std::array&lt; std::size_t, 2 &gt; shape) const</td></tr>
<tr class="memdesc:a27bbbe513ce61cfe4df1e630f2534832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a27bbbe513ce61cfe4df1e630f2534832">More...</a><br /></td></tr>
<tr class="separator:a27bbbe513ce61cfe4df1e630f2534832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c8c78c3bd964c05b3dd593bf0e122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a318c8c78c3bd964c05b3dd593bf0e122">tabulate</a> (int nd, impl::mdspan_t&lt; const F, 2 &gt; <a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a>, mdspan_t&lt; F, 4 &gt; basis) const</td></tr>
<tr class="memdesc:a318c8c78c3bd964c05b3dd593bf0e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a318c8c78c3bd964c05b3dd593bf0e122">More...</a><br /></td></tr>
<tr class="separator:a318c8c78c3bd964c05b3dd593bf0e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39071d50e9e7777a642f515c545cc9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a39071d50e9e7777a642f515c545cc9ef">tabulate</a> (int nd, std::span&lt; const F &gt; <a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a>, std::array&lt; std::size_t, 2 &gt; xshape, std::span&lt; F &gt; basis) const</td></tr>
<tr class="memdesc:a39071d50e9e7777a642f515c545cc9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a39071d50e9e7777a642f515c545cc9ef">More...</a><br /></td></tr>
<tr class="separator:a39071d50e9e7777a642f515c545cc9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2854ed6e5dc06d0ed73420909ac407e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad2854ed6e5dc06d0ed73420909ac407e">cell_type</a> () const</td></tr>
<tr class="memdesc:ad2854ed6e5dc06d0ed73420909ac407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element cell type.  <a href="classbasix_1_1FiniteElement.html#ad2854ed6e5dc06d0ed73420909ac407e">More...</a><br /></td></tr>
<tr class="separator:ad2854ed6e5dc06d0ed73420909ac407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cbe1b35a2ab85fc8a85730fb76f0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1polyset.html#a04ec1a9561f875220b50ad2076cd35c2">polyset::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ab8cbe1b35a2ab85fc8a85730fb76f0a4">polyset_type</a> () const</td></tr>
<tr class="memdesc:ab8cbe1b35a2ab85fc8a85730fb76f0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element polyset type.  <a href="classbasix_1_1FiniteElement.html#ab8cbe1b35a2ab85fc8a85730fb76f0a4">More...</a><br /></td></tr>
<tr class="separator:ab8cbe1b35a2ab85fc8a85730fb76f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be3154c07a9cc7aa2bb2233ae191590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8be3154c07a9cc7aa2bb2233ae191590">degree</a> () const</td></tr>
<tr class="memdesc:a8be3154c07a9cc7aa2bb2233ae191590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element polynomial degree.  <a href="classbasix_1_1FiniteElement.html#a8be3154c07a9cc7aa2bb2233ae191590">More...</a><br /></td></tr>
<tr class="separator:a8be3154c07a9cc7aa2bb2233ae191590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555d2234569e64d1983d8cf9a1fcf48c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a555d2234569e64d1983d8cf9a1fcf48c">embedded_superdegree</a> () const</td></tr>
<tr class="memdesc:a555d2234569e64d1983d8cf9a1fcf48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest degree <code>n</code> such that the highest degree polynomial in this element is contained in a Lagrange (or vector Lagrange) element of degree <code>n</code>.  <a href="classbasix_1_1FiniteElement.html#a555d2234569e64d1983d8cf9a1fcf48c">More...</a><br /></td></tr>
<tr class="separator:a555d2234569e64d1983d8cf9a1fcf48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f96560b78b0cc38a3ae7d5eb45eec3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a41f96560b78b0cc38a3ae7d5eb45eec3">embedded_subdegree</a> () const</td></tr>
<tr class="memdesc:a41f96560b78b0cc38a3ae7d5eb45eec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest degree <code>n</code> such that a Lagrange (or vector Lagrange) element of degree n is a subspace of this element.  <a href="classbasix_1_1FiniteElement.html#a41f96560b78b0cc38a3ae7d5eb45eec3">More...</a><br /></td></tr>
<tr class="separator:a41f96560b78b0cc38a3ae7d5eb45eec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b157bb6a943f276989823dac4dd9884"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8b157bb6a943f276989823dac4dd9884">value_shape</a> () const</td></tr>
<tr class="memdesc:a8b157bb6a943f276989823dac4dd9884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element value tensor shape.  <a href="classbasix_1_1FiniteElement.html#a8b157bb6a943f276989823dac4dd9884">More...</a><br /></td></tr>
<tr class="separator:a8b157bb6a943f276989823dac4dd9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b59d24da952b7c590d97d929e7eb5eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a5b59d24da952b7c590d97d929e7eb5eb">dim</a> () const</td></tr>
<tr class="memdesc:a5b59d24da952b7c590d97d929e7eb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the finite element space.  <a href="classbasix_1_1FiniteElement.html#a5b59d24da952b7c590d97d929e7eb5eb">More...</a><br /></td></tr>
<tr class="separator:a5b59d24da952b7c590d97d929e7eb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af632d219b4c4b9f6a23ea124208c678e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#af632d219b4c4b9f6a23ea124208c678e">family</a> () const</td></tr>
<tr class="memdesc:af632d219b4c4b9f6a23ea124208c678e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The finite element family.  <a href="classbasix_1_1FiniteElement.html#af632d219b4c4b9f6a23ea124208c678e">More...</a><br /></td></tr>
<tr class="separator:af632d219b4c4b9f6a23ea124208c678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc685192a3bcd2ae6e6dca2fbc92901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a7cc685192a3bcd2ae6e6dca2fbc92901">lagrange_variant</a> () const</td></tr>
<tr class="memdesc:a7cc685192a3bcd2ae6e6dca2fbc92901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lagrange variant of the element.  <a href="classbasix_1_1FiniteElement.html#a7cc685192a3bcd2ae6e6dca2fbc92901">More...</a><br /></td></tr>
<tr class="separator:a7cc685192a3bcd2ae6e6dca2fbc92901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae98c4a939f1d98d11943c67496b236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aeae98c4a939f1d98d11943c67496b236">dpc_variant</a> () const</td></tr>
<tr class="memdesc:aeae98c4a939f1d98d11943c67496b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">DPC variant of the element.  <a href="classbasix_1_1FiniteElement.html#aeae98c4a939f1d98d11943c67496b236">More...</a><br /></td></tr>
<tr class="separator:aeae98c4a939f1d98d11943c67496b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade11e85f802d692a00c0368490fbf25d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ade11e85f802d692a00c0368490fbf25d">map_type</a> () const</td></tr>
<tr class="memdesc:ade11e85f802d692a00c0368490fbf25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map type for the element.  <a href="classbasix_1_1FiniteElement.html#ade11e85f802d692a00c0368490fbf25d">More...</a><br /></td></tr>
<tr class="separator:ade11e85f802d692a00c0368490fbf25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b69240399a8db8705ba4305e88e34d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9b69240399a8db8705ba4305e88e34d1">sobolev_space</a> () const</td></tr>
<tr class="memdesc:a9b69240399a8db8705ba4305e88e34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying Sobolev space for this element.  <a href="classbasix_1_1FiniteElement.html#a9b69240399a8db8705ba4305e88e34d1">More...</a><br /></td></tr>
<tr class="separator:a9b69240399a8db8705ba4305e88e34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6272cb60e88215d3a85d058d87b9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad8f6272cb60e88215d3a85d058d87b9a">discontinuous</a> () const</td></tr>
<tr class="memdesc:ad8f6272cb60e88215d3a85d058d87b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this element is the discontinuous variant.  <a href="classbasix_1_1FiniteElement.html#ad8f6272cb60e88215d3a85d058d87b9a">More...</a><br /></td></tr>
<tr class="separator:ad8f6272cb60e88215d3a85d058d87b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6e3560616e17ea9621c64a5800cd48"><td class="memItemLeft" align="right" valign="top"><a id="aca6e3560616e17ea9621c64a5800cd48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aca6e3560616e17ea9621c64a5800cd48">dof_transformations_are_permutations</a> () const</td></tr>
<tr class="memdesc:aca6e3560616e17ea9621c64a5800cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the degree-of-freedom transformations are all permutations. <br /></td></tr>
<tr class="separator:aca6e3560616e17ea9621c64a5800cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305ea29cd89b0abc825b8bc335df4327"><td class="memItemLeft" align="right" valign="top"><a id="a305ea29cd89b0abc825b8bc335df4327"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a305ea29cd89b0abc825b8bc335df4327">dof_transformations_are_identity</a> () const</td></tr>
<tr class="memdesc:a305ea29cd89b0abc825b8bc335df4327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates is the dof transformations are all the identity. <br /></td></tr>
<tr class="separator:a305ea29cd89b0abc825b8bc335df4327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09c511d565978e3a5a50b7481561224"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad09c511d565978e3a5a50b7481561224">push_forward</a> (impl::mdspan_t&lt; const F, 3 &gt; U, impl::mdspan_t&lt; const F, 3 &gt; J, std::span&lt; const F &gt; detJ, impl::mdspan_t&lt; const F, 3 &gt; K) const</td></tr>
<tr class="memdesc:ad09c511d565978e3a5a50b7481561224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map function values from the reference to a physical cell.  <a href="classbasix_1_1FiniteElement.html#ad09c511d565978e3a5a50b7481561224">More...</a><br /></td></tr>
<tr class="separator:ad09c511d565978e3a5a50b7481561224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95e334dfd3afaccb83d898d27f3efcc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac95e334dfd3afaccb83d898d27f3efcc">pull_back</a> (impl::mdspan_t&lt; const F, 3 &gt; u, impl::mdspan_t&lt; const F, 3 &gt; J, std::span&lt; const F &gt; detJ, impl::mdspan_t&lt; const F, 3 &gt; K) const</td></tr>
<tr class="memdesc:ac95e334dfd3afaccb83d898d27f3efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map function values from a physical cell to the reference.  <a href="classbasix_1_1FiniteElement.html#ac95e334dfd3afaccb83d898d27f3efcc">More...</a><br /></td></tr>
<tr class="separator:ac95e334dfd3afaccb83d898d27f3efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582a08343f222f1571b7f700767fc705"><td class="memTemplParams" colspan="2">template&lt;typename O , typename P , typename Q , typename R &gt; </td></tr>
<tr class="memitem:a582a08343f222f1571b7f700767fc705"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(O &amp;, const P &amp;, const Q &amp;, F, const R &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a582a08343f222f1571b7f700767fc705">map_fn</a> () const</td></tr>
<tr class="memdesc:a582a08343f222f1571b7f700767fc705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function that performs the appropriate push-forward/pull-back for the element type.  <a href="classbasix_1_1FiniteElement.html#a582a08343f222f1571b7f700767fc705">More...</a><br /></td></tr>
<tr class="separator:a582a08343f222f1571b7f700767fc705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100cdb78027a12ffd295c43e6b7b117"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad100cdb78027a12ffd295c43e6b7b117">entity_dofs</a> () const</td></tr>
<tr class="memdesc:ad100cdb78027a12ffd295c43e6b7b117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dofs on each topological entity: (vertices, edges, faces, cell) in that order.  <a href="classbasix_1_1FiniteElement.html#ad100cdb78027a12ffd295c43e6b7b117">More...</a><br /></td></tr>
<tr class="separator:ad100cdb78027a12ffd295c43e6b7b117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e591f62b3e49663aa91143dd3fcebbe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4e591f62b3e49663aa91143dd3fcebbe">entity_closure_dofs</a> () const</td></tr>
<tr class="memdesc:a4e591f62b3e49663aa91143dd3fcebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dofs on the closure of each topological entity: (vertices, edges, faces, cell) in that order.  <a href="classbasix_1_1FiniteElement.html#a4e591f62b3e49663aa91143dd3fcebbe">More...</a><br /></td></tr>
<tr class="separator:a4e591f62b3e49663aa91143dd3fcebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec2f9542fb0f555e73605045130eaef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a1ec2f9542fb0f555e73605045130eaef">base_transformations</a> () const</td></tr>
<tr class="memdesc:a1ec2f9542fb0f555e73605045130eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base transformations.  <a href="classbasix_1_1FiniteElement.html#a1ec2f9542fb0f555e73605045130eaef">More...</a><br /></td></tr>
<tr class="separator:a1ec2f9542fb0f555e73605045130eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026662c5a78070ec64ff8f2f76679f3f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>, std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a026662c5a78070ec64ff8f2f76679f3f">entity_transformations</a> () const</td></tr>
<tr class="memdesc:a026662c5a78070ec64ff8f2f76679f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entity dof transformation matrices.  <a href="classbasix_1_1FiniteElement.html#a026662c5a78070ec64ff8f2f76679f3f">More...</a><br /></td></tr>
<tr class="separator:a026662c5a78070ec64ff8f2f76679f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62410337392b86f8ee1ac159177e4e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d">permute</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a62410337392b86f8ee1ac159177e4e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute indices associated with degree-of-freedoms on the reference element ordering to the globally consistent physical element degree-of-freedom ordering.  <a href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d">More...</a><br /></td></tr>
<tr class="separator:a62410337392b86f8ee1ac159177e4e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d87425d5dc80a3b9247c61c773780b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6d87425d5dc80a3b9247c61c773780b6">permute_inv</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a6d87425d5dc80a3b9247c61c773780b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a>.  <a href="classbasix_1_1FiniteElement.html#a6d87425d5dc80a3b9247c61c773780b6">More...</a><br /></td></tr>
<tr class="separator:a6d87425d5dc80a3b9247c61c773780b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76284b2b9e4e63e7425e2eb2229cec62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62">permute_subentity_closure</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t cell_info, <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> entity_type, int entity_index) const</td></tr>
<tr class="memdesc:a76284b2b9e4e63e7425e2eb2229cec62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference element.  <a href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62">More...</a><br /></td></tr>
<tr class="separator:a76284b2b9e4e63e7425e2eb2229cec62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d2108e4b9c0a52ee074d59e5ad93a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a21d2108e4b9c0a52ee074d59e5ad93a4">permute_subentity_closure_inv</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t cell_info, <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> entity_type, int entity_index) const</td></tr>
<tr class="memdesc:a21d2108e4b9c0a52ee074d59e5ad93a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62" title="Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference el...">permute_subentity_closure()</a>.  <a href="classbasix_1_1FiniteElement.html#a21d2108e4b9c0a52ee074d59e5ad93a4">More...</a><br /></td></tr>
<tr class="separator:a21d2108e4b9c0a52ee074d59e5ad93a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f813c02aabc1711f9711756c1d251f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8f813c02aabc1711f9711756c1d251f8">permute_subentity_closure</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t entity_info, <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> entity_type) const</td></tr>
<tr class="memdesc:a8f813c02aabc1711f9711756c1d251f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference element.  <a href="classbasix_1_1FiniteElement.html#a8f813c02aabc1711f9711756c1d251f8">More...</a><br /></td></tr>
<tr class="separator:a8f813c02aabc1711f9711756c1d251f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df7fe4324b56bc4e5baeb85dbe40cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a3df7fe4324b56bc4e5baeb85dbe40cb0">permute_subentity_closure_inv</a> (std::span&lt; std::int32_t &gt; d, std::uint32_t entity_info, <a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> entity_type) const</td></tr>
<tr class="memdesc:a3df7fe4324b56bc4e5baeb85dbe40cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62" title="Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference el...">permute_subentity_closure()</a>.  <a href="classbasix_1_1FiniteElement.html#a3df7fe4324b56bc4e5baeb85dbe40cb0">More...</a><br /></td></tr>
<tr class="separator:a3df7fe4324b56bc4e5baeb85dbe40cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204bc807ddcec4a21083e111890ec09a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a204bc807ddcec4a21083e111890ec09a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a">T_apply</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a204bc807ddcec4a21083e111890ec09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basis functions from the reference element ordering and orientation to the globally consistent physical element ordering and orientation.  <a href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a">More...</a><br /></td></tr>
<tr class="separator:a204bc807ddcec4a21083e111890ec09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a9eaaf3ded82f04322943597ad66ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21a9eaaf3ded82f04322943597ad66ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a21a9eaaf3ded82f04322943597ad66ba">Tt_apply</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a21a9eaaf3ded82f04322943597ad66ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a21a9eaaf3ded82f04322943597ad66ba">More...</a><br /></td></tr>
<tr class="separator:a21a9eaaf3ded82f04322943597ad66ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f40d975ac716968aaff7cd3fb59d058"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f40d975ac716968aaff7cd3fb59d058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6f40d975ac716968aaff7cd3fb59d058">Tt_inv_apply</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a6f40d975ac716968aaff7cd3fb59d058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a6f40d975ac716968aaff7cd3fb59d058">More...</a><br /></td></tr>
<tr class="separator:a6f40d975ac716968aaff7cd3fb59d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94599a3d81592d9c88c167d1a54b43fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94599a3d81592d9c88c167d1a54b43fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a94599a3d81592d9c88c167d1a54b43fe">Tinv_apply</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a94599a3d81592d9c88c167d1a54b43fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a94599a3d81592d9c88c167d1a54b43fe">More...</a><br /></td></tr>
<tr class="separator:a94599a3d81592d9c88c167d1a54b43fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5b436743ca55e7f3f65dbc7f038ca1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e5b436743ca55e7f3f65dbc7f038ca1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6e5b436743ca55e7f3f65dbc7f038ca1">Tt_apply_right</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a6e5b436743ca55e7f3f65dbc7f038ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a6e5b436743ca55e7f3f65dbc7f038ca1">More...</a><br /></td></tr>
<tr class="separator:a6e5b436743ca55e7f3f65dbc7f038ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f9b0dd8b9c5685f4d5a23f452cef75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48f9b0dd8b9c5685f4d5a23f452cef75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a48f9b0dd8b9c5685f4d5a23f452cef75">T_apply_right</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a48f9b0dd8b9c5685f4d5a23f452cef75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a48f9b0dd8b9c5685f4d5a23f452cef75">More...</a><br /></td></tr>
<tr class="separator:a48f9b0dd8b9c5685f4d5a23f452cef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5f8019e850a5404e09efd22d1ce4af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f5f8019e850a5404e09efd22d1ce4af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0f5f8019e850a5404e09efd22d1ce4af">Tinv_apply_right</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a0f5f8019e850a5404e09efd22d1ce4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a0f5f8019e850a5404e09efd22d1ce4af">More...</a><br /></td></tr>
<tr class="separator:a0f5f8019e850a5404e09efd22d1ce4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d533cdaca6a3b1c306c16889343b983"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d533cdaca6a3b1c306c16889343b983"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a7d533cdaca6a3b1c306c16889343b983">Tt_inv_apply_right</a> (std::span&lt; T &gt; u, int n, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:a7d533cdaca6a3b1c306c16889343b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the transpose inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <a href="classbasix_1_1FiniteElement.html#a7d533cdaca6a3b1c306c16889343b983">More...</a><br /></td></tr>
<tr class="separator:a7d533cdaca6a3b1c306c16889343b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9029b7b3b17618c7da8ca49c31a24dd3"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9029b7b3b17618c7da8ca49c31a24dd3">points</a> () const</td></tr>
<tr class="memdesc:a9029b7b3b17618c7da8ca49c31a24dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interpolation points.  <a href="classbasix_1_1FiniteElement.html#a9029b7b3b17618c7da8ca49c31a24dd3">More...</a><br /></td></tr>
<tr class="separator:a9029b7b3b17618c7da8ca49c31a24dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28f7a87d7c40140415f02b51241e152"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac28f7a87d7c40140415f02b51241e152">interpolation_matrix</a> () const</td></tr>
<tr class="memdesc:ac28f7a87d7c40140415f02b51241e152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix of weights interpolation.  <a href="classbasix_1_1FiniteElement.html#ac28f7a87d7c40140415f02b51241e152">More...</a><br /></td></tr>
<tr class="separator:ac28f7a87d7c40140415f02b51241e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be07c7bdcee21c8cf2804f0741ab4e4"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2be07c7bdcee21c8cf2804f0741ab4e4">dual_matrix</a> () const</td></tr>
<tr class="memdesc:a2be07c7bdcee21c8cf2804f0741ab4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dual matrix.  <a href="classbasix_1_1FiniteElement.html#a2be07c7bdcee21c8cf2804f0741ab4e4">More...</a><br /></td></tr>
<tr class="separator:a2be07c7bdcee21c8cf2804f0741ab4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09752dd03b15e15fdfb50a38ba9814"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a1d09752dd03b15e15fdfb50a38ba9814">wcoeffs</a> () const</td></tr>
<tr class="memdesc:a1d09752dd03b15e15fdfb50a38ba9814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coefficients that define the polynomial set in terms of the orthonormal polynomials.  <a href="classbasix_1_1FiniteElement.html#a1d09752dd03b15e15fdfb50a38ba9814">More...</a><br /></td></tr>
<tr class="separator:a1d09752dd03b15e15fdfb50a38ba9814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4160dd1b8ec0223b7a8d997a13775d6"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &gt;, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">x</a> () const</td></tr>
<tr class="memdesc:ad4160dd1b8ec0223b7a8d997a13775d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolation points for each subentity.  <a href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6">More...</a><br /></td></tr>
<tr class="separator:ad4160dd1b8ec0223b7a8d997a13775d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7f2fed5734ed3118a74cb836370611"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 4 &gt; &gt; &gt;, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a1e7f2fed5734ed3118a74cb836370611">M</a> () const</td></tr>
<tr class="memdesc:a1e7f2fed5734ed3118a74cb836370611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolation matrices for each subentity.  <a href="classbasix_1_1FiniteElement.html#a1e7f2fed5734ed3118a74cb836370611">More...</a><br /></td></tr>
<tr class="separator:a1e7f2fed5734ed3118a74cb836370611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f0c90d8010da4cde445b719fed0fb7"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a23f0c90d8010da4cde445b719fed0fb7">coefficient_matrix</a> () const</td></tr>
<tr class="memdesc:a23f0c90d8010da4cde445b719fed0fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrix of coefficients.  <a href="classbasix_1_1FiniteElement.html#a23f0c90d8010da4cde445b719fed0fb7">More...</a><br /></td></tr>
<tr class="separator:a23f0c90d8010da4cde445b719fed0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aabff36857476d891ffc5c80d30b147"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4aabff36857476d891ffc5c80d30b147">has_tensor_product_factorisation</a> () const</td></tr>
<tr class="memdesc:a4aabff36857476d891ffc5c80d30b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not this element can be represented as a product of elements defined on lower-dimensional reference cells.  <a href="classbasix_1_1FiniteElement.html#a4aabff36857476d891ffc5c80d30b147">More...</a><br /></td></tr>
<tr class="separator:a4aabff36857476d891ffc5c80d30b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147a6c863dc4b0af508be9f4d0ff9927"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a>&lt; F &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a147a6c863dc4b0af508be9f4d0ff9927">get_tensor_product_representation</a> () const</td></tr>
<tr class="memdesc:a147a6c863dc4b0af508be9f4d0ff9927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tensor product representation of this element.  <a href="classbasix_1_1FiniteElement.html#a147a6c863dc4b0af508be9f4d0ff9927">More...</a><br /></td></tr>
<tr class="separator:a147a6c863dc4b0af508be9f4d0ff9927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d4c2f24fd524b00a6bf0ab283f87fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad3d4c2f24fd524b00a6bf0ab283f87fe">interpolation_is_identity</a> () const</td></tr>
<tr class="memdesc:ad3d4c2f24fd524b00a6bf0ab283f87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the interpolation matrix for this element is an identity matrix.  <a href="classbasix_1_1FiniteElement.html#ad3d4c2f24fd524b00a6bf0ab283f87fe">More...</a><br /></td></tr>
<tr class="separator:ad3d4c2f24fd524b00a6bf0ab283f87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b364ec6c8681526d3f6a15802e21c1"><td class="memItemLeft" align="right" valign="top"><a id="a51b364ec6c8681526d3f6a15802e21c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a51b364ec6c8681526d3f6a15802e21c1">interpolation_nderivs</a> () const</td></tr>
<tr class="memdesc:a51b364ec6c8681526d3f6a15802e21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of derivatives needed when interpolating. <br /></td></tr>
<tr class="separator:a51b364ec6c8681526d3f6a15802e21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12145f082817587bd17ede85cb251706"><td class="memItemLeft" align="right" valign="top"><a id="a12145f082817587bd17ede85cb251706"></a>
const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a12145f082817587bd17ede85cb251706">dof_ordering</a> () const</td></tr>
<tr class="memdesc:a12145f082817587bd17ede85cb251706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dof layout. <br /></td></tr>
<tr class="separator:a12145f082817587bd17ede85cb251706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::floating_point F&gt;<br />
class basix::FiniteElement&lt; F &gt;</h3>

<p>A finite element. </p>
<p>The basis of a finite element is stored as a set of coefficients, which are applied to the underlying expansion set for that cell type, when tabulating. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f8794de82cfc63ce8e40fad99802dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8794de82cfc63ce8e40fad99802dfe">&#9670;&nbsp;</a></span>FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1polyset.html#a04ec1a9561f875220b50ad2076cd35c2">polyset::type</a>&#160;</td>
          <td class="paramname"><em>poly_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mdspan_t&lt; const F, 2 &gt;&#160;</td>
          <td class="paramname"><em>wcoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; mdspan_t&lt; const F, 2 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; mdspan_t&lt; const F, 4 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation_nderivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td>
          <td class="paramname"><em>map_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a>&#160;</td>
          <td class="paramname"><em>sobolev_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discontinuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>embedded_subdegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>embedded_superdegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a>&#160;</td>
          <td class="paramname"><em>lvariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a>&#160;</td>
          <td class="paramname"><em>dvariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dof_ordering</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a finite element. </p>
<p>Initialising a finite element calculates the basis functions of the finite element, in terms of the polynomial basis.</p>
<p>The below explanation uses Einstein notation.</p>
<p>The basis functions \({\phi_i}\) of a finite element are represented as a linear combination of polynomials \(\{p_j\}\) in an underlying polynomial basis that span the space of all d-dimensional polynomials up to order \(k \ (P_k^d)\): </p><p class="formulaDsp">
\[ \phi_i = c_{ij} p_j \]
</p>
<p>In some cases, the basis functions \(\{\phi_i\}\) do not span the full space \(P_k\), in which case we denote space spanned by the basis functions by \(\{q_k\}\), which can be represented by: </p><p class="formulaDsp">
\[ q_i = b_{ij} p_j. \]
</p>
<p> This leads to </p><p class="formulaDsp">
\[ \phi_i = c^{\prime}_{ij} q_j = c^{\prime}_{ij} b_{jk} p_k, \]
</p>
<p> and in matrix form: </p><p class="formulaDsp">
\[ \phi = C^{\prime} B p \]
</p>
<p>If the basis functions span the full space, then \( B \) is simply the identity.</p>
<p>The basis functions \(\phi_i\) are defined by a dual set of functionals \(\{f_i\}\). The basis functions are the functions in span{ \(q_k\)} such that </p><p class="formulaDsp">
\[ f_i(\phi_j) = \delta_{ij} \]
</p>
<p> and inserting the expression for \(\phi_{j}\): </p><p class="formulaDsp">
\[ f_i(c^{\prime}_{jk}b_{kl}p_{l}) = c^{\prime}_{jk} b_{kl} f_i \left( p_{l} \right) \]
</p>
<p>Defining a matrix D given by applying the functionals to each polynomial \(p_j\): </p><p class="formulaDsp">
\[ [D] = d_{ij},\mbox{ where } d_{ij} = f_i(p_j), \]
</p>
<p> we have: </p><p class="formulaDsp">
\[ C^{\prime} B D^{T} = I \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ C^{\prime} = (B D^{T})^{-1}. \]
</p>
<p>Recalling that \(C = C^{\prime} B\), where \(C\) is the matrix form of \(c_{ij}\),</p>
<p class="formulaDsp">
\[ C = (B D^{T})^{-1} B \]
</p>
<p>This function takes the matrices \(B\) (<code>wcoeffs</code>) and \(D\) (<code>M</code>) as inputs and will internally compute \(C\).</p>
<p>The matrix \(BD^{T}\) can be obtained from an element by using <a class="el" href="classbasix_1_1FiniteElement.html#a2be07c7bdcee21c8cf2804f0741ab4e4" title="Get the dual matrix.">dual_matrix()</a>. The matrix \(C\) can be obtained from an element by using <a class="el" href="classbasix_1_1FiniteElement.html#a23f0c90d8010da4cde445b719fed0fb7" title="Get the matrix of coefficients.">coefficient_matrix()</a>.</p>
<h2>Example: Order 1 Lagrange elements on a triangle </h2>
<p>On a triangle, the scalar expansion basis is: </p><p class="formulaDsp">
\[ p_0 = \sqrt{2}/2 \qquad p_1 = \sqrt{3}(2x + y - 1) \qquad p_2 = 3y - 1 \]
</p>
<p> These span the space \(P_1\).</p>
<p>Lagrange order 1 elements span the space P_1, so in this example, B (span_coeffs) is the identity matrix: </p><p class="formulaDsp">
\[ B = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>The functionals defining the Lagrange order 1 space are point evaluations at the three vertices of the triangle. The matrix D (dual) given by applying these to p_0 to p_2 is: </p><p class="formulaDsp">
\[ \mbox{dual} = \begin{bmatrix} \sqrt{2}/2 &amp; -\sqrt{3} &amp; -1 \\ \sqrt{2}/2 &amp; \sqrt{3} &amp; -1 \\ \sqrt{2}/2 &amp; 0 &amp; 2 \end{bmatrix} \]
</p>
<p>For this example, this function outputs the matrix: </p><p class="formulaDsp">
\[ C = \begin{bmatrix} \sqrt{2}/3 &amp; -\sqrt{3}/6 &amp; -1/6 \\ \sqrt{2}/3 &amp; \sqrt{3}/6 &amp; -1/6 \\ \sqrt{2}/3 &amp; 0 &amp; 1/3 \end{bmatrix} \]
</p>
<p> The basis functions of the finite element can be obtained by applying the matrix C to the vector \([p_0, p_1, p_2]\), giving: </p><p class="formulaDsp">
\[ \begin{bmatrix} 1 - x - y \\ x \\ y \end{bmatrix} \]
</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>On a triangle, the 2D vector expansion basis is: </p><p class="formulaDsp">
\[ \begin{matrix} p_0 &amp; = &amp; (\sqrt{2}/2, 0) \\ p_1 &amp; = &amp; (\sqrt{3}(2x + y - 1), 0) \\ p_2 &amp; = &amp; (3y - 1, 0) \\ p_3 &amp; = &amp; (0, \sqrt{2}/2) \\ p_4 &amp; = &amp; (0, \sqrt{3}(2x + y - 1)) \\ p_5 &amp; = &amp; (0, 3y - 1) \end{matrix} \]
</p>
<p> These span the space \( P_1^2 \).</p>
<p>Raviart-Thomas order 1 elements span a space smaller than \( P_1^2 \), so B (span_coeffs) is not the identity. It is given by: </p><p class="formulaDsp">
\[ B = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 1/12 &amp; \sqrt{6}/48 &amp; -\sqrt{2}/48 &amp; 1/12 &amp; 0 &amp; \sqrt{2}/24 \end{bmatrix} \]
</p>
<p> Applying the matrix B to the vector \([p_0, p_1, ..., p_5]\) gives the basis of the polynomial space for Raviart-Thomas: </p><p class="formulaDsp">
\[ \begin{bmatrix} \sqrt{2}/2 &amp; 0 \\ 0 &amp; \sqrt{2}/2 \\ \sqrt{2}x/8 &amp; \sqrt{2}y/8 \end{bmatrix} \]
</p>
<p>The functionals defining the Raviart-Thomas order 1 space are integral of the normal components along each edge. The matrix D (dual) given by applying these to \(p_0\) to \(p_5\) is: </p><p class="formulaDsp">
\[ D = \begin{bmatrix} -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 &amp; -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 \\ -\sqrt{2}/2 &amp; \sqrt{3}/2 &amp; -1/2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \sqrt{2}/2 &amp; 0 &amp; -1 \end{bmatrix} \]
</p>
<p>In this example, this function outputs the matrix: </p><p class="formulaDsp">
\[ C = \begin{bmatrix} -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 &amp; -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 \\ -\sqrt{2}/2 &amp; \sqrt{3}/2 &amp; -1/2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \sqrt{2}/2 &amp; 0 &amp; -1 \end{bmatrix} \]
</p>
<p> The basis functions of the finite element can be obtained by applying the matrix C to the vector \([p_0, p_1, ..., p_5]\), giving: </p><p class="formulaDsp">
\[ \begin{bmatrix} -x &amp; -y \\ x - 1 &amp; y \\ -x &amp; 1 - y \end{bmatrix} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>The element family </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_type</td><td>The polyset type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>The degree of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolation_nderivs</td><td>The number of derivatives that need to be used during interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td>The value shape of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcoeffs</td><td>Matrices for the kth value index containing the expansion coefficients defining a polynomial basis spanning the polynomial space for this element. Shape is (dim(finite element polyset), dim(Legendre polynomials)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation points. Indices are (tdim, entity index, point index, dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The interpolation matrices. Indices are (tdim, entity index, dof, vs, point_index, derivative) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_type</td><td>The type of map to be used to map values from the reference to a cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sobolev_space</td><td>The underlying Sobolev space for the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discontinuous</td><td>Indicates whether or not this is the discontinuous version of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">embedded_subdegree</td><td>The highest degree n such that a Lagrange (or vector Lagrange) element of degree n is a subspace of this element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">embedded_superdegree</td><td>The highest degree n such that at least one polynomial of degree n is included in this element's polymonial set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lvariant</td><td>The Lagrange variant of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dvariant</td><td>The DPC variant of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_ordering</td><td>DOF reordering: a mapping from the reference order to a new permuted order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a369c8049d19ca40e09189498feeee720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c8049d19ca40e09189498feeee720">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a>&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two elements are the same. </p>
<dl class="section note"><dt>Note</dt><dd>This operator compares the element properties, e.g. family, degree, etc, and not computed numerical data </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if elements are the same </dd></dl>

</div>
</div>
<a id="a97bfad3598917d05db627e06c8fe4399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bfad3598917d05db627e06c8fe4399">&#9670;&nbsp;</a></span>tabulate_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::size_t, 4&gt; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::tabulate_shape </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array shape for tabulate basis values and derivatives at set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_points</td><td>Number of points that basis will be computed at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the array to will filled when passed to <a class="el" href="classbasix_1_1FiniteElement.html#a53b81aa1517fa85f40ab8d7e763627d4" title="Compute basis values and derivatives at set of points.">tabulate()</a>. </dd></dl>

</div>
</div>
<a id="a53b81aa1517fa85f40ab8d7e763627d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b81aa1517fa85f40ab8d7e763627d4">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 4 &gt; &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis values and derivatives at set of points. </p>
<dl class="section note"><dt>Note</dt><dd>The version of <a class="el" href="classbasix_1_1FiniteElement.html#a53b81aa1517fa85f40ab8d7e763627d4" title="Compute basis values and derivatives at set of points.">tabulate()</a> with the basis data as an out argument should be preferred for repeated call where performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46" title="Compute trivial indexing in a 1D array (for completeness).">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27bbbe513ce61cfe4df1e630f2534832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bbbe513ce61cfe4df1e630f2534832">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 4 &gt; &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const F &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis values and derivatives at set of points. </p>
<dl class="section note"><dt>Note</dt><dd>The version of <a class="el" href="classbasix_1_1FiniteElement.html#a53b81aa1517fa85f40ab8d7e763627d4" title="Compute basis values and derivatives at set of points.">tabulate()</a> with the basis data as an out argument should be preferred for repeated call where performance is critical</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions (row-major storage). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape <code>(number of points, geometric dimension)</code> of the <code>x</code> array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46" title="Compute trivial indexing in a 1D array (for completeness).">indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a318c8c78c3bd964c05b3dd593bf0e122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c8c78c3bd964c05b3dd593bf0e122">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mdspan_t&lt; F, 4 &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis values and derivatives at set of points. </p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basis</td><td>Memory location to fill. It must be allocated with shape <code>(num_derivatives, num_points, num basis functions, value_size)</code>. The function <a class="el" href="classbasix_1_1FiniteElement.html#a97bfad3598917d05db627e06c8fe4399" title="Array shape for tabulate basis values and derivatives at set of points.">tabulate_shape()</a> can be used to get the required shape.<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46" title="Compute trivial indexing in a 1D array (for completeness).">indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Remove all internal dynamic memory allocation, pass scratch space as required </dd></dl>

</div>
</div>
<a id="a39071d50e9e7777a642f515c545cc9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39071d50e9e7777a642f515c545cc9ef">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const F &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>xshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; F &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis values and derivatives at set of points. </p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions (row-major storage). The shape of <code>x</code> is <code>(number of points, geometric dimension)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>The shape <code>(number of points, geometric dimension)</code> of <code>x</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basis</td><td>Memory location to fill. It must be allocated with shape <code>(num_derivatives, num_points, num basis functions, value_size)</code>. The function <a class="el" href="classbasix_1_1FiniteElement.html#a97bfad3598917d05db627e06c8fe4399" title="Array shape for tabulate basis values and derivatives at set of points.">tabulate_shape()</a> can be used to get the required shape.<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46" title="Compute trivial indexing in a 1D array (for completeness).">indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2854ed6e5dc06d0ed73420909ac407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2854ed6e5dc06d0ed73420909ac407e">&#9670;&nbsp;</a></span>cell_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the element cell type. </p>
<dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
<a id="ab8cbe1b35a2ab85fc8a85730fb76f0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cbe1b35a2ab85fc8a85730fb76f0a4">&#9670;&nbsp;</a></span>polyset_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1polyset.html#a04ec1a9561f875220b50ad2076cd35c2">polyset::type</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::polyset_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the element polyset type. </p>
<dl class="section return"><dt>Returns</dt><dd>The polyset </dd></dl>

</div>
</div>
<a id="a8be3154c07a9cc7aa2bb2233ae191590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be3154c07a9cc7aa2bb2233ae191590">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the element polynomial degree. </p>
<dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a555d2234569e64d1983d8cf9a1fcf48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555d2234569e64d1983d8cf9a1fcf48c">&#9670;&nbsp;</a></span>embedded_superdegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::embedded_superdegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lowest degree <code>n</code> such that the highest degree polynomial in this element is contained in a Lagrange (or vector Lagrange) element of degree <code>n</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a41f96560b78b0cc38a3ae7d5eb45eec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f96560b78b0cc38a3ae7d5eb45eec3">&#9670;&nbsp;</a></span>embedded_subdegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::embedded_subdegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Highest degree <code>n</code> such that a Lagrange (or vector Lagrange) element of degree n is a subspace of this element. </p>
<dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a8b157bb6a943f276989823dac4dd9884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b157bb6a943f276989823dac4dd9884">&#9670;&nbsp;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::size_t&gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::value_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element value tensor shape. </p>
<p>For example, returns <code>{}</code> for scalars, <code>{3}</code> for vectors in 3D, <code>{2, 2}</code> for a rank-2 tensor in 2D. </p><dl class="section return"><dt>Returns</dt><dd>Value shape </dd></dl>

</div>
</div>
<a id="a5b59d24da952b7c590d97d929e7eb5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b59d24da952b7c590d97d929e7eb5eb">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of the finite element space. </p>
<p>The dimension is the number of degrees-of-freedom for the element. </p><dl class="section return"><dt>Returns</dt><dd>Number of degrees of freedom </dd></dl>

</div>
</div>
<a id="af632d219b4c4b9f6a23ea124208c678e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af632d219b4c4b9f6a23ea124208c678e">&#9670;&nbsp;</a></span>family()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The finite element family. </p>
<dl class="section return"><dt>Returns</dt><dd>The family </dd></dl>

</div>
</div>
<a id="a7cc685192a3bcd2ae6e6dca2fbc92901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc685192a3bcd2ae6e6dca2fbc92901">&#9670;&nbsp;</a></span>lagrange_variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::lagrange_variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lagrange variant of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>The Lagrange variant. </dd></dl>

</div>
</div>
<a id="aeae98c4a939f1d98d11943c67496b236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae98c4a939f1d98d11943c67496b236">&#9670;&nbsp;</a></span>dpc_variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::dpc_variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DPC variant of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>The DPC variant. </dd></dl>

</div>
</div>
<a id="ade11e85f802d692a00c0368490fbf25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade11e85f802d692a00c0368490fbf25d">&#9670;&nbsp;</a></span>map_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::map_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map type for the element. </p>
<dl class="section return"><dt>Returns</dt><dd>The map type. </dd></dl>

</div>
</div>
<a id="a9b69240399a8db8705ba4305e88e34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b69240399a8db8705ba4305e88e34d1">&#9670;&nbsp;</a></span>sobolev_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a> <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::sobolev_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Underlying Sobolev space for this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The Sobolev space. </dd></dl>

</div>
</div>
<a id="ad8f6272cb60e88215d3a85d058d87b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f6272cb60e88215d3a85d058d87b9a">&#9670;&nbsp;</a></span>discontinuous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::discontinuous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this element is the discontinuous variant. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this element is a discontinuous version of the element. </dd></dl>

</div>
</div>
<a id="ad09c511d565978e3a5a50b7481561224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09c511d565978e3a5a50b7481561224">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::push_forward </td>
          <td>(</td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const F &gt;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map function values from the reference to a physical cell. </p>
<p>This function can perform the mapping for multiple points, grouped by points that share a common Jacobian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>The function values on the reference. The indices are <code>[Jacobian index, point index, components]</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping. The indices are <code>[Jacobian index, J_i, J_j]</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping. It has length <code>J.shape(0)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping. The indices are <code>[Jacobian index, K_i, K_j]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the cell. The indices are [Jacobian index, point index, components]. </dd></dl>

</div>
</div>
<a id="ac95e334dfd3afaccb83d898d27f3efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95e334dfd3afaccb83d898d27f3efcc">&#9670;&nbsp;</a></span>pull_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::pull_back </td>
          <td>(</td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const F &gt;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan_t&lt; const F, 3 &gt;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map function values from a physical cell to the reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The function values on the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the reference. The indices are [Jacobian index, point index, components]. </dd></dl>

</div>
</div>
<a id="a582a08343f222f1571b7f700767fc705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582a08343f222f1571b7f700767fc705">&#9670;&nbsp;</a></span>map_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename O , typename P , typename Q , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(O&amp;, const P&amp;, const Q&amp;, F, const R&amp;)&gt; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::map_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a function that performs the appropriate push-forward/pull-back for the element type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>The type that hold the (computed) mapped data (ndim==2) </td></tr>
    <tr><td class="paramname">P</td><td>The type that hold the data to be mapped (ndim==2) </td></tr>
    <tr><td class="paramname">Q</td><td>The type that holds the Jacobian (or inverse) matrix (ndim==2) </td></tr>
    <tr><td class="paramname">R</td><td>The type that holds the inverse of the <code>Q</code> data (ndim==2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that for a push-forward takes arguments<ul>
<li><code>u</code> [out] The data on the physical cell after the push-forward flattened with row-major layout, shape=(num_points, value_size)</li>
<li><code>U</code> [in] The data on the reference cell physical field to push forward, flattened with row-major layout, shape=(num_points, ref_value_size)</li>
<li><code>J</code> [in] The Jacobian matrix of the map ,shape=(gdim, tdim)</li>
<li><code>detJ</code> [in] det(J)</li>
<li><code>K</code> [in] The inverse of the Jacobian matrix, shape=(tdim, gdim)</li>
</ul>
</dd></dl>
<p>For a pull-back the arguments should be:</p><ul>
<li><code>U</code> [out] The data on the reference cell after the pull-back, flattened with row-major layout, shape=(num_points, ref value_size)</li>
<li><code>u</code> [in] The data on the physical cell that should be pulled back , flattened with row-major layout, shape=(num_points, value_size)</li>
<li><code>K</code> [in] The inverse of the Jacobian matrix of the map ,shape=(tdim, gdim)</li>
<li><code>detJ_inv</code> [in] 1/det(J)</li>
<li><code>J</code> [in] The Jacobian matrix, shape=(gdim, tdim) </li>
</ul>

</div>
</div>
<a id="ad100cdb78027a12ffd295c43e6b7b117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad100cdb78027a12ffd295c43e6b7b117">&#9670;&nbsp;</a></span>entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dofs on each topological entity: (vertices, edges, faces, cell) in that order. </p>
<p>For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[3], [4], [5]], cell: [[]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with an entity of a given topological dimension. The shape is (tdim + 1, num_entities, num_dofs). </dd></dl>

</div>
</div>
<a id="a4e591f62b3e49663aa91143dd3fcebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e591f62b3e49663aa91143dd3fcebbe">&#9670;&nbsp;</a></span>entity_closure_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::entity_closure_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dofs on the closure of each topological entity: (vertices, edges, faces, cell) in that order. </p>
<p>For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[1, 2, 3], [0, 2, 4], [0, 1, 5]], cell: [[0, 1, 2, 3, 4, 5]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with the closure of an entity of a given topological dimension. The shape is <code>(tdim + 1, num_entities, num_dofs)</code>. </dd></dl>

</div>
</div>
<a id="a1ec2f9542fb0f555e73605045130eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec2f9542fb0f555e73605045130eaef">&#9670;&nbsp;</a></span>base_transformations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; F &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::base_transformations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the base transformations. </p>
<p>The base transformations represent the effect of rotating or reflecting a subentity of the cell on the numbering and orientation of the DOFs. This returns a list of matrices with one matrix for each subentity permutation in the following order: Reversing edge 0, reversing edge 1, ... Rotate face 0, reflect face 0, rotate face 1, reflect face 1, ...</p>
<h2>Example: Order 3 Lagrange on a triangle </h2>
<p>This space has 10 dofs arranged like: </p><div class="fragment"><div class="line">2</div>
<div class="line">|\</div>
<div class="line">6 4</div>
<div class="line">|  \</div>
<div class="line">5 9 3</div>
<div class="line">|    \</div>
<div class="line">0-7-8-1</div>
</div><!-- fragment --><p> For this element, the base transformations are: [Matrix swapping 3 and 4, Matrix swapping 5 and 6, Matrix swapping 7 and 8] The first row shows the effect of reversing the diagonal edge. The second row shows the effect of reversing the vertical edge. The third row shows the effect of reversing the horizontal edge.</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>This space has 3 dofs arranged like: </p><div class="fragment"><div class="line">  |\</div>
<div class="line">  | \</div>
<div class="line">  |  \</div>
<div class="line">&lt;-1   0</div>
<div class="line">  |  / \</div>
<div class="line">  | L ^ \</div>
<div class="line">  |   |  \</div>
<div class="line">   ---2---</div>
</div><!-- fragment --><p> These DOFs are integrals of normal components over the edges: DOFs 0 and 2 are oriented inward, DOF 1 is oriented outwards. For this element, the base transformation matrices are: </p><div class="fragment"><div class="line">0: [[-1, 0, 0],</div>
<div class="line">    [ 0, 1, 0],</div>
<div class="line">    [ 0, 0, 1]]</div>
<div class="line">1: [[1,  0, 0],</div>
<div class="line">    [0, -1, 0],</div>
<div class="line">    [0,  0, 1]]</div>
<div class="line">2: [[1, 0,  0],</div>
<div class="line">    [0, 1,  0],</div>
<div class="line">    [0, 0, -1]]</div>
</div><!-- fragment --><p> The first matrix reverses DOF 0 (as this is on the first edge). The second matrix reverses DOF 1 (as this is on the second edge). The third matrix reverses DOF 2 (as this is on the third edge).</p>
<h2>Example: DOFs on the face of Order 2 Nedelec first kind on a tetrahedron </h2>
<p>On a face of this tetrahedron, this space has two face tangent DOFs: </p><div class="fragment"><div class="line">|\        |\</div>
<div class="line">| \       | \</div>
<div class="line">|  \      | ^\</div>
<div class="line">|   \     | | \</div>
<div class="line">| 0-&gt;\    | 1  \</div>
<div class="line">|     \   |     \</div>
<div class="line"> ------    ------</div>
</div><!-- fragment --><p> For these DOFs, the subblocks of the base transformation matrices are: </p><div class="fragment"><div class="line">rotation:   [[-1, 1],</div>
<div class="line">             [ 1, 0]]</div>
<div class="line">reflection: [[0, 1],</div>
<div class="line">             [1, 0]]</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>The base transformations for this element. The shape is (ntranformations, ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="a026662c5a78070ec64ff8f2f76679f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026662c5a78070ec64ff8f2f76679f3f">&#9670;&nbsp;</a></span>entity_transformations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>, std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 3&gt; &gt; &gt; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::entity_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entity dof transformation matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>The entity transformations for the sub-entities of this element. The shape for each cell is (ntransformations, ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="a62410337392b86f8ee1ac159177e4e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62410337392b86f8ee1ac159177e4e7d">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute indices associated with degree-of-freedoms on the reference element ordering to the globally consistent physical element degree-of-freedom ordering. </p>
<p>Given an array \(\tilde{d}\) that holds an integer associated with each degree-of-freedom and following the reference element degree-of-freedom ordering, this function computes </p><p class="formulaDsp">
\[ d = P \tilde{d}, \]
</p>
<p> where \(P\) is a permutation matrix and \(d\) holds the integers in \(\tilde{d}\) but permuted to follow the globally consistent physical element degree-of-freedom ordering. The permutation is computed in-place.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each reference element degree-of-freedom (in). Indices associated with each physical element degree-of-freedom (out). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d87425d5dc80a3b9247c61c773780b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d87425d5dc80a3b9247c61c773780b6">&#9670;&nbsp;</a></span>permute_inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute_inv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a>. </p>
<p>Given an array \(d\) that holds an integer associated with each degree-of-freedom and following the globally consistent physical element degree-of-freedom ordering, this function computes </p><p class="formulaDsp">
\[ \tilde{d} = P^{T} d, \]
</p>
<p> where \(P^{T}\) is a permutation matrix and \(\tilde{d}\) holds the integers in \(d\) but permuted to follow the reference element degree-of-freedom ordering. The permutation is computed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each physical element degree-of-freedom [in]. Indices associated with each reference element degree-of-freedom [out]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76284b2b9e4e63e7425e2eb2229cec62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76284b2b9e4e63e7425e2eb2229cec62">&#9670;&nbsp;</a></span>permute_subentity_closure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute_subentity_closure </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entity_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference element. </p>
<p>This function performs a similar permutation to <a class="el" href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a> but additionally permutes the positions of vertices and edges</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each reference element degree-of-freedom (in). Indices associated with each physical element degree-of-freedom (out). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_type</td><td>The cell type of the sub-entity </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_index</td><td>The index of the entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21d2108e4b9c0a52ee074d59e5ad93a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d2108e4b9c0a52ee074d59e5ad93a4">&#9670;&nbsp;</a></span>permute_subentity_closure_inv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute_subentity_closure_inv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td>
          <td class="paramname"><em>entity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entity_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62" title="Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference el...">permute_subentity_closure()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each reference element degree-of-freedom (in). Indices associated with each physical element degree-of-freedom (out). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_type</td><td>The cell type of the sub-entity </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_index</td><td>The index of the entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f813c02aabc1711f9711756c1d251f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f813c02aabc1711f9711756c1d251f8">&#9670;&nbsp;</a></span>permute_subentity_closure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute_subentity_closure </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>entity_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td>
          <td class="paramname"><em>entity_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference element. </p>
<p>This function performs a similar permutation to <a class="el" href="classbasix_1_1FiniteElement.html#a62410337392b86f8ee1ac159177e4e7d" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a> but additionally permutes the positions of vertices and edges</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each reference element degree-of-freedom (in). Indices associated with each physical element degree-of-freedom (out). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_info</td><td>Permutation info for the entity </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_type</td><td>The cell type of the sub-entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3df7fe4324b56bc4e5baeb85dbe40cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df7fe4324b56bc4e5baeb85dbe40cb0">&#9670;&nbsp;</a></span>permute_subentity_closure_inv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::permute_subentity_closure_inv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>entity_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a30ecf43ef8a377355caf943f9d8204b4">cell::type</a>&#160;</td>
          <td class="paramname"><em>entity_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the inverse of the operation applied by <a class="el" href="classbasix_1_1FiniteElement.html#a76284b2b9e4e63e7425e2eb2229cec62" title="Permute indices associated with degree-of-freedoms on the closure of a sub-entity of the reference el...">permute_subentity_closure()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>Indices associated with each reference element degree-of-freedom (in). Indices associated with each physical element degree-of-freedom (out). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_info</td><td>Permutation info for the entity </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entity_type</td><td>The cell type of the sub-entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a204bc807ddcec4a21083e111890ec09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204bc807ddcec4a21083e111890ec09a">&#9670;&nbsp;</a></span>T_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::T_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform basis functions from the reference element ordering and orientation to the globally consistent physical element ordering and orientation. </p>
<p>Consider that the value of a finite element function \(f_{h}\) at a point is given by </p><p class="formulaDsp">
\[ f_{h} = \phi^{T} c, \]
</p>
<p> where \(f_{h}\) has shape \(r \times 1\), \(\phi\) has shape \(d \times r\) and holds the finite element basis functions, and \(c\) has shape \(d \times 1\) and holds the degrees-of-freedom. The basis functions and degree-of-freedom are with respect to the physical element orientation. If the degrees-of-freedom on the physical element orientation are given by </p><p class="formulaDsp">
\[ \phi = T \tilde{\phi}, \]
</p>
<p> where \(T\) is a \(d \times d\) matrix, it follows from \(f_{h} = \phi^{T} c = \tilde{\phi}^{T} T^{T} c\) that </p><p class="formulaDsp">
\[ \tilde{c} = T^{T} c. \]
</p>
<p>This function applies \(T\) to data. The transformation is performed in-place. The operator \(T\) is orthogonal for many elements, but not all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a9eaaf3ded82f04322943597ad66ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a9eaaf3ded82f04322943597ad66ba">&#9670;&nbsp;</a></span>Tt_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tt_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ u \leftarrow T^{T} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom an d the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_info</td><td>Permutation info for the cell, </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f40d975ac716968aaff7cd3fb59d058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f40d975ac716968aaff7cd3fb59d058">&#9670;&nbsp;</a></span>Tt_inv_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tt_inv_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the inverse transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ u \leftarrow T^{-T} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94599a3d81592d9c88c167d1a54b43fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94599a3d81592d9c88c167d1a54b43fe">&#9670;&nbsp;</a></span>Tinv_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tinv_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ u \leftarrow T^{-1} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e5b436743ca55e7f3f65dbc7f038ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5b436743ca55e7f3f65dbc7f038ca1">&#9670;&nbsp;</a></span>Tt_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tt_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right(post)-apply the transpose of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ u^{T} \leftarrow u^{T} T^{T} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48f9b0dd8b9c5685f4d5a23f452cef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f9b0dd8b9c5685f4d5a23f452cef75">&#9670;&nbsp;</a></span>T_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::T_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right(post)-apply the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ u^{T} \leftarrow u^{T} T \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f5f8019e850a5404e09efd22d1ce4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5f8019e850a5404e09efd22d1ce4af">&#9670;&nbsp;</a></span>Tinv_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tinv_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right(post)-apply the inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ u^{T} \leftarrow u^{T} T^{-1} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d533cdaca6a3b1c306c16889343b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d533cdaca6a3b1c306c16889343b983">&#9670;&nbsp;</a></span>Tt_inv_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::Tt_inv_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right(post)-apply the transpose inverse of the operator applied by <a class="el" href="classbasix_1_1FiniteElement.html#a204bc807ddcec4a21083e111890ec09a" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ u^{T} \leftarrow u^{T} T^{-T} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Data to transform. The shape is <code>(m, n)</code>, where <code>m</code> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <code>data</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>Permutation info for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9029b7b3b17618c7da8ca49c31a24dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9029b7b3b17618c7da8ca49c31a24dd3">&#9670;&nbsp;</a></span>points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the interpolation points. </p>
<p>The interpolation points are the coordinates on the reference element where a function need to be evaluated in order to interpolate it in the finite element space. </p><dl class="section return"><dt>Returns</dt><dd>Array of coordinate with shape <code>(num_points, tdim)</code> </dd></dl>

</div>
</div>
<a id="ac28f7a87d7c40140415f02b51241e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28f7a87d7c40140415f02b51241e152">&#9670;&nbsp;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::interpolation_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a matrix of weights interpolation. </p>
<p>To interpolate a function in this finite element, the functions should be evaluated at each point given by <a class="el" href="classbasix_1_1FiniteElement.html#a9029b7b3b17618c7da8ca49c31a24dd3" title="Return the interpolation points.">points()</a>. These function values should then be multiplied by the weight matrix to give the coefficients of the interpolated function.</p>
<p>The shape of the returned matrix will be <code>(dim, num_points * value_size)</code>, where <code>dim</code> is the number of DOFs in the finite element, <code>num_points</code> is the number of points returned by <a class="el" href="classbasix_1_1FiniteElement.html#a9029b7b3b17618c7da8ca49c31a24dd3" title="Return the interpolation points.">points()</a>, and <code>value_size</code> is the value size of the finite element.</p>
<p>For example, to interpolate into a Lagrange space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">values = vector(pts.shape(0))</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Raviart-Thomas space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">vs = prod(element.value_shape())</div>
<div class="line">values = VECTOR(pts.shape(0) * vs)</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i::pts.shape(0)] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Lagrange space with a block size, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">coefficients = VECTOR(element.dim() * block_size)</div>
<div class="line">FOR b IN RANGE(block_size):</div>
<div class="line">    values = vector(pts.shape(0))</div>
<div class="line">    FOR i, p IN ENUMERATE(pts):</div>
<div class="line">        values[i] = f.evaluate_at(p)[b]</div>
<div class="line">    coefficients[::block_size] = i_m * values</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The interpolation matrix. Shape is <code>(ndofs, number of interpolation points)</code>. </dd></dl>

</div>
</div>
<a id="a2be07c7bdcee21c8cf2804f0741ab4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be07c7bdcee21c8cf2804f0741ab4e4">&#9670;&nbsp;</a></span>dual_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::dual_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dual matrix. </p>
<p>This is the matrix \(BD^{T}\), as described in the documentation of the <a class="el" href="classbasix_1_1FiniteElement.html#a5f8794de82cfc63ce8e40fad99802dfe" title="Construct a finite element.">FiniteElement()</a> constructor. </p><dl class="section return"><dt>Returns</dt><dd>The dual matrix. Shape is <code>(ndofs, ndofs)</code> = <code>(<a class="el" href="classbasix_1_1FiniteElement.html#a5b59d24da952b7c590d97d929e7eb5eb" title="Dimension of the finite element space.">dim()</a>, <a class="el" href="classbasix_1_1FiniteElement.html#a5b59d24da952b7c590d97d929e7eb5eb" title="Dimension of the finite element space.">dim()</a>)</code>. </dd></dl>

</div>
</div>
<a id="a1d09752dd03b15e15fdfb50a38ba9814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09752dd03b15e15fdfb50a38ba9814">&#9670;&nbsp;</a></span>wcoeffs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::wcoeffs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the coefficients that define the polynomial set in terms of the orthonormal polynomials. </p>
<p>The polynomials spanned by each finite element in Basix are represented as a linear combination of the orthonormal polynomials of a given degree on the cell. Each row of this matrix defines a polynomial in the set spanned by the finite element.</p>
<p>For example, the orthonormal polynomials of degree &lt;= 1 on a triangle are (where a, b, c, d are some constants):</p>
<ul>
<li>(sqrt(2), 0)</li>
<li>(a*x - b, 0)</li>
<li>(c*y - d, 0)</li>
<li>(0, sqrt(2))</li>
<li>(0, a*x - b)</li>
<li>(0, c*y - d)</li>
</ul>
<p>For a degree 1 Raviart-Thomas element, the first two rows of wcoeffs would be the following, as (1, 0) and (0, 1) are spanned by the element</p>
<ul>
<li>[1, 0, 0, 0, 0, 0]</li>
<li>[0, 0, 0, 1, 0, 0]</li>
</ul>
<p>The third row of wcoeffs in this example would give coefficients that represent (x, y) in terms of the orthonormal polynomials:</p>
<ul>
<li>[-b/(a*sqrt(2)), 1/a, 0, -d/(c*sqrt(2)), 0, 1/c]</li>
</ul>
<p>These coefficients are only stored for custom elements. This function will throw an exception if called on a non-custom element.</p>
<dl class="section return"><dt>Returns</dt><dd>Coefficient matrix. Shape is <code>(dim(finite element polyset), dim(Lagrange polynomials))</code>. </dd></dl>

</div>
</div>
<a id="ad4160dd1b8ec0223b7a8d997a13775d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4160dd1b8ec0223b7a8d997a13775d6">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::vector&lt;std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt; &gt;, 4&gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interpolation points for each subentity. </p>
<p>The indices of this data are <code>(tdim, entity index, point index, dim)</code>. </p>

</div>
</div>
<a id="a1e7f2fed5734ed3118a74cb836370611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7f2fed5734ed3118a74cb836370611">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::vector&lt;std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 4&gt; &gt; &gt;, 4&gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interpolation matrices for each subentity. </p>
<p>The shape of this data is <code>(tdim, entity index, dof, value size, point_index, derivative)</code>.</p>
<p>These matrices define how to evaluate the DOF functionals associated with each sub-entity of the cell. Given a function f, the functionals associated with the <code>e</code>-th entity of dimension <code>d</code> can be computed as follows:</p>
<div class="fragment"><div class="line">matrix = element.M()[d][e]</div>
<div class="line">pts = element.x()[d][e]</div>
<div class="line">nderivs = element</div>
<div class="line">values = f.eval_derivs(nderivs, pts)</div>
<div class="line">result = ZEROS(matrix.shape(0))</div>
<div class="line">FOR i IN RANGE(matrix.shape(0)):</div>
<div class="line">    FOR j IN RANGE(matrix.shape(1)):</div>
<div class="line">        FOR k IN RANGE(matrix.shape(2)):</div>
<div class="line">            FOR l IN RANGE(matrix.shape(3)):</div>
<div class="line">                result[i] += matrix[i, j, k, l] * values[l][k][j]</div>
</div><!-- fragment --><p>For example, for a degree 1 Raviart-Thomas (RT) element on a triangle, the DOF functionals are integrals over the edges of the dot product of the function with the normal to the edge. In this case, <code><a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6" title="Get the interpolation points for each subentity.">x()</a></code> would contain quadrature points for each edge, and <code><a class="el" href="classbasix_1_1FiniteElement.html#a1e7f2fed5734ed3118a74cb836370611" title="Get the interpolation matrices for each subentity.">M()</a></code> would be a 1 by 2 by <code>npoints</code> by 1 array for each edge. For each point, the <code>[0, :, point, 0]</code> slice of this would be the quadrature weight multiplied by the normal. For all entities that are not edges, the entries in <code><a class="el" href="classbasix_1_1FiniteElement.html#ad4160dd1b8ec0223b7a8d997a13775d6" title="Get the interpolation points for each subentity.">x()</a></code> and <code><a class="el" href="classbasix_1_1FiniteElement.html#a1e7f2fed5734ed3118a74cb836370611" title="Get the interpolation matrices for each subentity.">M()</a></code> for a degree 1 RT element would have size 0.</p>
<p>These matrices are only stored for custom elements. This function will throw an exception if called on a non-custom element </p><dl class="section return"><dt>Returns</dt><dd>The interpolation matrices. The indices of this data are <code>(tdim, entity index, dof, vs, point_index, derivative)</code>. </dd></dl>

</div>
</div>
<a id="a23f0c90d8010da4cde445b719fed0fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f0c90d8010da4cde445b719fed0fb7">&#9670;&nbsp;</a></span>coefficient_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt;std::vector&lt;F&gt;, std::array&lt;std::size_t, 2&gt; &gt;&amp; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::coefficient_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the matrix of coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>The coefficient matrix. Shape is <code>(ndofs, ndofs)</code>. </dd></dl>

</div>
</div>
<a id="a4aabff36857476d891ffc5c80d30b147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aabff36857476d891ffc5c80d30b147">&#9670;&nbsp;</a></span>has_tensor_product_factorisation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::has_tensor_product_factorisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not this element can be represented as a product of elements defined on lower-dimensional reference cells. </p>
<p>If the product exists, this element's basis functions can be computed as a tensor product of the basis elements of the elements in the product.</p>
<p>If such a factorisation exists, <a class="el" href="classbasix_1_1FiniteElement.html#a147a6c863dc4b0af508be9f4d0ff9927" title="Get the tensor product representation of this element.">get_tensor_product_representation()</a> can be used to get these elements. </p>

</div>
</div>
<a id="a147a6c863dc4b0af508be9f4d0ff9927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147a6c863dc4b0af508be9f4d0ff9927">&#9670;&nbsp;</a></span>get_tensor_product_representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a>&lt;F&gt; &gt; &gt; <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::get_tensor_product_representation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tensor product representation of this element. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if no such factorisation exists.</td></tr>
  </table>
  </dd>
</dl>
<p>The tensor product representation will be a vector of vectors of finite elements. Each tuple contains a vector of finite elements, and a vector of integers. The vector of finite elements gives the elements on an interval that appear in the tensor product representation. The vector of integers gives the permutation between the numbering of the tensor product DOFs and the number of the DOFs of this Basix element. </p><dl class="section return"><dt>Returns</dt><dd>The tensor product representation </dd></dl>

</div>
</div>
<a id="ad3d4c2f24fd524b00a6bf0ab283f87fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d4c2f24fd524b00a6bf0ab283f87fe">&#9670;&nbsp;</a></span>interpolation_is_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; F &gt;::interpolation_is_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not the interpolation matrix for this element is an identity matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the interpolation matrix is the identity and false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/basix/basix/cpp/basix/<a class="el" href="finite-element_8h_source.html">finite-element.h</a></li>
<li>/home/runner/work/basix/basix/cpp/basix/finite-element.cpp</li>
</ul>
</div><!-- contents -->

  </section>
</div>
<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    &copy; FEniCS Project 2025. Changes to this website can be made/suggested on <a href='https://github.com/FEniCS/web'>GitHub</a>.
  </footer>
</div>
</body>
</html>

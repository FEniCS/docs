<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="https://fenicsproject.org/assets/css/style.css">
    <link rel="apple-touch-icon" sizes="57x57" href="https://fenicsproject.org/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://fenicsproject.org/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://fenicsproject.org/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://fenicsproject.org/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://fenicsproject.org/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://fenicsproject.org/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://fenicsproject.org/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://fenicsproject.org/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://fenicsproject.org/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://fenicsproject.org/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://fenicsproject.org/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://fenicsproject.org/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://fenicsproject.org/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="https://fenicsproject.org/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#555555">
    <meta name="msapplication-TileImage" content="https://fenicsproject.org/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#555555">
    <link rel="stylesheet" type="text/css" href="https://fenicsproject.org/assets/css/customsty.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://use.fontawesome.com/ffd23b5274.js"></script>
    <script type='text/javascript'>
document.getElementById("MathJax-script").addEventListener('load', function () {
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['[[',']]']]
  },
  svg: {
    fontCache: 'global'
  }
}});
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basix: basix::FiniteElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
  </head>
<body>
<!-- HEADER -->
<div id="nav_head">
  <header class="inner" id="nav_head_inner">
    <a id="logo" href="/"><img src="https://fenicsproject.org/assets/img/fenics-logo-small.png"></a>
    <div class="top-navigation">
  <nav role="navigation" id="site-nav" class="nav">
    <ul>
        <li><a href="https://fenicsproject.org/people-of-fenics">People of FEniCS</a></li>
        <li><a href="https://fenicsproject.org/roadmap">Roadmap 2021-</a></li>
        <li><a href="https://fenicsproject.org/fenics-2022">FEniCS 2022</a></li>
        <li><a href="https://fenicsproject.org/download">Download</a></li>
        <li><a href="https://fenicsproject.org/documentation">Documentation</a></li>
        <li><a href="https://fenicsproject.org/community">Community</a></li>
        <li><a href="https://fenicsproject.org/governance">Governance</a></li>
        <li><a href="https://fenicsproject.org/citing">Citing</a></li>
        <li><a href="https://numfocus.salsalabs.org/donate-to-fenics/index.html">Donate</a></li>
    </ul>
  </nav>
</div>
  </header>
</div>
  <div id="header_wrap" class="outer" style="background-image:url(https://fenicsproject.org/assets/img/default-bg.png);background-repeat:repeat">
  <header class="inner">
  <h1 id="project_title">Basix 0.3.1.0
</h1>
  </header>
</div>
<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner"><h2 id="project_subtitle"><a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/index.html'>Home</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/install.html'>Installation</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python/demo'>Demos</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/cpp'>C++ docs</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python'>Python docs</a>
</h2>  </section>
</div><div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classbasix_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basix::FiniteElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A finite element.  
 <a href="classbasix_1_1FiniteElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="finite-element_8h_source.html">finite-element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bdb8d12c20fb875c86d6d805bdccf40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4bdb8d12c20fb875c86d6d805bdccf40">FiniteElement</a> (<a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> <a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a>, <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a>, const std::vector&lt; std::size_t &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a>, const xt::xtensor&lt; double, 3 &gt; &amp;coeffs, const std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, xt::xtensor&lt; double, 3 &gt;&gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a35c5f918982d6ad1448e436f7526b94e">entity_transformations</a>, const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt;, 4 &gt; &amp;x, const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 3 &gt;&gt;, 4 &gt; &amp;M, <a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#abd2f2e222254d8f1a3bf69964906e75d">map_type</a>, bool <a class="el" href="classbasix_1_1FiniteElement.html#aebfcc4fdf0ecb92a2ec4f315d221de51">discontinuous</a>)</td></tr>
<tr class="separator:a4bdb8d12c20fb875c86d6d805bdccf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memItemLeft" align="right" valign="top"><a id="ad6d31f4039d140b08a88e8cc6d33d06a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad6d31f4039d140b08a88e8cc6d33d06a">FiniteElement</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d657b79583dd417c18232057aafda98"><td class="memItemLeft" align="right" valign="top"><a id="a2d657b79583dd417c18232057aafda98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2d657b79583dd417c18232057aafda98">FiniteElement</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a2d657b79583dd417c18232057aafda98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2d657b79583dd417c18232057aafda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22cdbee8b090eaee4a441772c94a24"><td class="memItemLeft" align="right" valign="top"><a id="a8d22cdbee8b090eaee4a441772c94a24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8d22cdbee8b090eaee4a441772c94a24">~FiniteElement</a> ()=default</td></tr>
<tr class="memdesc:a8d22cdbee8b090eaee4a441772c94a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d22cdbee8b090eaee4a441772c94a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012641ff0a6abe1bda2e9493615c22fc"><td class="memItemLeft" align="right" valign="top"><a id="a012641ff0a6abe1bda2e9493615c22fc"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a012641ff0a6abe1bda2e9493615c22fc">operator=</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a012641ff0a6abe1bda2e9493615c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a012641ff0a6abe1bda2e9493615c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2bef969b9481371fa06f701009794"><td class="memItemLeft" align="right" valign="top"><a id="a0cd2bef969b9481371fa06f701009794"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cd2bef969b9481371fa06f701009794">operator=</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a0cd2bef969b9481371fa06f701009794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a0cd2bef969b9481371fa06f701009794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0074afdb7c640258fc6df3947c9c48"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::size_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9f0074afdb7c640258fc6df3947c9c48">tabulate_shape</a> (std::size_t nd, std::size_t num_points) const</td></tr>
<tr class="separator:a9f0074afdb7c640258fc6df3947c9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf3833eba5388b26727768a311c5965"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cf3833eba5388b26727768a311c5965">tabulate</a> (int nd, const xt::xarray&lt; double &gt; &amp;x) const</td></tr>
<tr class="separator:a0cf3833eba5388b26727768a311c5965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a416fb57cb90110ce476328ab99708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a86a416fb57cb90110ce476328ab99708">tabulate</a> (int nd, const xt::xarray&lt; double &gt; &amp;x, xt::xtensor&lt; double, 4 &gt; &amp;basis) const</td></tr>
<tr class="separator:a86a416fb57cb90110ce476328ab99708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e3921459dce5bff1cb731d1713ccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a> () const</td></tr>
<tr class="separator:a07e3921459dce5bff1cb731d1713ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9361216564eb22d899f1e961803392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a> () const</td></tr>
<tr class="separator:a6c9361216564eb22d899f1e961803392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2b0d7ce9c73d76c18f2cc1de08a59cb9">value_size</a> () const</td></tr>
<tr class="separator:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82325b132e0b989ee51338b7727ce38f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a> () const</td></tr>
<tr class="separator:a82325b132e0b989ee51338b7727ce38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d38980ecdf3be924a093b4d2319479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">dim</a> () const</td></tr>
<tr class="separator:a99d38980ecdf3be924a093b4d2319479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaa8df68d126f872c9d028a52709aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a> () const</td></tr>
<tr class="separator:aafaa8df68d126f872c9d028a52709aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad987bd4ad7cf140bf91101f15995ae69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad987bd4ad7cf140bf91101f15995ae69">mapping_type</a> () const</td></tr>
<tr class="separator:ad987bd4ad7cf140bf91101f15995ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfcc4fdf0ecb92a2ec4f315d221de51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aebfcc4fdf0ecb92a2ec4f315d221de51">discontinuous</a> () const</td></tr>
<tr class="separator:aebfcc4fdf0ecb92a2ec4f315d221de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a46dd5cfd393b08ca5e619c20c63c6ce5">dof_transformations_are_permutations</a> () const</td></tr>
<tr class="separator:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac5b7c1db36efbc036b8831e9c0ef7f1a">dof_transformations_are_identity</a> () const</td></tr>
<tr class="separator:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2afa4f636cec9cf68e725b6e29546f"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aec2afa4f636cec9cf68e725b6e29546f">map_push_forward</a> (const xt::xtensor&lt; double, 3 &gt; &amp;U, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K) const</td></tr>
<tr class="separator:aec2afa4f636cec9cf68e725b6e29546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48899f804c5fa9847c1d891fa00631e"><td class="memTemplParams" colspan="2">template&lt;typename O , typename P , typename Q , typename S , typename T &gt; </td></tr>
<tr class="memitem:ab48899f804c5fa9847c1d891fa00631e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ab48899f804c5fa9847c1d891fa00631e">map_push_forward_m</a> (const O &amp;U, const P &amp;J, const Q &amp;detJ, const S &amp;K, T &amp;&amp;u) const</td></tr>
<tr class="separator:ab48899f804c5fa9847c1d891fa00631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbcc0627d583ac0b73a3a0b2ff55301"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4bbcc0627d583ac0b73a3a0b2ff55301">map_pull_back</a> (const xt::xtensor&lt; double, 3 &gt; &amp;u, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K) const</td></tr>
<tr class="separator:a4bbcc0627d583ac0b73a3a0b2ff55301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae993ef90a0621a297e2c0d1f5fe4f68b"><td class="memTemplParams" colspan="2">template&lt;typename O , typename P , typename Q , typename S , typename T &gt; </td></tr>
<tr class="memitem:ae993ef90a0621a297e2c0d1f5fe4f68b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae993ef90a0621a297e2c0d1f5fe4f68b">map_pull_back_m</a> (const O &amp;u, const P &amp;J, const Q &amp;detJ, const S &amp;K, T &amp;&amp;U) const</td></tr>
<tr class="separator:ae993ef90a0621a297e2c0d1f5fe4f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba63ff5a4c5709ce34aea734f39ff38"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6ba63ff5a4c5709ce34aea734f39ff38">num_entity_dofs</a> () const</td></tr>
<tr class="separator:a6ba63ff5a4c5709ce34aea734f39ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d70fa1a7f22cf1a73345980843f8678"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8d70fa1a7f22cf1a73345980843f8678">num_entity_closure_dofs</a> () const</td></tr>
<tr class="separator:a8d70fa1a7f22cf1a73345980843f8678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572bc37d493eb6a9f2183b76f14cec20"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a572bc37d493eb6a9f2183b76f14cec20">entity_dofs</a> () const</td></tr>
<tr class="separator:a572bc37d493eb6a9f2183b76f14cec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d5b83865b234bc08f3675a5a6ccb0d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a69d5b83865b234bc08f3675a5a6ccb0d">entity_closure_dofs</a> () const</td></tr>
<tr class="separator:a69d5b83865b234bc08f3675a5a6ccb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f6d20c7990da4441b81bea8aab4ec"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aff0f6d20c7990da4441b81bea8aab4ec">base_transformations</a> () const</td></tr>
<tr class="separator:aff0f6d20c7990da4441b81bea8aab4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c5f918982d6ad1448e436f7526b94e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, xt::xtensor&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a35c5f918982d6ad1448e436f7526b94e">entity_transformations</a> () const</td></tr>
<tr class="separator:a35c5f918982d6ad1448e436f7526b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d4be5aabe5c1262a41aa906793e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac51d4be5aabe5c1262a41aa906793e4b">permute_dofs</a> (const xtl::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ac51d4be5aabe5c1262a41aa906793e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04faa96922aa2dd770c08839f38327c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae04faa96922aa2dd770c08839f38327c">unpermute_dofs</a> (const xtl::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae04faa96922aa2dd770c08839f38327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5004d8af1a79884ac72e31597f6f07f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5004d8af1a79884ac72e31597f6f07f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae5004d8af1a79884ac72e31597f6f07f">apply_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae5004d8af1a79884ac72e31597f6f07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f830ea050dd5038f62568f23aafd43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62f830ea050dd5038f62568f23aafd43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a62f830ea050dd5038f62568f23aafd43">apply_transpose_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a62f830ea050dd5038f62568f23aafd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9d7b7e7b94a8f7494d5f50963770265f">apply_inverse_transpose_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed686ad90b69dfbf69dc45b7e2469a4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed686ad90b69dfbf69dc45b7e2469a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aed686ad90b69dfbf69dc45b7e2469a4e">apply_inverse_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:aed686ad90b69dfbf69dc45b7e2469a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0062080a3fff8198323304982882ab1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0062080a3fff8198323304982882ab1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae0062080a3fff8198323304982882ab1">apply_dof_transformation_to_transpose</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae0062080a3fff8198323304982882ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134e38ab1f3cee5ea8af971c696bc90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae134e38ab1f3cee5ea8af971c696bc90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae134e38ab1f3cee5ea8af971c696bc90">apply_transpose_dof_transformation_to_transpose</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae134e38ab1f3cee5ea8af971c696bc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb254ba76aeea8621a09a39d3012e20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6eb254ba76aeea8621a09a39d3012e20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6eb254ba76aeea8621a09a39d3012e20">apply_inverse_transpose_dof_transformation_to_transpose</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a6eb254ba76aeea8621a09a39d3012e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54243f4dd49139b581f60d14e95f02a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54243f4dd49139b581f60d14e95f02a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a54243f4dd49139b581f60d14e95f02a0">apply_inverse_dof_transformation_to_transpose</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a54243f4dd49139b581f60d14e95f02a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507daff721c5d41e9d62b4e68e639bea"><td class="memItemLeft" align="right" valign="top">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">points</a> () const</td></tr>
<tr class="separator:a507daff721c5d41e9d62b4e68e639bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61674c5b124276e8ffd697541844d06e"><td class="memItemLeft" align="right" valign="top">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a61674c5b124276e8ffd697541844d06e">interpolation_matrix</a> () const</td></tr>
<tr class="separator:a61674c5b124276e8ffd697541844d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb08798be1ac44fc0074bcf9c92265e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdb08798be1ac44fc0074bcf9c92265e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#acdb08798be1ac44fc0074bcf9c92265e">interpolate</a> (const xtl::span&lt; T &gt; &amp;coefficients, const xtl::span&lt; const T &gt; &amp;data, const int block_size) const</td></tr>
<tr class="separator:acdb08798be1ac44fc0074bcf9c92265e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abd2f2e222254d8f1a3bf69964906e75d"><td class="memItemLeft" align="right" valign="top"><a id="abd2f2e222254d8f1a3bf69964906e75d"></a>
<a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#abd2f2e222254d8f1a3bf69964906e75d">map_type</a></td></tr>
<tr class="memdesc:abd2f2e222254d8f1a3bf69964906e75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element map type. <br /></td></tr>
<tr class="separator:abd2f2e222254d8f1a3bf69964906e75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A finite element. </p>
<p>The basis of a finite element is stored as a set of coefficients, which are applied to the underlying expansion set for that cell type, when tabulating. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4bdb8d12c20fb875c86d6d805bdccf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdb8d12c20fb875c86d6d805bdccf40">&#9670;&nbsp;</a></span>FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FiniteElement::FiniteElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, xt::xtensor&lt; double, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>entity_transformations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 3 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td>
          <td class="paramname"><em>map_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discontinuous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A finite element </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>The element family </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>The degree of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td>The value shape of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>Expansion coefficients of the basis functions in the underlying polynomial set. The shape is (num_dofs, value_size, basis_dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_transformations</td><td>Entity transformations representing the effect rotating and reflecting subentities of the cell has on the DOFs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation points. Shape is (tdim, entity index, point index, dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The interpolation matrices. Indices are (tdim, entity index, dof, vs, point_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_type</td><td>The type of map to be used to map values from the reference to a cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discontinuous</td><td>Indicates whether or not this is the discontinuous version of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5004d8af1a79884ac72e31597f6f07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5004d8af1a79884ac72e31597f6f07f">&#9670;&nbsp;</a></span>apply_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0062080a3fff8198323304982882ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0062080a3fff8198323304982882ab1">&#9670;&nbsp;</a></span>apply_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed686ad90b69dfbf69dc45b7e2469a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed686ad90b69dfbf69dc45b7e2469a4e">&#9670;&nbsp;</a></span>apply_inverse_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54243f4dd49139b581f60d14e95f02a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54243f4dd49139b581f60d14e95f02a0">&#9670;&nbsp;</a></span>apply_inverse_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d7b7e7b94a8f7494d5f50963770265f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7b7e7b94a8f7494d5f50963770265f">&#9670;&nbsp;</a></span>apply_inverse_transpose_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_transpose_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse transpose DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eb254ba76aeea8621a09a39d3012e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb254ba76aeea8621a09a39d3012e20">&#9670;&nbsp;</a></span>apply_inverse_transpose_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_transpose_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse transpose DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62f830ea050dd5038f62568f23aafd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f830ea050dd5038f62568f23aafd43">&#9670;&nbsp;</a></span>apply_transpose_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_transpose_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae134e38ab1f3cee5ea8af971c696bc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae134e38ab1f3cee5ea8af971c696bc90">&#9670;&nbsp;</a></span>apply_transpose_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_transpose_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f6d20c7990da4441b81bea8aab4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f6d20c7990da4441b81bea8aab4ec">&#9670;&nbsp;</a></span>base_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::base_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the base transformations The base transformations represent the effect of rotating or reflecting a subentity of the cell on the numbering and orientation of the DOFs. This returns a list of matrices with one matrix for each subentity permutation in the following order: Reversing edge 0, reversing edge 1, ... Rotate face 0, reflect face 0, rotate face 1, reflect face 1, ...</p>
<h2>Example: Order 3 Lagrange on a triangle </h2>
<p>This space has 10 dofs arranged like: </p><div class="fragment"><div class="line">2</div>
<div class="line">|\</div>
<div class="line">6 4</div>
<div class="line">|  \</div>
<div class="line">5 9 3</div>
<div class="line">|    \</div>
<div class="line">0-7-8-1</div>
</div><!-- fragment --><p>For this element, the base transformations are: [Matrix swapping 3 and 4, Matrix swapping 5 and 6, Matrix swapping 7 and 8] The first row shows the effect of reversing the diagonal edge. The second row shows the effect of reversing the vertical edge. The third row shows the effect of reversing the horizontal edge.</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>This space has 3 dofs arranged like: </p><div class="fragment"><div class="line">  |\</div>
<div class="line">  | \</div>
<div class="line">  |  \</div>
<div class="line">&lt;-1   0</div>
<div class="line">  |  / \</div>
<div class="line">  | L ^ \</div>
<div class="line">  |   |  \</div>
<div class="line">   ---2---</div>
</div><!-- fragment --><p>These DOFs are integrals of normal components over the edges: DOFs 0 and 2 are oriented inward, DOF 1 is oriented outwards. For this element, the base transformation matrices are: </p><div class="fragment"><div class="line">0: [[-1, 0, 0],</div>
<div class="line">    [ 0, 1, 0],</div>
<div class="line">    [ 0, 0, 1]]</div>
<div class="line">1: [[1,  0, 0],</div>
<div class="line">    [0, -1, 0],</div>
<div class="line">    [0,  0, 1]]</div>
<div class="line">2: [[1, 0,  0],</div>
<div class="line">    [0, 1,  0],</div>
<div class="line">    [0, 0, -1]]</div>
</div><!-- fragment --><p>The first matrix reverses DOF 0 (as this is on the first edge). The second matrix reverses DOF 1 (as this is on the second edge). The third matrix reverses DOF 2 (as this is on the third edge).</p>
<h2>Example: DOFs on the face of Order 2 Nedelec first kind on a tetrahedron </h2>
<p>On a face of this tetrahedron, this space has two face tangent DOFs: </p><div class="fragment"><div class="line">|\        |\</div>
<div class="line">| \       | \</div>
<div class="line">|  \      | ^\</div>
<div class="line">|   \     | | \</div>
<div class="line">| 0-&gt;\    | 1  \</div>
<div class="line">|     \   |     \</div>
<div class="line"> ------    ------</div>
</div><!-- fragment --><p>For these DOFs, the subblocks of the base transformation matrices are: </p><div class="fragment"><div class="line">rotation: [[-1, 1],</div>
<div class="line">           [ 1, 0]]</div>
<div class="line">reflection: [[0, 1],</div>
<div class="line">             [1, 0]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The base transformations for this element </dd></dl>

</div>
</div>
<a id="a07e3921459dce5bff1cb731d1713ccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e3921459dce5bff1cb731d1713ccc2">&#9670;&nbsp;</a></span>cell_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> FiniteElement::cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element cell type </p><dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
<a id="a6c9361216564eb22d899f1e961803392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9361216564eb22d899f1e961803392">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element polynomial degree </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a99d38980ecdf3be924a093b4d2319479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d38980ecdf3be924a093b4d2319479">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimension of the finite element space (number of degrees of freedom for the element) </p><dl class="section return"><dt>Returns</dt><dd>Number of degrees of freedom </dd></dl>

</div>
</div>
<a id="aebfcc4fdf0ecb92a2ec4f315d221de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfcc4fdf0ecb92a2ec4f315d221de51">&#9670;&nbsp;</a></span>discontinuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::discontinuous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this element is the discontinuous variant </p><dl class="section return"><dt>Returns</dt><dd>True if this element is a discontinuous version of the element </dd></dl>

</div>
</div>
<a id="ac5b7c1db36efbc036b8831e9c0ef7f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b7c1db36efbc036b8831e9c0ef7f1a">&#9670;&nbsp;</a></span>dof_transformations_are_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all the identity </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="a46dd5cfd393b08ca5e619c20c63c6ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dd5cfd393b08ca5e619c20c63c6ce5">&#9670;&nbsp;</a></span>dof_transformations_are_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_permutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all permutations </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="a69d5b83865b234bc08f3675a5a6ccb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d5b83865b234bc08f3675a5a6ccb0d">&#9670;&nbsp;</a></span>entity_closure_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp; FiniteElement::entity_closure_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dofs on the closure of each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[1, 2, 3], [0, 2, 4], [0, 1, 5]], cell: [[0, 1, 2, 3, 4, 5]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with the closure of an entity of a given topological dimension. The shape is (tdim + 1, num_entities, num_dofs). </dd></dl>

</div>
</div>
<a id="a572bc37d493eb6a9f2183b76f14cec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572bc37d493eb6a9f2183b76f14cec20">&#9670;&nbsp;</a></span>entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp; FiniteElement::entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dofs on each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[3], [4], [5]], cell: [[]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with an entity of a given topological dimension. The shape is (tdim + 1, num_entities, num_dofs). </dd></dl>

</div>
</div>
<a id="a35c5f918982d6ad1448e436f7526b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c5f918982d6ad1448e436f7526b94e">&#9670;&nbsp;</a></span>entity_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, xt::xtensor&lt; double, 3 &gt; &gt; FiniteElement::entity_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the entity dof transformation matrices </p><dl class="section return"><dt>Returns</dt><dd>The entity transformations for the subentities of this element </dd></dl>

</div>
</div>
<a id="aafaa8df68d126f872c9d028a52709aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaa8df68d126f872c9d028a52709aaf">&#9670;&nbsp;</a></span>family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> FiniteElement::family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the finite element family </p><dl class="section return"><dt>Returns</dt><dd>The family </dd></dl>

</div>
</div>
<a id="acdb08798be1ac44fc0074bcf9c92265e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb08798be1ac44fc0074bcf9c92265e">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::interpolate </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the coefficients of a function given the values of the function at the interpolation points.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd>
<dd>
This function will be removed in a future version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">coefficients</td><td>The coefficients of the function's interpolation into the function space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The function evaluated at the points given by <code><a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">points()</a></code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>The block size of the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61674c5b124276e8ffd697541844d06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61674c5b124276e8ffd697541844d06e">&#9670;&nbsp;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const xt::xtensor&lt; double, 2 &gt; &amp; FiniteElement::interpolation_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a matrix of weights interpolation To interpolate a function in this finite element, the functions should be evaluated at each point given by <a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">FiniteElement::points()</a>. These function values should then be multiplied by the weight matrix to give the coefficients of the interpolated function.</p>
<p>The shape of the returned matrix will be <code>(dim, num_points * value_size)</code>, where <code>dim</code> is the number of DOFs in the finite element, <code>num_points</code> is the number of points returned by <code><a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">points()</a></code>, and <code>value_size</code> is the value size of the finite element.</p>
<p>For example, to interpolate into a Lagrange space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">values = vector(pts.shape(0))</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Raviart-Thomas space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">vs = element.value_size()</div>
<div class="line">values = VECTOR(pts.shape(0) * vs)</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i::pts.shape(0)] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Lagrange space with a block size, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">coefficients = VECTOR(element.dim() * block_size)</div>
<div class="line">FOR b IN RANGE(block_size):</div>
<div class="line">    values = vector(pts.shape(0))</div>
<div class="line">    FOR i, p IN ENUMERATE(pts):</div>
<div class="line">        values[i] = f.evaluate_at(p)[b]</div>
<div class="line">    coefficients[::block_size] = i_m * values</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The interpolation matrix </dd></dl>

</div>
</div>
<a id="a4bbcc0627d583ac0b73a3a0b2ff55301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbcc0627d583ac0b73a3a0b2ff55301">&#9670;&nbsp;</a></span>map_pull_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::map_pull_back </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The function values on the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the reference </dd></dl>

</div>
</div>
<a id="ae993ef90a0621a297e2c0d1f5fe4f68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae993ef90a0621a297e2c0d1f5fe4f68b">&#9670;&nbsp;</a></span>map_pull_back_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename P , typename Q , typename S , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::map_pull_back_m </td>
          <td>(</td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map function values from a physical cell back to to the reference</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Data defined on the physical element. It must have dimension 3. The first index is for the geometric/map data, the second is the point index for points that share map data, and the third index is (vector) component, e.g. <code>u[i,:,:]</code> are points that are mapped by <code>J[i,:,:]</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobians. It must have dimension 3. The first index is for the ith Jacobian, i.e. J[i,:,:] is the ith Jacobian. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of J. <code>detJ[i]</code> is equal to <code>det(J[i,:,:])</code>. It must have dimension 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of J, <code>K[i,:,:] = J[i,:,:]^-1</code>. It must have dimension 3. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>The input <code>u</code> mapped to the reference element. It must have dimension 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec2afa4f636cec9cf68e725b6e29546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2afa4f636cec9cf68e725b6e29546f">&#9670;&nbsp;</a></span>map_push_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::map_push_forward </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from the reference to a physical cell. This function can perform the mapping for multiple points, grouped by points that share a common Jacobian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>The function values on the reference. The indices are [Jacobian index, point index, components]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping. The indices are [Jacobian index, J_i, J_j]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping. It has length <code>J.shape(0)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping. The indices are [Jacobian index, K_i, K_j]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the cell. The indices are [Jacobian index, point index, components]. </dd></dl>

</div>
</div>
<a id="ab48899f804c5fa9847c1d891fa00631e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48899f804c5fa9847c1d891fa00631e">&#9670;&nbsp;</a></span>map_push_forward_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename P , typename Q , typename S , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::map_push_forward_m </td>
          <td>(</td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Direct to memory push forward</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>Data defined on the reference element. It must have dimension 3. The first index is for the geometric/map data, the second is the point index for points that share map data, and the third index is (vector) component, e.g. <code>u[i,:,:]</code> are points that are mapped by <code>J[i,:,:]</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobians. It must have dimension 3. The first index is for the ith Jacobian, i.e. J[i,:,:] is the ith Jacobian. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of J. <code>detJ[i]</code> is equal to <code>det(J[i,:,:])</code>. It must have dimension 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of J, <code>K[i,:,:] = J[i,:,:]^-1</code>. It must have dimension 3. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The input <code>U</code> mapped to the physical. It must have dimension 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad987bd4ad7cf140bf91101f15995ae69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad987bd4ad7cf140bf91101f15995ae69">&#9670;&nbsp;</a></span>mapping_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> FiniteElement::mapping_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mapping type used for this element </p><dl class="section return"><dt>Returns</dt><dd>The mapping </dd></dl>

</div>
</div>
<a id="a8d70fa1a7f22cf1a73345980843f8678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d70fa1a7f22cf1a73345980843f8678">&#9670;&nbsp;</a></span>num_entity_closure_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; FiniteElement::num_entity_closure_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dofs on the closure of each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [1, 1, 1], edges: [3, 3, 3], cell: [6] </p><dl class="section return"><dt>Returns</dt><dd>Number of dofs associated with the closure of an entity of a given topological dimension. The shape is (tdim + 1, num_entities). </dd></dl>

</div>
</div>
<a id="a6ba63ff5a4c5709ce34aea734f39ff38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba63ff5a4c5709ce34aea734f39ff38">&#9670;&nbsp;</a></span>num_entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; FiniteElement::num_entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dofs on each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [1, 1, 1], edges: [1, 1, 1], cell: [0] The sum of the entity dofs must match the total number of dofs reported by <a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">FiniteElement::dim</a>, </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::vector&lt;int&gt;&gt;&amp; dofs = e.entity_dofs();</div>
<div class="line"><span class="keywordtype">int</span> num_dofs0 = dofs[1][3]; <span class="comment">// Number of dofs associated with edge 3</span></div>
<div class="line"><span class="keywordtype">int</span> num_dofs1 = dofs[2][0]; <span class="comment">// Number of dofs associated with face 0</span></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Number of dofs associated with an entity of a given topological dimension. The shape is (tdim + 1, num_entities). </dd></dl>

</div>
</div>
<a id="ac51d4be5aabe5c1262a41aa906793e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d4be5aabe5c1262a41aa906793e4b">&#9670;&nbsp;</a></span>permute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::permute_dofs </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permute the dof numbering on a cell</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507daff721c5d41e9d62b4e68e639bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507daff721c5d41e9d62b4e68e639bea">&#9670;&nbsp;</a></span>points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const xt::xtensor&lt; double, 2 &gt; &amp; FiniteElement::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interpolation points, i.e. the coordinates on the reference element where a function need to be evaluated in order to interpolate it in the finite element space. </p><dl class="section return"><dt>Returns</dt><dd>Array of coordinate with shape <code>(num_points, tdim)</code> </dd></dl>

</div>
</div>
<a id="a0cf3833eba5388b26727768a311c5965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf3833eba5388b26727768a311c5965">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 4 &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="section note"><dt>Note</dt><dd>The version of <code><a class="el" href="classbasix_1_1FiniteElement.html#a0cf3833eba5388b26727768a311c5965">FiniteElement::tabulate</a></code> with the basis data as an out argument should be preferred for repeated call where performance is critical</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, i.e. for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a86a416fb57cb90110ce476328ab99708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a416fb57cb90110ce476328ab99708">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xt::xtensor&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basis</td><td>Memory location to fill. It must be allocated with shape (num_derivatives, num_points, num basis functions, value_size). The function <code><a class="el" href="classbasix_1_1FiniteElement.html#a9f0074afdb7c640258fc6df3947c9c48">FiniteElement::tabulate_shape</a></code> can be used to get the required shape.<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, i.e. for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Remove all internal dynamic memory allocation, pass scratch space as required </dd></dl>

</div>
</div>
<a id="a9f0074afdb7c640258fc6df3947c9c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0074afdb7c640258fc6df3947c9c48">&#9670;&nbsp;</a></span>tabulate_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::size_t, 4 &gt; FiniteElement::tabulate_shape </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_points</td><td>Number of points that basis will be computed at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the array to will filled when passed to <code><a class="el" href="classbasix_1_1FiniteElement.html#a0cf3833eba5388b26727768a311c5965">FiniteElement::tabulate</a></code> </dd></dl>

</div>
</div>
<a id="ae04faa96922aa2dd770c08839f38327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04faa96922aa2dd770c08839f38327c">&#9670;&nbsp;</a></span>unpermute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::unpermute_dofs </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpermute the dof numbering on a cell</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82325b132e0b989ee51338b7727ce38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82325b132e0b989ee51338b7727ce38f">&#9670;&nbsp;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; FiniteElement::value_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value tensor shape, e.g. returning [1] for scalars. </p><dl class="section return"><dt>Returns</dt><dd>Value shape </dd></dl>

</div>
</div>
<a id="a2b0d7ce9c73d76c18f2cc1de08a59cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0d7ce9c73d76c18f2cc1de08a59cb9">&#9670;&nbsp;</a></span>value_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::value_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value size This is just a convenience function returning product(value_shape) </p><dl class="section return"><dt>Returns</dt><dd>Value size </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/basix/basix/cpp/basix/<a class="el" href="finite-element_8h_source.html">finite-element.h</a></li>
<li>/home/runner/work/basix/basix/cpp/basix/finite-element.cpp</li>
</ul>
</div><!-- contents -->

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    &copy; FEniCS Project 2021. Changes to this website can be made/suggested on <a href='https://github.com/FEniCS/web'>GitHub</a>.
  </footer>
</div>
</body>
</html>

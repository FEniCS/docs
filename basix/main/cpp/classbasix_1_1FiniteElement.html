<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="https://fenicsproject.org/assets/css/style.css">
    <link rel="apple-touch-icon" sizes="57x57" href="https://fenicsproject.org/assets/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://fenicsproject.org/assets/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://fenicsproject.org/assets/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://fenicsproject.org/assets/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://fenicsproject.org/assets/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://fenicsproject.org/assets/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://fenicsproject.org/assets/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://fenicsproject.org/assets/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://fenicsproject.org/assets/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://fenicsproject.org/assets/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://fenicsproject.org/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://fenicsproject.org/assets/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://fenicsproject.org/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="https://fenicsproject.org/assets/icons/manifest.json">
    <meta name="msapplication-TileColor" content="#555555">
    <meta name="msapplication-TileImage" content="https://fenicsproject.org/assets/icons/ms-icon-144x144.png">
    <meta name="theme-color" content="#555555">
    <link rel="stylesheet" type="text/css" href="https://fenicsproject.org/assets/css/customsty.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://kit.fontawesome.com/5506de0e1b.js" crossorigin="anonymous"></script>
    <script type='text/javascript'>
document.getElementById("MathJax-script").addEventListener('load', function () {
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['[[',']]']]
  },
  svg: {
    fontCache: 'global'
  }
}});
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basix: basix::FiniteElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
  </head>
<body>
<!-- HEADER -->
<div id="nav_head">
  <header class="inner" id="nav_head_inner">
    <a id="logo" href="/"><img src="https://fenicsproject.org/assets/img/fenics-logo-small.png"></a>
    <div class="top-navigation">
  <nav role="navigation" id="site-nav" class="nav">
    <ul>
        <li><a href="https://fenicsproject.org/fenics-2023">FEniCS 2023</a></li>
        <li><a href="https://fenicsproject.org/download">Download</a></li>
        <li><a href="https://fenicsproject.org/documentation">Documentation</a></li>
        <li><a href="https://fenicsproject.org/community">Community</a></li>
        <li><a href="https://fenicsproject.org/citing">Citing</a></li>
        <li><a href="https://numfocus.salsalabs.org/donate-to-fenics/index.html">Donate</a></li>
    </ul>
  </nav>
</div>
  </header>
</div>
  <div id="header_wrap" class="outer" style="background-image:url(https://fenicsproject.org/assets/img/default-bg.png);background-repeat:repeat">
  <header class="inner">
  <h1 id="project_title">Basix 0.7.0.0
</h1>
  </header>
</div>
<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner"><h2 id="project_subtitle"><a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/index.html'>Home</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/install.html'>Installation</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python/demo'>Demos</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/cpp'>C++ docs</a>
&nbsp;
&nbsp;
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python'>Python docs</a>
</h2>  </section>
</div><div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbasix_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basix::FiniteElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A finite element.  
 <a href="classbasix_1_1FiniteElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="finite-element_8h_source.html">finite-element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a263e785dd3d083af75a6b07bfd87dd00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a263e785dd3d083af75a6b07bfd87dd00">FiniteElement</a> (<a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> <a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a>, <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a>, const std::vector&lt; std::size_t &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a879496da4405a7273ba8045b1299f66b">value_shape</a>, const cmdspan2_t &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a9295f480358ceb856cf9e61b045b751c">wcoeffs</a>, const std::array&lt; std::vector&lt; cmdspan2_t &gt;, 4 &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a>, const std::array&lt; std::vector&lt; cmdspan4_t &gt;, 4 &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#ae48dbe8218a020276179532c55a65f5c">M</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a5e08d22679a1f54e8bf128909b535879">interpolation_nderivs</a>, <a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a4718b4f0231b8287288ca7fb28588977">map_type</a>, <a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a> <a class="el" href="classbasix_1_1FiniteElement.html#a126fcc52ed6994188309a0f0b94ae30a">sobolev_space</a>, bool <a class="el" href="classbasix_1_1FiniteElement.html#aebfcc4fdf0ecb92a2ec4f315d221de51">discontinuous</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a1ec5b8fe7b275dc4ddf373974757a8de">highest_complete_degree</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a9ce5bdcac7c0acaafe9dcf45c74f1301">highest_degree</a>, <a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a> lvariant, <a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a> dvariant, std::vector&lt; std::tuple&lt; std::vector&lt; <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &gt;, std::vector&lt; int &gt;&gt;&gt; tensor_factors={}, std::vector&lt; int &gt; <a class="el" href="classbasix_1_1FiniteElement.html#a6bef73c73caaadabc9f7cf9fcab4d2fa">dof_ordering</a>={})</td></tr>
<tr class="memdesc:a263e785dd3d083af75a6b07bfd87dd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a finite element.  <a href="classbasix_1_1FiniteElement.html#a263e785dd3d083af75a6b07bfd87dd00">More...</a><br /></td></tr>
<tr class="separator:a263e785dd3d083af75a6b07bfd87dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memItemLeft" align="right" valign="top"><a id="ad6d31f4039d140b08a88e8cc6d33d06a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad6d31f4039d140b08a88e8cc6d33d06a">FiniteElement</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d657b79583dd417c18232057aafda98"><td class="memItemLeft" align="right" valign="top"><a id="a2d657b79583dd417c18232057aafda98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2d657b79583dd417c18232057aafda98">FiniteElement</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a2d657b79583dd417c18232057aafda98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2d657b79583dd417c18232057aafda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22cdbee8b090eaee4a441772c94a24"><td class="memItemLeft" align="right" valign="top"><a id="a8d22cdbee8b090eaee4a441772c94a24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8d22cdbee8b090eaee4a441772c94a24">~FiniteElement</a> ()=default</td></tr>
<tr class="memdesc:a8d22cdbee8b090eaee4a441772c94a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d22cdbee8b090eaee4a441772c94a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012641ff0a6abe1bda2e9493615c22fc"><td class="memItemLeft" align="right" valign="top"><a id="a012641ff0a6abe1bda2e9493615c22fc"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a012641ff0a6abe1bda2e9493615c22fc">operator=</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a012641ff0a6abe1bda2e9493615c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a012641ff0a6abe1bda2e9493615c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2bef969b9481371fa06f701009794"><td class="memItemLeft" align="right" valign="top"><a id="a0cd2bef969b9481371fa06f701009794"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cd2bef969b9481371fa06f701009794">operator=</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a0cd2bef969b9481371fa06f701009794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a0cd2bef969b9481371fa06f701009794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c8049d19ca40e09189498feeee720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a369c8049d19ca40e09189498feeee720">operator==</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;e) const</td></tr>
<tr class="separator:a369c8049d19ca40e09189498feeee720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0074afdb7c640258fc6df3947c9c48"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::size_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9f0074afdb7c640258fc6df3947c9c48">tabulate_shape</a> (std::size_t nd, std::size_t num_points) const</td></tr>
<tr class="separator:a9f0074afdb7c640258fc6df3947c9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0618f0de76f2eab3a8f897a083b0a85d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0618f0de76f2eab3a8f897a083b0a85d">tabulate</a> (int nd, impl::cmdspan2_t <a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a>) const</td></tr>
<tr class="memdesc:a0618f0de76f2eab3a8f897a083b0a85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis values and derivatives at set of points.  <a href="classbasix_1_1FiniteElement.html#a0618f0de76f2eab3a8f897a083b0a85d">More...</a><br /></td></tr>
<tr class="separator:a0618f0de76f2eab3a8f897a083b0a85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d719bc02bb7d0ac200298268cba0a3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a63d719bc02bb7d0ac200298268cba0a3">tabulate</a> (int nd, const std::span&lt; const double &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a>, std::array&lt; std::size_t, 2 &gt; shape) const</td></tr>
<tr class="separator:a63d719bc02bb7d0ac200298268cba0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc4683d0f9604b7a4b7fbf5bf08ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2efc4683d0f9604b7a4b7fbf5bf08ba3">tabulate</a> (int nd, impl::cmdspan2_t <a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a>, impl::mdspan4_t basis) const</td></tr>
<tr class="separator:a2efc4683d0f9604b7a4b7fbf5bf08ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d90fa4352ce7b29dc0e5dd3dcd7fd38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a1d90fa4352ce7b29dc0e5dd3dcd7fd38">tabulate</a> (int nd, const std::span&lt; const double &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a>, std::array&lt; std::size_t, 2 &gt; xshape, const std::span&lt; double &gt; &amp;basis) const</td></tr>
<tr class="separator:a1d90fa4352ce7b29dc0e5dd3dcd7fd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e3921459dce5bff1cb731d1713ccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a> () const</td></tr>
<tr class="separator:a07e3921459dce5bff1cb731d1713ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9361216564eb22d899f1e961803392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a> () const</td></tr>
<tr class="separator:a6c9361216564eb22d899f1e961803392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce5bdcac7c0acaafe9dcf45c74f1301"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9ce5bdcac7c0acaafe9dcf45c74f1301">highest_degree</a> () const</td></tr>
<tr class="separator:a9ce5bdcac7c0acaafe9dcf45c74f1301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5b8fe7b275dc4ddf373974757a8de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a1ec5b8fe7b275dc4ddf373974757a8de">highest_complete_degree</a> () const</td></tr>
<tr class="separator:a1ec5b8fe7b275dc4ddf373974757a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879496da4405a7273ba8045b1299f66b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a879496da4405a7273ba8045b1299f66b">value_shape</a> () const</td></tr>
<tr class="separator:a879496da4405a7273ba8045b1299f66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d38980ecdf3be924a093b4d2319479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">dim</a> () const</td></tr>
<tr class="separator:a99d38980ecdf3be924a093b4d2319479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaa8df68d126f872c9d028a52709aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a> () const</td></tr>
<tr class="separator:aafaa8df68d126f872c9d028a52709aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277701eea33cb029f3b0b3b3be2b4de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a277701eea33cb029f3b0b3b3be2b4de2">lagrange_variant</a> () const</td></tr>
<tr class="separator:a277701eea33cb029f3b0b3b3be2b4de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06a0c9f071d90d6ea452f9afe7c109d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aa06a0c9f071d90d6ea452f9afe7c109d">dpc_variant</a> () const</td></tr>
<tr class="separator:aa06a0c9f071d90d6ea452f9afe7c109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718b4f0231b8287288ca7fb28588977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4718b4f0231b8287288ca7fb28588977">map_type</a> () const</td></tr>
<tr class="separator:a4718b4f0231b8287288ca7fb28588977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126fcc52ed6994188309a0f0b94ae30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a126fcc52ed6994188309a0f0b94ae30a">sobolev_space</a> () const</td></tr>
<tr class="separator:a126fcc52ed6994188309a0f0b94ae30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfcc4fdf0ecb92a2ec4f315d221de51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aebfcc4fdf0ecb92a2ec4f315d221de51">discontinuous</a> () const</td></tr>
<tr class="separator:aebfcc4fdf0ecb92a2ec4f315d221de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a46dd5cfd393b08ca5e619c20c63c6ce5">dof_transformations_are_permutations</a> () const</td></tr>
<tr class="separator:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac5b7c1db36efbc036b8831e9c0ef7f1a">dof_transformations_are_identity</a> () const</td></tr>
<tr class="separator:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f00687e930074dc5fa0b68c95f2fa64"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9f00687e930074dc5fa0b68c95f2fa64">push_forward</a> (impl::cmdspan3_t U, impl::cmdspan3_t J, std::span&lt; const double &gt; detJ, impl::cmdspan3_t K) const</td></tr>
<tr class="separator:a9f00687e930074dc5fa0b68c95f2fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba1339b521932d8872a74716d19f6e6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#acba1339b521932d8872a74716d19f6e6">pull_back</a> (impl::cmdspan3_t u, impl::cmdspan3_t J, std::span&lt; const double &gt; detJ, impl::cmdspan3_t K) const</td></tr>
<tr class="separator:acba1339b521932d8872a74716d19f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7cb986a2f58c91579b8f4f7b7f7aa7"><td class="memTemplParams" colspan="2">template&lt;typename O , typename P , typename Q , typename R &gt; </td></tr>
<tr class="memitem:a6f7cb986a2f58c91579b8f4f7b7f7aa7"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(O &amp;, const P &amp;, const Q &amp;, double, const R &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6f7cb986a2f58c91579b8f4f7b7f7aa7">map_fn</a> () const</td></tr>
<tr class="separator:a6f7cb986a2f58c91579b8f4f7b7f7aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572bc37d493eb6a9f2183b76f14cec20"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a572bc37d493eb6a9f2183b76f14cec20">entity_dofs</a> () const</td></tr>
<tr class="separator:a572bc37d493eb6a9f2183b76f14cec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d5b83865b234bc08f3675a5a6ccb0d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a69d5b83865b234bc08f3675a5a6ccb0d">entity_closure_dofs</a> () const</td></tr>
<tr class="separator:a69d5b83865b234bc08f3675a5a6ccb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13dc5c1e4e0980929e5a1d6c06aa6fc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae13dc5c1e4e0980929e5a1d6c06aa6fc">base_transformations</a> () const</td></tr>
<tr class="memdesc:ae13dc5c1e4e0980929e5a1d6c06aa6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base transformations.  <a href="classbasix_1_1FiniteElement.html#ae13dc5c1e4e0980929e5a1d6c06aa6fc">More...</a><br /></td></tr>
<tr class="separator:ae13dc5c1e4e0980929e5a1d6c06aa6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056bdf81657a17a2de95947b9ad12a36"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a056bdf81657a17a2de95947b9ad12a36">entity_transformations</a> () const</td></tr>
<tr class="separator:a056bdf81657a17a2de95947b9ad12a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a741f90888d4c9477ee8b7e2754513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ab4a741f90888d4c9477ee8b7e2754513">permute_dofs</a> (const std::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ab4a741f90888d4c9477ee8b7e2754513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af627afd9aeee8237cf7552b4652c437a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#af627afd9aeee8237cf7552b4652c437a">unpermute_dofs</a> (const std::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:af627afd9aeee8237cf7552b4652c437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff134bf4cb89bf2065468d2dafc815"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5ff134bf4cb89bf2065468d2dafc815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae5ff134bf4cb89bf2065468d2dafc815">apply_dof_transformation</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae5ff134bf4cb89bf2065468d2dafc815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eb716f9fa348dc5a1cd5fbc31f6cac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84eb716f9fa348dc5a1cd5fbc31f6cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a84eb716f9fa348dc5a1cd5fbc31f6cac">apply_transpose_dof_transformation</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a84eb716f9fa348dc5a1cd5fbc31f6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd239adb249fe4e3b34615baa80dd769"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd239adb249fe4e3b34615baa80dd769"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#abd239adb249fe4e3b34615baa80dd769">apply_inverse_transpose_dof_transformation</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:abd239adb249fe4e3b34615baa80dd769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb75e2f0034bf656eeb75dfc9319ddf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb75e2f0034bf656eeb75dfc9319ddf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#afb75e2f0034bf656eeb75dfc9319ddf6">apply_inverse_dof_transformation</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:afb75e2f0034bf656eeb75dfc9319ddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa761bd48f858048da5494a54c3c394"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fa761bd48f858048da5494a54c3c394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a7fa761bd48f858048da5494a54c3c394">apply_dof_transformation_to_transpose</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a7fa761bd48f858048da5494a54c3c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cb7ea73d280d5c7f25e302e9695f33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9cb7ea73d280d5c7f25e302e9695f33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#af9cb7ea73d280d5c7f25e302e9695f33">apply_transpose_dof_transformation_to_transpose</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:af9cb7ea73d280d5c7f25e302e9695f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c9ba514d73732418677ea44040f19b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2c9ba514d73732418677ea44040f19b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae2c9ba514d73732418677ea44040f19b">apply_inverse_transpose_dof_transformation_to_transpose</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="memdesc:ae2c9ba514d73732418677ea44040f19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply inverse transpose DOF transformations to some transposed data.  <a href="classbasix_1_1FiniteElement.html#ae2c9ba514d73732418677ea44040f19b">More...</a><br /></td></tr>
<tr class="separator:ae2c9ba514d73732418677ea44040f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab6ed2a4557848808ead1082e1cbc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafab6ed2a4557848808ead1082e1cbc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aafab6ed2a4557848808ead1082e1cbc9">apply_inverse_dof_transformation_to_transpose</a> (std::span&lt; T &gt; data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:aafab6ed2a4557848808ead1082e1cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6193aeef301ffaf1da69dea0b0f214"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6b6193aeef301ffaf1da69dea0b0f214">points</a> () const</td></tr>
<tr class="separator:a6b6193aeef301ffaf1da69dea0b0f214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a9930d71935bcf4b559a433d53e2d0"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad7a9930d71935bcf4b559a433d53e2d0">interpolation_matrix</a> () const</td></tr>
<tr class="memdesc:ad7a9930d71935bcf4b559a433d53e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix of weights interpolation,.  <a href="classbasix_1_1FiniteElement.html#ad7a9930d71935bcf4b559a433d53e2d0">More...</a><br /></td></tr>
<tr class="separator:ad7a9930d71935bcf4b559a433d53e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c56bfac8f3a1e05fcc15e354868a3ae"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a5c56bfac8f3a1e05fcc15e354868a3ae">dual_matrix</a> () const</td></tr>
<tr class="separator:a5c56bfac8f3a1e05fcc15e354868a3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295f480358ceb856cf9e61b045b751c"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9295f480358ceb856cf9e61b045b751c">wcoeffs</a> () const</td></tr>
<tr class="separator:a9295f480358ceb856cf9e61b045b751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3962070c7d180f128d5814f25bedc12c"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &gt;, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x</a> () const</td></tr>
<tr class="separator:a3962070c7d180f128d5814f25bedc12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48dbe8218a020276179532c55a65f5c"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt; &gt;, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae48dbe8218a020276179532c55a65f5c">M</a> () const</td></tr>
<tr class="separator:ae48dbe8218a020276179532c55a65f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89171fc632b3408643faa22bf04b835f"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a89171fc632b3408643faa22bf04b835f">coefficient_matrix</a> () const</td></tr>
<tr class="separator:a89171fc632b3408643faa22bf04b835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b653fd5ef231b610abae7fabe96d2d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8b653fd5ef231b610abae7fabe96d2d4">has_tensor_product_factorisation</a> () const</td></tr>
<tr class="separator:a8b653fd5ef231b610abae7fabe96d2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1344636dc8d83c5ca71a9682174c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; std::vector&lt; <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &gt;, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a55b1344636dc8d83c5ca71a9682174c2">get_tensor_product_representation</a> () const</td></tr>
<tr class="separator:a55b1344636dc8d83c5ca71a9682174c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacde51327c7da17f2da16f3ace3f3a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#adacde51327c7da17f2da16f3ace3f3a2">interpolation_is_identity</a> () const</td></tr>
<tr class="separator:adacde51327c7da17f2da16f3ace3f3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e08d22679a1f54e8bf128909b535879"><td class="memItemLeft" align="right" valign="top"><a id="a5e08d22679a1f54e8bf128909b535879"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a5e08d22679a1f54e8bf128909b535879">interpolation_nderivs</a> () const</td></tr>
<tr class="memdesc:a5e08d22679a1f54e8bf128909b535879"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of derivatives needed when interpolating. <br /></td></tr>
<tr class="separator:a5e08d22679a1f54e8bf128909b535879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bef73c73caaadabc9f7cf9fcab4d2fa"><td class="memItemLeft" align="right" valign="top"><a id="a6bef73c73caaadabc9f7cf9fcab4d2fa"></a>
const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6bef73c73caaadabc9f7cf9fcab4d2fa">dof_ordering</a> () const</td></tr>
<tr class="memdesc:a6bef73c73caaadabc9f7cf9fcab4d2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dof layout. <br /></td></tr>
<tr class="separator:a6bef73c73caaadabc9f7cf9fcab4d2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A finite element. </p>
<p>The basis of a finite element is stored as a set of coefficients, which are applied to the underlying expansion set for that cell type, when tabulating. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a263e785dd3d083af75a6b07bfd87dd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263e785dd3d083af75a6b07bfd87dd00">&#9670;&nbsp;</a></span>FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FiniteElement::FiniteElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cmdspan2_t &amp;&#160;</td>
          <td class="paramname"><em>wcoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; cmdspan2_t &gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; cmdspan4_t &gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation_nderivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td>
          <td class="paramname"><em>map_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a>&#160;</td>
          <td class="paramname"><em>sobolev_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discontinuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>highest_complete_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>highest_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a>&#160;</td>
          <td class="paramname"><em>lvariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a>&#160;</td>
          <td class="paramname"><em>dvariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::vector&lt; <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &gt;, std::vector&lt; int &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>tensor_factors</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dof_ordering</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a finite element. </p>
<p>Initialising a finite element calculates the basis functions of the finite element, in terms of the polynomial basis.</p>
<p>The below explanation uses Einstein notation.</p>
<p>The basis functions \({\phi_i}\) of a finite element are represented as a linear combination of polynomials \(\{p_j\}\) in an underlying polynomial basis that span the space of all d-dimensional polynomials up to order \(k \ (P_k^d)\): </p><p class="formulaDsp">
\[ \phi_i = c_{ij} p_j \]
</p>
<p>In some cases, the basis functions \(\{\phi_i\}\) do not span the full space \(P_k\), in which case we denote space spanned by the basis functions by \(\{q_k\}\), which can be represented by: </p><p class="formulaDsp">
\[ q_i = b_{ij} p_j. \]
</p>
<p> This leads to </p><p class="formulaDsp">
\[ \phi_i = c^{\prime}_{ij} q_j = c^{\prime}_{ij} b_{jk} p_k, \]
</p>
<p> and in matrix form: </p><p class="formulaDsp">
\[ \phi = C^{\prime} B p \]
</p>
<p>If the basis functions span the full space, then \( B \) is simply the identity.</p>
<p>The basis functions \(\phi_i\) are defined by a dual set of functionals \(\{f_i\}\). The basis functions are the functions in span{ \(q_k\)} such that </p><p class="formulaDsp">
\[ f_i(\phi_j) = \delta_{ij} \]
</p>
<p> and inserting the expression for \(\phi_{j}\): </p><p class="formulaDsp">
\[ f_i(c^{\prime}_{jk}b_{kl}p_{l}) = c^{\prime}_{jk} b_{kl} f_i \left( p_{l} \right) \]
</p>
<p>Defining a matrix D given by applying the functionals to each polynomial \(p_j\): </p><p class="formulaDsp">
\[ [D] = d_{ij},\mbox{ where } d_{ij} = f_i(p_j), \]
</p>
<p> we have: </p><p class="formulaDsp">
\[ C^{\prime} B D^{T} = I \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ C^{\prime} = (B D^{T})^{-1}. \]
</p>
<p>Recalling that \(C = C^{\prime} B\), where \(C\) is the matrix form of \(c_{ij}\),</p>
<p class="formulaDsp">
\[ C = (B D^{T})^{-1} B \]
</p>
<p>This function takes the matrices \(B\) (<code>wcoeffs</code>) and \(D\) (<code>M</code>) as inputs and will internally compute \(C\).</p>
<p>The matrix \(BD^{T}\) can be obtained from an element by using the function <code><a class="el" href="classbasix_1_1FiniteElement.html#a5c56bfac8f3a1e05fcc15e354868a3ae">dual_matrix()</a></code>. The matrix \(C\) can be obtained from an element by using the function <code><a class="el" href="classbasix_1_1FiniteElement.html#a89171fc632b3408643faa22bf04b835f">coefficient_matrix()</a></code>.</p>
<h2>Example: Order 1 Lagrange elements on a triangle </h2>
<p>On a triangle, the scalar expansion basis is: </p><p class="formulaDsp">
\[ p_0 = \sqrt{2}/2 \qquad p_1 = \sqrt{3}(2x + y - 1) \qquad p_2 = 3y - 1 \]
</p>
<p> These span the space \(P_1\).</p>
<p>Lagrange order 1 elements span the space P_1, so in this example, B (span_coeffs) is the identity matrix: </p><p class="formulaDsp">
\[ B = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>The functionals defining the Lagrange order 1 space are point evaluations at the three vertices of the triangle. The matrix D (dual) given by applying these to p_0 to p_2 is: </p><p class="formulaDsp">
\[ \mbox{dual} = \begin{bmatrix} \sqrt{2}/2 &amp; -\sqrt{3} &amp; -1 \\ \sqrt{2}/2 &amp; \sqrt{3} &amp; -1 \\ \sqrt{2}/2 &amp; 0 &amp; 2 \end{bmatrix} \]
</p>
<p>For this example, this function outputs the matrix: </p><p class="formulaDsp">
\[ C = \begin{bmatrix} \sqrt{2}/3 &amp; -\sqrt{3}/6 &amp; -1/6 \\ \sqrt{2}/3 &amp; \sqrt{3}/6 &amp; -1/6 \\ \sqrt{2}/3 &amp; 0 &amp; 1/3 \end{bmatrix} \]
</p>
<p> The basis functions of the finite element can be obtained by applying the matrix C to the vector \([p_0, p_1, p_2]\), giving: </p><p class="formulaDsp">
\[ \begin{bmatrix} 1 - x - y \\ x \\ y \end{bmatrix} \]
</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>On a triangle, the 2D vector expansion basis is: </p><p class="formulaDsp">
\[ \begin{matrix} p_0 &amp; = &amp; (\sqrt{2}/2, 0) \\ p_1 &amp; = &amp; (\sqrt{3}(2x + y - 1), 0) \\ p_2 &amp; = &amp; (3y - 1, 0) \\ p_3 &amp; = &amp; (0, \sqrt{2}/2) \\ p_4 &amp; = &amp; (0, \sqrt{3}(2x + y - 1)) \\ p_5 &amp; = &amp; (0, 3y - 1) \end{matrix} \]
</p>
<p> These span the space \( P_1^2 \).</p>
<p>Raviart-Thomas order 1 elements span a space smaller than \( P_1^2 \), so B (span_coeffs) is not the identity. It is given by: </p><p class="formulaDsp">
\[ B = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 1/12 &amp; \sqrt{6}/48 &amp; -\sqrt{2}/48 &amp; 1/12 &amp; 0 &amp; \sqrt{2}/24 \end{bmatrix} \]
</p>
<p> Applying the matrix B to the vector \([p_0, p_1, ..., p_5]\) gives the basis of the polynomial space for Raviart-Thomas: </p><p class="formulaDsp">
\[ \begin{bmatrix} \sqrt{2}/2 &amp; 0 \\ 0 &amp; \sqrt{2}/2 \\ \sqrt{2}x/8 &amp; \sqrt{2}y/8 \end{bmatrix} \]
</p>
<p>The functionals defining the Raviart-Thomas order 1 space are integral of the normal components along each edge. The matrix D (dual) given by applying these to \(p_0\) to \(p_5\) is: </p><p class="formulaDsp">
\[ D = \begin{bmatrix} -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 &amp; -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 \\ -\sqrt{2}/2 &amp; \sqrt{3}/2 &amp; -1/2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \sqrt{2}/2 &amp; 0 &amp; -1 \end{bmatrix} \]
</p>
<p>In this example, this function outputs the matrix: </p><p class="formulaDsp">
\[ C = \begin{bmatrix} -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 &amp; -\sqrt{2}/2 &amp; -\sqrt{3}/2 &amp; -1/2 \\ -\sqrt{2}/2 &amp; \sqrt{3}/2 &amp; -1/2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \sqrt{2}/2 &amp; 0 &amp; -1 \end{bmatrix} \]
</p>
<p> The basis functions of the finite element can be obtained by applying the matrix C to the vector \([p_0, p_1, ..., p_5]\), giving: </p><p class="formulaDsp">
\[ \begin{bmatrix} -x &amp; -y \\ x - 1 &amp; y \\ -x &amp; 1 - y \end{bmatrix} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>The element family </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>The degree of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolation_nderivs</td><td>The number of derivatives that need to be used during interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td>The value shape of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wcoeffs</td><td>Matrices for the kth value index containing the expansion coefficients defining a polynomial basis spanning the polynomial space for this element. Shape is (dim(finite element polyset), dim(Legendre polynomials)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation points. Indices are (tdim, entity index, point index, dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The interpolation matrices. Indices are (tdim, entity index, dof, vs, point_index, derivative) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_type</td><td>The type of map to be used to map values from the reference to a cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sobolev_space</td><td>The underlying Sobolev space for the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discontinuous</td><td>Indicates whether or not this is the discontinuous version of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">highest_complete_degree</td><td>The highest degree n such that a Lagrange (or vector Lagrange) element of degree n is a subspace of this element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">highest_degree</td><td>The highest degree n such that at least one polynomial of degree n is included in this element's polymonial set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lvariant</td><td>The Lagrange variant of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dvariant</td><td>The DPC variant of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor_factors</td><td>The factors in the tensor product representation of this element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_ordering</td><td>DOF reordering: a mapping from the reference order to a new permuted order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5ff134bf4cb89bf2065468d2dafc815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ff134bf4cb89bf2065468d2dafc815">&#9670;&nbsp;</a></span>apply_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fa761bd48f858048da5494a54c3c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa761bd48f858048da5494a54c3c394">&#9670;&nbsp;</a></span>apply_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb75e2f0034bf656eeb75dfc9319ddf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb75e2f0034bf656eeb75dfc9319ddf6">&#9670;&nbsp;</a></span>apply_inverse_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafab6ed2a4557848808ead1082e1cbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafab6ed2a4557848808ead1082e1cbc9">&#9670;&nbsp;</a></span>apply_inverse_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd239adb249fe4e3b34615baa80dd769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd239adb249fe4e3b34615baa80dd769">&#9670;&nbsp;</a></span>apply_inverse_transpose_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_transpose_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse transpose DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2c9ba514d73732418677ea44040f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c9ba514d73732418677ea44040f19b">&#9670;&nbsp;</a></span>apply_inverse_transpose_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_transpose_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply inverse transpose DOF transformations to some transposed data. </p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84eb716f9fa348dc5a1cd5fbc31f6cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eb716f9fa348dc5a1cd5fbc31f6cac">&#9670;&nbsp;</a></span>apply_transpose_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_transpose_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose DOF transformations to some data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9cb7ea73d280d5c7f25e302e9695f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cb7ea73d280d5c7f25e302e9695f33">&#9670;&nbsp;</a></span>apply_transpose_dof_transformation_to_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_transpose_dof_transformation_to_transpose </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose DOF transformations to some transposed data</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae13dc5c1e4e0980929e5a1d6c06aa6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13dc5c1e4e0980929e5a1d6c06aa6fc">&#9670;&nbsp;</a></span>base_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::base_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the base transformations. </p>
<p>The base transformations represent the effect of rotating or reflecting a subentity of the cell on the numbering and orientation of the DOFs. This returns a list of matrices with one matrix for each subentity permutation in the following order: Reversing edge 0, reversing edge 1, ... Rotate face 0, reflect face 0, rotate face 1, reflect face 1, ...</p>
<h2>Example: Order 3 Lagrange on a triangle </h2>
<p>This space has 10 dofs arranged like: </p><div class="fragment"><div class="line">2</div>
<div class="line">|\</div>
<div class="line">6 4</div>
<div class="line">|  \</div>
<div class="line">5 9 3</div>
<div class="line">|    \</div>
<div class="line">0-7-8-1</div>
</div><!-- fragment --><p> For this element, the base transformations are: [Matrix swapping 3 and 4, Matrix swapping 5 and 6, Matrix swapping 7 and 8] The first row shows the effect of reversing the diagonal edge. The second row shows the effect of reversing the vertical edge. The third row shows the effect of reversing the horizontal edge.</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>This space has 3 dofs arranged like: </p><div class="fragment"><div class="line">  |\</div>
<div class="line">  | \</div>
<div class="line">  |  \</div>
<div class="line">&lt;-1   0</div>
<div class="line">  |  / \</div>
<div class="line">  | L ^ \</div>
<div class="line">  |   |  \</div>
<div class="line">   ---2---</div>
</div><!-- fragment --><p> These DOFs are integrals of normal components over the edges: DOFs 0 and 2 are oriented inward, DOF 1 is oriented outwards. For this element, the base transformation matrices are: </p><div class="fragment"><div class="line">0: [[-1, 0, 0],</div>
<div class="line">    [ 0, 1, 0],</div>
<div class="line">    [ 0, 0, 1]]</div>
<div class="line">1: [[1,  0, 0],</div>
<div class="line">    [0, -1, 0],</div>
<div class="line">    [0,  0, 1]]</div>
<div class="line">2: [[1, 0,  0],</div>
<div class="line">    [0, 1,  0],</div>
<div class="line">    [0, 0, -1]]</div>
</div><!-- fragment --><p> The first matrix reverses DOF 0 (as this is on the first edge). The second matrix reverses DOF 1 (as this is on the second edge). The third matrix reverses DOF 2 (as this is on the third edge).</p>
<h2>Example: DOFs on the face of Order 2 Nedelec first kind on a tetrahedron </h2>
<p>On a face of this tetrahedron, this space has two face tangent DOFs: </p><div class="fragment"><div class="line">|\        |\</div>
<div class="line">| \       | \</div>
<div class="line">|  \      | ^\</div>
<div class="line">|   \     | | \</div>
<div class="line">| 0-&gt;\    | 1  \</div>
<div class="line">|     \   |     \</div>
<div class="line"> ------    ------</div>
</div><!-- fragment --><p> For these DOFs, the subblocks of the base transformation matrices are: </p><div class="fragment"><div class="line">rotation: [[-1, 1],</div>
<div class="line">           [ 1, 0]]</div>
<div class="line">reflection: [[0, 1],</div>
<div class="line">             [1, 0]]</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>The base transformations for this element. The shape is (ntranformations, ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="a07e3921459dce5bff1cb731d1713ccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e3921459dce5bff1cb731d1713ccc2">&#9670;&nbsp;</a></span>cell_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> FiniteElement::cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element cell type </p><dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
<a id="a89171fc632b3408643faa22bf04b835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89171fc632b3408643faa22bf04b835f">&#9670;&nbsp;</a></span>coefficient_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp; FiniteElement::coefficient_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the matrix of coefficients.</p>
<p>This is the matrix \(C\), as described in the documentation of the <code><a class="el" href="classbasix_1_1FiniteElement.html#a263e785dd3d083af75a6b07bfd87dd00" title="Construct a finite element.">FiniteElement()</a></code> constructor. </p><dl class="section return"><dt>Returns</dt><dd>The coefficient matrix. Shape is (ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="a6c9361216564eb22d899f1e961803392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9361216564eb22d899f1e961803392">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element polynomial degree </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a99d38980ecdf3be924a093b4d2319479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d38980ecdf3be924a093b4d2319479">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimension of the finite element space (number of degrees-of-freedom for the element) </p><dl class="section return"><dt>Returns</dt><dd>Number of degrees of freedom </dd></dl>

</div>
</div>
<a id="aebfcc4fdf0ecb92a2ec4f315d221de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfcc4fdf0ecb92a2ec4f315d221de51">&#9670;&nbsp;</a></span>discontinuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::discontinuous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this element is the discontinuous variant </p><dl class="section return"><dt>Returns</dt><dd>True if this element is a discontinuous version of the element </dd></dl>

</div>
</div>
<a id="ac5b7c1db36efbc036b8831e9c0ef7f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b7c1db36efbc036b8831e9c0ef7f1a">&#9670;&nbsp;</a></span>dof_transformations_are_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all the identity </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="a46dd5cfd393b08ca5e619c20c63c6ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dd5cfd393b08ca5e619c20c63c6ce5">&#9670;&nbsp;</a></span>dof_transformations_are_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_permutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all permutations </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="aa06a0c9f071d90d6ea452f9afe7c109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06a0c9f071d90d6ea452f9afe7c109d">&#9670;&nbsp;</a></span>dpc_variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#a8e196cd0bcdc926110b57d13fa278060">element::dpc_variant</a> FiniteElement::dpc_variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the DPC variant of the element. </p><dl class="section return"><dt>Returns</dt><dd>The DPC variant </dd></dl>

</div>
</div>
<a id="a5c56bfac8f3a1e05fcc15e354868a3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c56bfac8f3a1e05fcc15e354868a3ae">&#9670;&nbsp;</a></span>dual_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp; FiniteElement::dual_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dual matrix.</p>
<p>This is the matrix \(BD^{T}\), as described in the documentation of the <code><a class="el" href="classbasix_1_1FiniteElement.html#a263e785dd3d083af75a6b07bfd87dd00" title="Construct a finite element.">FiniteElement()</a></code> constructor. </p><dl class="section return"><dt>Returns</dt><dd>The dual matrix. Shape is (ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="a69d5b83865b234bc08f3675a5a6ccb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d5b83865b234bc08f3675a5a6ccb0d">&#9670;&nbsp;</a></span>entity_closure_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp; FiniteElement::entity_closure_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dofs on the closure of each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[1, 2, 3], [0, 2, 4], [0, 1, 5]], cell: [[0, 1, 2, 3, 4, 5]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with the closure of an entity of a given topological dimension. The shape is (tdim + 1, num_entities, num_dofs). </dd></dl>

</div>
</div>
<a id="a572bc37d493eb6a9f2183b76f14cec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572bc37d493eb6a9f2183b76f14cec20">&#9670;&nbsp;</a></span>entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp; FiniteElement::entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dofs on each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [[0], [1], [2]], edges: [[3], [4], [5]], cell: [[]] </p><dl class="section return"><dt>Returns</dt><dd>Dofs associated with an entity of a given topological dimension. The shape is (tdim + 1, num_entities, num_dofs). </dd></dl>

</div>
</div>
<a id="a056bdf81657a17a2de95947b9ad12a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056bdf81657a17a2de95947b9ad12a36">&#9670;&nbsp;</a></span>entity_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>, std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt; &gt; FiniteElement::entity_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the entity dof transformation matrices </p><dl class="section return"><dt>Returns</dt><dd>The entity transformations for the sub-entities of this element. The shape for each cell is (ntransformations, ndofs, ndofs) </dd></dl>

</div>
</div>
<a id="aafaa8df68d126f872c9d028a52709aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaa8df68d126f872c9d028a52709aaf">&#9670;&nbsp;</a></span>family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#ada0a7daa08f1923682c927786b8ee007">element::family</a> FiniteElement::family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the finite element family </p><dl class="section return"><dt>Returns</dt><dd>The family </dd></dl>

</div>
</div>
<a id="a55b1344636dc8d83c5ca71a9682174c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1344636dc8d83c5ca71a9682174c2">&#9670;&nbsp;</a></span>get_tensor_product_representation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; std::vector&lt; <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &gt;, std::vector&lt; int &gt; &gt; &gt; FiniteElement::get_tensor_product_representation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tensor product representation of this element, or throw an error if no such factorisation exists.</p>
<p>The tensor product representation will be a vector of tuples. Each tuple contains a vector of finite elements, and a vector of integers. The vector of finite elements gives the elements on an interval that appear in the tensor product representation. The vector of integers gives the permutation between the numbering of the tensor product DOFs and the number of the DOFs of this Basix element. </p><dl class="section return"><dt>Returns</dt><dd>The tensor product representation </dd></dl>

</div>
</div>
<a id="a8b653fd5ef231b610abae7fabe96d2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b653fd5ef231b610abae7fabe96d2d4">&#9670;&nbsp;</a></span>has_tensor_product_factorisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::has_tensor_product_factorisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not this element can be represented as a product of elements defined on lower-dimensional reference cells. If the product exists, this element's basis functions can be computed as a tensor product of the basis elements of the elements in the product.</p>
<p>If such a factorisation exists, <code><a class="el" href="classbasix_1_1FiniteElement.html#a55b1344636dc8d83c5ca71a9682174c2">get_tensor_product_representation()</a></code> can be used to get these elements. </p>

</div>
</div>
<a id="a1ec5b8fe7b275dc4ddf373974757a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec5b8fe7b275dc4ddf373974757a8de">&#9670;&nbsp;</a></span>highest_complete_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::highest_complete_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest degree <code>n</code> such that a Lagrange (or vector Lagrange) element of degree n is a subspace of this element. </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a9ce5bdcac7c0acaafe9dcf45c74f1301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce5bdcac7c0acaafe9dcf45c74f1301">&#9670;&nbsp;</a></span>highest_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::highest_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowest degree <code>n</code> such that the highest degree polynomial in this element is contained in a Lagrange (or vector Lagrange) element of degree <code>n</code>. </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="adacde51327c7da17f2da16f3ace3f3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacde51327c7da17f2da16f3ace3f3a2">&#9670;&nbsp;</a></span>interpolation_is_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::interpolation_is_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not the interpolation matrix for this element is an identity matrix </p>

</div>
</div>
<a id="ad7a9930d71935bcf4b559a433d53e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a9930d71935bcf4b559a433d53e2d0">&#9670;&nbsp;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp; FiniteElement::interpolation_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a matrix of weights interpolation,. </p>
<p>To interpolate a function in this finite element, the functions should be evaluated at each point given by <a class="el" href="classbasix_1_1FiniteElement.html#a6b6193aeef301ffaf1da69dea0b0f214">FiniteElement::points()</a>. These function values should then be multiplied by the weight matrix to give the coefficients of the interpolated function.</p>
<p>The shape of the returned matrix will be <code>(dim, num_points * value_size)</code>, where <code>dim</code> is the number of DOFs in the finite element, <code>num_points</code> is the number of points returned by <code><a class="el" href="classbasix_1_1FiniteElement.html#a6b6193aeef301ffaf1da69dea0b0f214">points()</a></code>, and <code>value_size</code> is the value size of the finite element.</p>
<p>For example, to interpolate into a Lagrange space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">values = vector(pts.shape(0))</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Raviart-Thomas space, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">vs = prod(element.value_shape())</div>
<div class="line">values = VECTOR(pts.shape(0) * vs)</div>
<div class="line">FOR i, p IN ENUMERATE(pts):</div>
<div class="line">    values[i::pts.shape(0)] = f.evaluate_at(p)</div>
<div class="line">coefficients = i_m * values</div>
</div><!-- fragment --><p>To interpolate into a Lagrange space with a block size, the following should be done: </p><div class="fragment"><div class="line">i_m = element.interpolation_matrix()</div>
<div class="line">pts = element.points()</div>
<div class="line">coefficients = VECTOR(element.dim() * block_size)</div>
<div class="line">FOR b IN RANGE(block_size):</div>
<div class="line">    values = vector(pts.shape(0))</div>
<div class="line">    FOR i, p IN ENUMERATE(pts):</div>
<div class="line">        values[i] = f.evaluate_at(p)[b]</div>
<div class="line">    coefficients[::block_size] = i_m * values</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The interpolation matrix. Shape is (ndofs, number of interpolation points) </dd></dl>

</div>
</div>
<a id="a277701eea33cb029f3b0b3b3be2b4de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277701eea33cb029f3b0b3b3be2b4de2">&#9670;&nbsp;</a></span>lagrange_variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1element.html#a5d97cf44f3a72fad549a01ab3933b77f">element::lagrange_variant</a> FiniteElement::lagrange_variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Lagrange variant of the element. </p><dl class="section return"><dt>Returns</dt><dd>The Lagrange variant </dd></dl>

</div>
</div>
<a id="ae48dbe8218a020276179532c55a65f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48dbe8218a020276179532c55a65f5c">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt; &gt;, 4 &gt; &amp; FiniteElement::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the interpolation matrices for each subentity.</p>
<p>The shape of this data is (tdim, entity index, dof, value size, point_index, derivative).</p>
<p>These matrices define how to evaluate the DOF functionals associated with each sub-entity of the cell. Given a function f, the functionals associated with the <code>e</code>-th entity of dimension <code>d</code> can be computed as follows:</p>
<div class="fragment"><div class="line">matrix = element.M()[d][e]</div>
<div class="line">pts = element.x()[d][e]</div>
<div class="line">nderivs = element</div>
<div class="line">values = f.eval_derivs(nderivs, pts)</div>
<div class="line">result = ZEROS(matrix.shape(0))</div>
<div class="line">FOR i IN RANGE(matrix.shape(0)):</div>
<div class="line">    FOR j IN RANGE(matrix.shape(1)):</div>
<div class="line">        FOR k IN RANGE(matrix.shape(2)):</div>
<div class="line">            FOR l IN RANGE(matrix.shape(3)):</div>
<div class="line">                result[i] += matrix[i, j, k, l] * values[l][k][j]</div>
</div><!-- fragment --><p>For example, for a degree 1 Raviart-Thomas (RT) element on a triangle, the DOF functionals are integrals over the edges of the dot product of the function with the normal to the edge. In this case, <code><a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x()</a></code> would contain quadrature points for each edge, and <code><a class="el" href="classbasix_1_1FiniteElement.html#ae48dbe8218a020276179532c55a65f5c">M()</a></code> would by a 1 by 2 by <code>npoints</code> by 1 array for each edge. For each point, the <code>[0, :, point, 0]</code> slice of this would be the quadrature weight multiplied by the normal. For all entities that are not edges, the entries in <code><a class="el" href="classbasix_1_1FiniteElement.html#a3962070c7d180f128d5814f25bedc12c">x()</a></code> and <code><a class="el" href="classbasix_1_1FiniteElement.html#ae48dbe8218a020276179532c55a65f5c">M()</a></code> for a degree 1 RT element would have size 0.</p>
<p>These matrices are only stored for custom elements. This function will throw an exception if called on a non-custom element </p><dl class="section return"><dt>Returns</dt><dd>The interpolation matrices. The indices of this data are (tdim, entity index, dof, vs, point_index, derivative) </dd></dl>

</div>
</div>
<a id="a6f7cb986a2f58c91579b8f4f7b7f7aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7cb986a2f58c91579b8f4f7b7f7aa7">&#9670;&nbsp;</a></span>map_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename P , typename Q , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(O&amp;, const P&amp;, const Q&amp;, double, const R&amp;)&gt; basix::FiniteElement::map_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a function that performs the appropriate push-forward/pull-back for the element type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>The type that hold the (computed) mapped data (ndim==2) </td></tr>
    <tr><td class="paramname">P</td><td>The type that hold the data to be mapped (ndim==2) </td></tr>
    <tr><td class="paramname">Q</td><td>The type that holds the Jacobian (or inverse) matrix (ndim==2) </td></tr>
    <tr><td class="paramname">R</td><td>The type that holds the inverse of the <code>Q</code> data (ndim==2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that for a push-forward takes arguments<ul>
<li><code>u</code> [out] The data on the physical cell after the push-forward flattened with row-major layout, shape=(num_points, value_size)</li>
<li><code>U</code> [in] The data on the reference cell physical field to push forward, flattened with row-major layout, shape=(num_points, ref_value_size)</li>
<li><code>J</code> [in] The Jacobian matrix of the map ,shape=(gdim, tdim)</li>
<li><code>detJ</code> [in] det(J)</li>
<li><code>K</code> [in] The inverse of the Jacobian matrix, shape=(tdim, gdim)</li>
</ul>
</dd></dl>
<p>For a pull-back the arguments should be:</p><ul>
<li><code>U</code> [out] The data on the reference cell after the pull-back, flattened with row-major layout, shape=(num_points, ref value_size)</li>
<li><code>u</code> [in] The data on the physical cell that should be pulled back , flattened with row-major layout, shape=(num_points, value_size)</li>
<li><code>K</code> [in] The inverse of the Jacobian matrix of the map ,shape=(tdim, gdim)</li>
<li><code>detJ_inv</code> [in] 1/det(J)</li>
<li><code>J</code> [in] The Jacobian matrix, shape=(gdim, tdim) </li>
</ul>

</div>
</div>
<a id="a4718b4f0231b8287288ca7fb28588977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4718b4f0231b8287288ca7fb28588977">&#9670;&nbsp;</a></span>map_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> FiniteElement::map_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the map type for this element </p><dl class="section return"><dt>Returns</dt><dd>The map type </dd></dl>

</div>
</div>
<a id="a369c8049d19ca40e09189498feeee720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c8049d19ca40e09189498feeee720">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two elements are the same </p><dl class="section note"><dt>Note</dt><dd>This operator compares the element properties, e.g. family, degree, etc, and not computed numerical data </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if elements are the same </dd></dl>

</div>
</div>
<a id="ab4a741f90888d4c9477ee8b7e2754513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a741f90888d4c9477ee8b7e2754513">&#9670;&nbsp;</a></span>permute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::permute_dofs </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permute the dof numbering on a cell</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6193aeef301ffaf1da69dea0b0f214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6193aeef301ffaf1da69dea0b0f214">&#9670;&nbsp;</a></span>points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp; FiniteElement::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interpolation points, i.e. the coordinates on the reference element where a function need to be evaluated in order to interpolate it in the finite element space. </p><dl class="section return"><dt>Returns</dt><dd>Array of coordinate with shape <code>(num_points, tdim)</code> </dd></dl>

</div>
</div>
<a id="acba1339b521932d8872a74716d19f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba1339b521932d8872a74716d19f6e6">&#9670;&nbsp;</a></span>pull_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::pull_back </td>
          <td>(</td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The function values on the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the reference. The indices are [Jacobian index, point index, components]. </dd></dl>

</div>
</div>
<a id="a9f00687e930074dc5fa0b68c95f2fa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f00687e930074dc5fa0b68c95f2fa64">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 3 &gt; &gt; FiniteElement::push_forward </td>
          <td>(</td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan3_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from the reference to a physical cell. This function can perform the mapping for multiple points, grouped by points that share a common Jacobian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>The function values on the reference. The indices are [Jacobian index, point index, components]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>The Jacobian of the mapping. The indices are [Jacobian index, J_i, J_j]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping. It has length <code>J.shape(0)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping. The indices are [Jacobian index, K_i, K_j]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the cell. The indices are [Jacobian index, point index, components]. </dd></dl>

</div>
</div>
<a id="a126fcc52ed6994188309a0f0b94ae30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126fcc52ed6994188309a0f0b94ae30a">&#9670;&nbsp;</a></span>sobolev_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1sobolev.html#a80a5ebc47ba8d0dd2ecab4fbd43087bc">sobolev::space</a> FiniteElement::sobolev_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the underlying Sobolev space for this element </p><dl class="section return"><dt>Returns</dt><dd>The Sobolev space </dd></dl>

</div>
</div>
<a id="a63d719bc02bb7d0ac200298268cba0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d719bc02bb7d0ac200298268cba0a3">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="section note"><dt>Note</dt><dd>The version of <code><a class="el" href="classbasix_1_1FiniteElement.html#a0618f0de76f2eab3a8f897a083b0a85d" title="Compute basis values and derivatives at set of points.">FiniteElement::tabulate</a></code> with the basis data as an out argument should be preferred for repeated call where performance is critical</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions (row-major storage). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape <code>(number of points, geometric dimension)</code> of the <code>x</code> array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1d90fa4352ce7b29dc0e5dd3dcd7fd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d90fa4352ce7b29dc0e5dd3dcd7fd38">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>xshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions (row-major storage). The shape of x is (number of points, geometric dimension). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>The shape <code>(number of points, geometric dimension)</code> of <code>x</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basis</td><td>Memory location to fill. It must be allocated with shape (num_derivatives, num_points, num basis functions, value_size). The function <code><a class="el" href="classbasix_1_1FiniteElement.html#a9f0074afdb7c640258fc6df3947c9c48">FiniteElement::tabulate_shape</a></code> can be used to get the required shape.<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0618f0de76f2eab3a8f897a083b0a85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0618f0de76f2eab3a8f897a083b0a85d">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 4 &gt; &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan2_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis values and derivatives at set of points. </p>
<dl class="section note"><dt>Note</dt><dd>The version of <code><a class="el" href="classbasix_1_1FiniteElement.html#a0618f0de76f2eab3a8f897a083b0a85d" title="Compute basis values and derivatives at set of points.">FiniteElement::tabulate</a></code> with the basis data as an out argument should be preferred for repeated call where performance is critical</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2efc4683d0f9604b7a4b7fbf5bf08ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efc4683d0f9604b7a4b7fbf5bf08ba3">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::cmdspan2_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::mdspan4_t&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basis</td><td>Memory location to fill. It must be allocated with shape (num_derivatives, num_points, num basis functions, value_size). The function <code><a class="el" href="classbasix_1_1FiniteElement.html#a9f0074afdb7c640258fc6df3947c9c48">FiniteElement::tabulate_shape</a></code> can be used to get the required shape.<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, ie for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix_1_1indexing.html#aee955bbd20bb422bca33e4654b7d7e46">basix::indexing::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Remove all internal dynamic memory allocation, pass scratch space as required </dd></dl>

</div>
</div>
<a id="a9f0074afdb7c640258fc6df3947c9c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0074afdb7c640258fc6df3947c9c48">&#9670;&nbsp;</a></span>tabulate_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::size_t, 4 &gt; FiniteElement::tabulate_shape </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Array shape for tabulate basis values and derivatives at set of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_points</td><td>Number of points that basis will be computed at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the array to will filled when passed to <code><a class="el" href="classbasix_1_1FiniteElement.html#a0618f0de76f2eab3a8f897a083b0a85d" title="Compute basis values and derivatives at set of points.">FiniteElement::tabulate</a></code> </dd></dl>

</div>
</div>
<a id="af627afd9aeee8237cf7552b4652c437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af627afd9aeee8237cf7552b4652c437a">&#9670;&nbsp;</a></span>unpermute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::unpermute_dofs </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpermute the dof numbering on a cell</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be called at runtime, so its performance is critical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a879496da4405a7273ba8045b1299f66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879496da4405a7273ba8045b1299f66b">&#9670;&nbsp;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::size_t &gt; &amp; FiniteElement::value_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The element value tensor shape, e.g. returning {} for scalars, {3} for vectors in 3D, {2, 2} for a rank-2 tensor in 2D. </p><dl class="section return"><dt>Returns</dt><dd>Value shape </dd></dl>

</div>
</div>
<a id="a9295f480358ceb856cf9e61b045b751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9295f480358ceb856cf9e61b045b751c">&#9670;&nbsp;</a></span>wcoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &amp; FiniteElement::wcoeffs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the coefficients that define the polynomial set in terms of the orthonormal polynomials.</p>
<p>The polynomials spanned by each finite element in Basix are represented as a linear combination of the orthonormal polynomials of a given degree on the cell. Each row of this matrix defines a polynomial in the set spanned by the finite element.</p>
<p>For example, the orthonormal polynomials of degree &lt;= 1 on a triangle are (where a, b, c, d are some constants):</p>
<ul>
<li>(sqrt(2), 0)</li>
<li>(a*x - b, 0)</li>
<li>(c*y - d, 0)</li>
<li>(0, sqrt(2))</li>
<li>(0, a*x - b)</li>
<li>(0, c*y - d)</li>
</ul>
<p>For a degree 1 Raviart-Thomas element, the first two rows of wcoeffs would be the following, as (1, 0) and (0, 1) are spanned by the element</p>
<ul>
<li>[1, 0, 0, 0, 0, 0]</li>
<li>[0, 0, 0, 1, 0, 0]</li>
</ul>
<p>The third row of wcoeffs in this example would give coefficients that represent (x, y) in terms of the orthonormal polynomials:</p>
<ul>
<li>[-b/(a*sqrt(2)), 1/a, 0, -d/(c*sqrt(2)), 0, 1/c]</li>
</ul>
<p>These coefficients are only stored for custom elements. This function will throw an exception if called on a non-custom element </p><dl class="section return"><dt>Returns</dt><dd>Coefficient matrix. Shape is (dim(finite element polyset), dim(Lagrange polynomials)) </dd></dl>

</div>
</div>
<a id="a3962070c7d180f128d5814f25bedc12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3962070c7d180f128d5814f25bedc12c">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::vector&lt; std::pair&lt; std::vector&lt; double &gt;, std::array&lt; std::size_t, 2 &gt; &gt; &gt;, 4 &gt; &amp; FiniteElement::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the interpolation points for each subentity.</p>
<p>The indices of this data are (tdim, entity index, point index, dim). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/basix/basix/cpp/basix/<a class="el" href="finite-element_8h_source.html">finite-element.h</a></li>
<li>/home/runner/work/basix/basix/cpp/basix/finite-element.cpp</li>
</ul>
</div><!-- contents -->

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    &copy; FEniCS Project 2021. Changes to this website can be made/suggested on <a href='https://github.com/FEniCS/web'>GitHub</a>.
  </footer>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tabulation Project basix: basix::FiniteElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tabulation Project basix
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbasix_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basix::FiniteElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="finite-element_8h_source.html">finite-element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a923357c54d17c89a66f85e887f01ce6c"><td class="memItemLeft" align="right" valign="top"><a id="a923357c54d17c89a66f85e887f01ce6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a923357c54d17c89a66f85e887f01ce6c">FiniteElement</a> (element::family <a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a>, <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a>, const std::vector&lt; int &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a>, const Eigen::ArrayXXd &amp;coeffs, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a9501349952715cda61dd48c0e2395ffb">entity_dofs</a>, const std::vector&lt; Eigen::MatrixXd &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#af76e81b3893b14939790c6aacb6ec7d4">base_permutations</a>, const Eigen::ArrayXXd &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a100a9e7b1c3eb7dab992696877c7889f">points</a>, const Eigen::MatrixXd <a class="el" href="classbasix_1_1FiniteElement.html#ab9c13633143b8d607459e42e9d69d43a">interpolation_matrix</a>={}, <a class="el" href="namespacebasix_1_1mapping.html#a2426bf33626776d9ca2efe0b60438f9b">mapping::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a25c73e9e3bbcbd310035ae2acb8c25e7">mapping_type</a>=mapping::type::identity)</td></tr>
<tr class="memdesc:a923357c54d17c89a66f85e887f01ce6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A finite element. <br /></td></tr>
<tr class="separator:a923357c54d17c89a66f85e887f01ce6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memItemLeft" align="right" valign="top"><a id="ad6d31f4039d140b08a88e8cc6d33d06a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad6d31f4039d140b08a88e8cc6d33d06a">FiniteElement</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d657b79583dd417c18232057aafda98"><td class="memItemLeft" align="right" valign="top"><a id="a2d657b79583dd417c18232057aafda98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2d657b79583dd417c18232057aafda98">FiniteElement</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a2d657b79583dd417c18232057aafda98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2d657b79583dd417c18232057aafda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22cdbee8b090eaee4a441772c94a24"><td class="memItemLeft" align="right" valign="top"><a id="a8d22cdbee8b090eaee4a441772c94a24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8d22cdbee8b090eaee4a441772c94a24">~FiniteElement</a> ()=default</td></tr>
<tr class="memdesc:a8d22cdbee8b090eaee4a441772c94a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d22cdbee8b090eaee4a441772c94a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012641ff0a6abe1bda2e9493615c22fc"><td class="memItemLeft" align="right" valign="top"><a id="a012641ff0a6abe1bda2e9493615c22fc"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a012641ff0a6abe1bda2e9493615c22fc">operator=</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a012641ff0a6abe1bda2e9493615c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a012641ff0a6abe1bda2e9493615c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2bef969b9481371fa06f701009794"><td class="memItemLeft" align="right" valign="top"><a id="a0cd2bef969b9481371fa06f701009794"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cd2bef969b9481371fa06f701009794">operator=</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a0cd2bef969b9481371fa06f701009794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a0cd2bef969b9481371fa06f701009794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9142c0e8f4dc91456387344313e1354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae9142c0e8f4dc91456387344313e1354">tabulate</a> (int nd, const Eigen::ArrayXXd &amp;x) const</td></tr>
<tr class="separator:ae9142c0e8f4dc91456387344313e1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0effbf7ea7c51051666c3b7fcb725bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae0effbf7ea7c51051666c3b7fcb725bf">tabulate_to_memory</a> (int nd, const Eigen::ArrayXXd &amp;x, double *basis_data) const</td></tr>
<tr class="separator:ae0effbf7ea7c51051666c3b7fcb725bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e3921459dce5bff1cb731d1713ccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a> () const</td></tr>
<tr class="separator:a07e3921459dce5bff1cb731d1713ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9361216564eb22d899f1e961803392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a> () const</td></tr>
<tr class="separator:a6c9361216564eb22d899f1e961803392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2b0d7ce9c73d76c18f2cc1de08a59cb9">value_size</a> () const</td></tr>
<tr class="separator:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82325b132e0b989ee51338b7727ce38f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a> () const</td></tr>
<tr class="separator:a82325b132e0b989ee51338b7727ce38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d38980ecdf3be924a093b4d2319479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">dim</a> () const</td></tr>
<tr class="separator:a99d38980ecdf3be924a093b4d2319479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaa8df68d126f872c9d028a52709aaf"><td class="memItemLeft" align="right" valign="top">element::family&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a> () const</td></tr>
<tr class="separator:aafaa8df68d126f872c9d028a52709aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c73e9e3bbcbd310035ae2acb8c25e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacebasix_1_1mapping.html#a2426bf33626776d9ca2efe0b60438f9b">mapping::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a25c73e9e3bbcbd310035ae2acb8c25e7">mapping_type</a> () const</td></tr>
<tr class="separator:a25c73e9e3bbcbd310035ae2acb8c25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215a6a18895a1e370e3eb2046dae0166"><td class="memItemLeft" align="right" valign="top">Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a215a6a18895a1e370e3eb2046dae0166">map_push_forward</a> (const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;reference_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K) const</td></tr>
<tr class="separator:a215a6a18895a1e370e3eb2046dae0166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb99c18e9d023e29f996120cff23b2b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#acb99c18e9d023e29f996120cff23b2b0">map_push_forward_to_memory_real</a> (const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;reference_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K, double *physical_data) const</td></tr>
<tr class="separator:acb99c18e9d023e29f996120cff23b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79f25ceadbddfa0655f231e3667c61e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac79f25ceadbddfa0655f231e3667c61e">map_push_forward_to_memory_complex</a> (const Eigen::Array&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;reference_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K, std::complex&lt; double &gt; *physical_data) const</td></tr>
<tr class="separator:ac79f25ceadbddfa0655f231e3667c61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad679a63ad8abb3d99e98e665dd77053b"><td class="memItemLeft" align="right" valign="top">Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad679a63ad8abb3d99e98e665dd77053b">map_pull_back</a> (const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;physical_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K) const</td></tr>
<tr class="separator:ad679a63ad8abb3d99e98e665dd77053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885db5e95d6990a8f1056c5d04900621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a885db5e95d6990a8f1056c5d04900621">map_pull_back_to_memory_real</a> (const Eigen::ArrayXXd &amp;physical_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K, double *reference_data) const</td></tr>
<tr class="separator:a885db5e95d6990a8f1056c5d04900621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c83398e77228993278798c4dcc3fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae4c83398e77228993278798c4dcc3fe9">map_pull_back_to_memory_complex</a> (const Eigen::Array&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;physical_data, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;J, const Eigen::ArrayXd &amp;detJ, const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;K, std::complex&lt; double &gt; *reference_data) const</td></tr>
<tr class="separator:ae4c83398e77228993278798c4dcc3fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9501349952715cda61dd48c0e2395ffb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9501349952715cda61dd48c0e2395ffb">entity_dofs</a> () const</td></tr>
<tr class="separator:a9501349952715cda61dd48c0e2395ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e81b3893b14939790c6aacb6ec7d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#af76e81b3893b14939790c6aacb6ec7d4">base_permutations</a> () const</td></tr>
<tr class="separator:af76e81b3893b14939790c6aacb6ec7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100a9e7b1c3eb7dab992696877c7889f"><td class="memItemLeft" align="right" valign="top"><a id="a100a9e7b1c3eb7dab992696877c7889f"></a>
const Eigen::ArrayXXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a100a9e7b1c3eb7dab992696877c7889f">points</a> () const</td></tr>
<tr class="memdesc:a100a9e7b1c3eb7dab992696877c7889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of interpolation points. <br /></td></tr>
<tr class="separator:a100a9e7b1c3eb7dab992696877c7889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b604f114c15fddb979f4fffee90236"><td class="memItemLeft" align="right" valign="top"><a id="a90b604f114c15fddb979f4fffee90236"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a90b604f114c15fddb979f4fffee90236">num_points</a> () const</td></tr>
<tr class="memdesc:a90b604f114c15fddb979f4fffee90236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of interpolation points. <br /></td></tr>
<tr class="separator:a90b604f114c15fddb979f4fffee90236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c13633143b8d607459e42e9d69d43a"><td class="memItemLeft" align="right" valign="top">const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ab9c13633143b8d607459e42e9d69d43a">interpolation_matrix</a> () const</td></tr>
<tr class="separator:ab9c13633143b8d607459e42e9d69d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite Element The basis is stored as a set of coefficients, which are applied to the underlying expansion set for that cell type, when tabulating. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af76e81b3893b14939790c6aacb6ec7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76e81b3893b14939790c6aacb6ec7d4">&#9670;&nbsp;</a></span>base_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; FiniteElement::base_permutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the base permutations The base permutations represent the effect of rotating or reflecting a subentity of the cell on the numbering and orientation of the DOFs. This returns a list of matrices with one matrix for each subentity permutation in the following order: Reversing edge 0, reversing edge 1, ... Rotate face 0, reflect face 0, rotate face 1, reflect face 1, ...</p>
<h2>Example: Order 3 Lagrange on a triangle </h2>
<p>This space has 10 dofs arranged like: </p><div class="fragment"><div class="line">2</div>
<div class="line">|\</div>
<div class="line">6 4</div>
<div class="line">|  \</div>
<div class="line">5 9 3</div>
<div class="line">|    \</div>
<div class="line">0-7-8-1</div>
</div><!-- fragment --><p>For this element, the base permutations are: [Matrix swapping 3 and 4, Matrix swapping 5 and 6, Matrix swapping 7 and 8] The first row shows the effect of reversing the diagonal edge. The second row shows the effect of reversing the vertical edge. The third row shows the effect of reversing the horizontal edge.</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>This space has 3 dofs arranged like: </p><div class="fragment"><div class="line">  |\</div>
<div class="line">  | \</div>
<div class="line">  |  \</div>
<div class="line">&lt;-1   0</div>
<div class="line">  |  / \</div>
<div class="line">  | L ^ \</div>
<div class="line">  |   |  \</div>
<div class="line">   ---2---</div>
</div><!-- fragment --><p>These DOFs are integrals of normal components over the edges: DOFs 0 and 2 are oriented inward, DOF 1 is oriented outwards. For this element, the base permutation matrices are: </p><div class="fragment"><div class="line">0: [[-1, 0, 0],</div>
<div class="line">    [ 0, 1, 0],</div>
<div class="line">    [ 0, 0, 1]]</div>
<div class="line">1: [[1,  0, 0],</div>
<div class="line">    [0, -1, 0],</div>
<div class="line">    [0,  0, 1]]</div>
<div class="line">2: [[1, 0,  0],</div>
<div class="line">    [0, 1,  0],</div>
<div class="line">    [0, 0, -1]]</div>
</div><!-- fragment --><p>The first matrix reverses DOF 0 (as this is on the first edge). The second matrix reverses DOF 1 (as this is on the second edge). The third matrix reverses DOF 2 (as this is on the third edge).</p>
<h2>Example: DOFs on the face of Order 2 Nedelec first kind on a tetrahedron </h2>
<p>On a face of this tetrahedron, this space has two face tangent DOFs: </p><div class="fragment"><div class="line">|\        |\</div>
<div class="line">| \       | \</div>
<div class="line">|  \      | ^\</div>
<div class="line">|   \     | | \</div>
<div class="line">| 0-&gt;\    | 1  \</div>
<div class="line">|     \   |     \</div>
<div class="line"> ------    ------</div>
</div><!-- fragment --><p>For these DOFs, the subblocks of the base permutation matrices are: </p><div class="fragment"><div class="line">rotation: [[-1, 1],</div>
<div class="line">           [ 1, 0]]</div>
<div class="line">reflection: [[0, 1],</div>
<div class="line">             [1, 0]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a07e3921459dce5bff1cb731d1713ccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e3921459dce5bff1cb731d1713ccc2">&#9670;&nbsp;</a></span>cell_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> FiniteElement::cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element cell type </p><dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
<a id="a6c9361216564eb22d899f1e961803392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9361216564eb22d899f1e961803392">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element polynomial degree </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a99d38980ecdf3be924a093b4d2319479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d38980ecdf3be924a093b4d2319479">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimension of the finite element space (number of degrees of freedom for the element) </p><dl class="section return"><dt>Returns</dt><dd>Number of degrees of freedom </dd></dl>

</div>
</div>
<a id="a9501349952715cda61dd48c0e2395ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9501349952715cda61dd48c0e2395ffb">&#9670;&nbsp;</a></span>entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; FiniteElement::entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dofs on each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [1, 1, 1], edges: [1, 1, 1], cell: [0] The sum of the entity dofs must match the total number of dofs reported by <a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">FiniteElement::dim</a>, </p><dl class="section return"><dt>Returns</dt><dd>List of entity dof counts on each dimension </dd></dl>

</div>
</div>
<a id="aafaa8df68d126f872c9d028a52709aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaa8df68d126f872c9d028a52709aaf">&#9670;&nbsp;</a></span>family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">element::family FiniteElement::family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the finite element family </p><dl class="section return"><dt>Returns</dt><dd>The family </dd></dl>

</div>
</div>
<a id="ab9c13633143b8d607459e42e9d69d43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c13633143b8d607459e42e9d69d43a">&#9670;&nbsp;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::MatrixXd &amp; FiniteElement::interpolation_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a matrix of weights interpolation To interpolate a function in this finite element, the functions should be evaluated at each point given by <a class="el" href="classbasix_1_1FiniteElement.html#a100a9e7b1c3eb7dab992696877c7889f" title="Return a set of interpolation points.">FiniteElement::points()</a>. These function values should then be multiplied by the weight matrix to give the coefficients of the interpolated function. </p>

</div>
</div>
<a id="ad679a63ad8abb3d99e98e665dd77053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad679a63ad8abb3d99e98e665dd77053b">&#9670;&nbsp;</a></span>map_pull_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; FiniteElement::map_pull_back </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physical_data</td><td>The function values on the cell </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the reference </dd></dl>

</div>
</div>
<a id="ae4c83398e77228993278798c4dcc3fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c83398e77228993278798c4dcc3fe9">&#9670;&nbsp;</a></span>map_pull_back_to_memory_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::map_pull_back_to_memory_complex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>physical_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>reference_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physical_data</td><td>The function values on the cell </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">reference_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a885db5e95d6990a8f1056c5d04900621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885db5e95d6990a8f1056c5d04900621">&#9670;&nbsp;</a></span>map_pull_back_to_memory_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::map_pull_back_to_memory_real </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>physical_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>reference_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physical_data</td><td>The function values on the cell </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">reference_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a215a6a18895a1e370e3eb2046dae0166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215a6a18895a1e370e3eb2046dae0166">&#9670;&nbsp;</a></span>map_push_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; FiniteElement::map_push_forward </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from the reference to a physical cell </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_data</td><td>The function values on the reference </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the cell </dd></dl>

</div>
</div>
<a id="ac79f25ceadbddfa0655f231e3667c61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79f25ceadbddfa0655f231e3667c61e">&#9670;&nbsp;</a></span>map_push_forward_to_memory_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::map_push_forward_to_memory_complex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>physical_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct to memory push forward </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_data</td><td>The function values on the reference </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">physical_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb99c18e9d023e29f996120cff23b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb99c18e9d023e29f996120cff23b2b0">&#9670;&nbsp;</a></span>map_push_forward_to_memory_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::map_push_forward_to_memory_real </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>physical_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct to memory push forward </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_data</td><td>The function values on the reference </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">physical_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c73e9e3bbcbd310035ae2acb8c25e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c73e9e3bbcbd310035ae2acb8c25e7">&#9670;&nbsp;</a></span>mapping_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacebasix_1_1mapping.html#a2426bf33626776d9ca2efe0b60438f9b">mapping::type</a> FiniteElement::mapping_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mapping type used for this element </p><dl class="section return"><dt>Returns</dt><dd>The mapping </dd></dl>

</div>
</div>
<a id="ae9142c0e8f4dc91456387344313e1354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9142c0e8f4dc91456387344313e1354">&#9670;&nbsp;</a></span>tabulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::ArrayXXd &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The first entry in the list is the basis function. Higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, i.e. for the (x,y) derivatives in 2D: (0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0)... The function <a class="el" href="namespacebasix.html#a7c1ffad0977ef56fe76213782c7e5e8b">basix::idx</a> can be used to find the appropriate derivative. If a vector result is expected, it will be stacked with all x values, followed by all y-values (and then z, if any), likewise tensor-valued results will be stacked in index order. </dd></dl>

</div>
</div>
<a id="ae0effbf7ea7c51051666c3b7fcb725bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0effbf7ea7c51051666c3b7fcb725bf">&#9670;&nbsp;</a></span>tabulate_to_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate_to_memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>basis_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct to memory block tabulation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd</td><td>Number of derivatives </td></tr>
    <tr><td class="paramname">x</td><td>Points </td></tr>
    <tr><td class="paramname">basis_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82325b132e0b989ee51338b7727ce38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82325b132e0b989ee51338b7727ce38f">&#9670;&nbsp;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; FiniteElement::value_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value tensor shape, e.g. returning [1] for scalars. </p><dl class="section return"><dt>Returns</dt><dd>Value shape </dd></dl>

</div>
</div>
<a id="a2b0d7ce9c73d76c18f2cc1de08a59cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0d7ce9c73d76c18f2cc1de08a59cb9">&#9670;&nbsp;</a></span>value_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::value_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value size This is just a convenience function returning product(value_shape) </p><dl class="section return"><dt>Returns</dt><dd>Value size </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/basix/basix/cpp/<a class="el" href="finite-element_8h_source.html">finite-element.h</a></li>
<li>/home/runner/work/basix/basix/cpp/finite-element.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>

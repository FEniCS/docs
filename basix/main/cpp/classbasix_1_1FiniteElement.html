<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Basix: basix::FiniteElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://docs.fenicsproject.org/pandoc.css" rel="stylesheet" type="text/css" />
<link href="https://docs.fenicsproject.org/basix/main/assets/sty.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" type="image/x-icon" href="https://fenicsproject.org/favicon.ico"/>
</head>
<body>
<div class='fenicsheadwrapper'>
<div class='fenicshead'>
<div class='fenicstitle'><a href='https://docs.fenicsproject.org/basix/main/index.html'>Basix <span class='fenicsversion'>0.1.1.0</span></a></div>
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/index.html'>Home</a>
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/install.html'>Installation</a>
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/cpp'>C++ docs</a>
<a class='fenicsnav' href='https://docs.fenicsproject.org/basix/main/python'>Python docs</a>
</div></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasix.html">basix</a></li><li class="navelem"><a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classbasix_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basix::FiniteElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="finite-element_8h_source.html">finite-element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c35d60bb22575a33f59bf5b68056514"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0c35d60bb22575a33f59bf5b68056514">FiniteElement</a> (element::family <a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a>, <a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a>, int <a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a>, const std::vector&lt; std::size_t &gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a>, const xt::xtensor&lt; double, 3 &gt; &amp;coeffs, const std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt; &amp;<a class="el" href="classbasix_1_1FiniteElement.html#a33995ee9439d50bca3a9972e1445992d">entity_transformations</a>, const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt;, 4 &gt; &amp;x, const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 3 &gt;&gt;, 4 &gt; &amp;M, <a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> <a class="el" href="classbasix_1_1FiniteElement.html#abd2f2e222254d8f1a3bf69964906e75d">map_type</a>=maps::type::identity)</td></tr>
<tr class="separator:a0c35d60bb22575a33f59bf5b68056514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memItemLeft" align="right" valign="top"><a id="ad6d31f4039d140b08a88e8cc6d33d06a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad6d31f4039d140b08a88e8cc6d33d06a">FiniteElement</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ad6d31f4039d140b08a88e8cc6d33d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d657b79583dd417c18232057aafda98"><td class="memItemLeft" align="right" valign="top"><a id="a2d657b79583dd417c18232057aafda98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2d657b79583dd417c18232057aafda98">FiniteElement</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a2d657b79583dd417c18232057aafda98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2d657b79583dd417c18232057aafda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22cdbee8b090eaee4a441772c94a24"><td class="memItemLeft" align="right" valign="top"><a id="a8d22cdbee8b090eaee4a441772c94a24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a8d22cdbee8b090eaee4a441772c94a24">~FiniteElement</a> ()=default</td></tr>
<tr class="memdesc:a8d22cdbee8b090eaee4a441772c94a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d22cdbee8b090eaee4a441772c94a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012641ff0a6abe1bda2e9493615c22fc"><td class="memItemLeft" align="right" valign="top"><a id="a012641ff0a6abe1bda2e9493615c22fc"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a012641ff0a6abe1bda2e9493615c22fc">operator=</a> (const <a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;element)=default</td></tr>
<tr class="memdesc:a012641ff0a6abe1bda2e9493615c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a012641ff0a6abe1bda2e9493615c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2bef969b9481371fa06f701009794"><td class="memItemLeft" align="right" valign="top"><a id="a0cd2bef969b9481371fa06f701009794"></a>
<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cd2bef969b9481371fa06f701009794">operator=</a> (<a class="el" href="classbasix_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a0cd2bef969b9481371fa06f701009794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a0cd2bef969b9481371fa06f701009794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf3833eba5388b26727768a311c5965"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a0cf3833eba5388b26727768a311c5965">tabulate</a> (int nd, const xt::xarray&lt; double &gt; &amp;x) const</td></tr>
<tr class="separator:a0cf3833eba5388b26727768a311c5965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136cc9018791cc33cc58a5acfbc87544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a136cc9018791cc33cc58a5acfbc87544">tabulate</a> (int nd, const xt::xarray&lt; double &gt; &amp;x, xt::xtensor&lt; double, 4 &gt; &amp;basis_data) const</td></tr>
<tr class="separator:a136cc9018791cc33cc58a5acfbc87544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e3921459dce5bff1cb731d1713ccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a07e3921459dce5bff1cb731d1713ccc2">cell_type</a> () const</td></tr>
<tr class="separator:a07e3921459dce5bff1cb731d1713ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9361216564eb22d899f1e961803392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a6c9361216564eb22d899f1e961803392">degree</a> () const</td></tr>
<tr class="separator:a6c9361216564eb22d899f1e961803392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a2b0d7ce9c73d76c18f2cc1de08a59cb9">value_size</a> () const</td></tr>
<tr class="separator:a2b0d7ce9c73d76c18f2cc1de08a59cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82325b132e0b989ee51338b7727ce38f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a82325b132e0b989ee51338b7727ce38f">value_shape</a> () const</td></tr>
<tr class="separator:a82325b132e0b989ee51338b7727ce38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d38980ecdf3be924a093b4d2319479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">dim</a> () const</td></tr>
<tr class="separator:a99d38980ecdf3be924a093b4d2319479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaa8df68d126f872c9d028a52709aaf"><td class="memItemLeft" align="right" valign="top">element::family&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aafaa8df68d126f872c9d028a52709aaf">family</a> () const</td></tr>
<tr class="separator:aafaa8df68d126f872c9d028a52709aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad987bd4ad7cf140bf91101f15995ae69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ad987bd4ad7cf140bf91101f15995ae69">mapping_type</a> () const</td></tr>
<tr class="separator:ad987bd4ad7cf140bf91101f15995ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a46dd5cfd393b08ca5e619c20c63c6ce5">dof_transformations_are_permutations</a> () const</td></tr>
<tr class="separator:a46dd5cfd393b08ca5e619c20c63c6ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac5b7c1db36efbc036b8831e9c0ef7f1a">dof_transformations_are_identity</a> () const</td></tr>
<tr class="separator:ac5b7c1db36efbc036b8831e9c0ef7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2afa4f636cec9cf68e725b6e29546f"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aec2afa4f636cec9cf68e725b6e29546f">map_push_forward</a> (const xt::xtensor&lt; double, 3 &gt; &amp;U, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K) const</td></tr>
<tr class="separator:aec2afa4f636cec9cf68e725b6e29546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028704e44a3f110510d7ecd509825900"><td class="memTemplParams" colspan="2">template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a028704e44a3f110510d7ecd509825900"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a028704e44a3f110510d7ecd509825900">map_push_forward_m</a> (const xt::xtensor&lt; T, 3 &gt; &amp;U, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K, E &amp;&amp;u) const</td></tr>
<tr class="separator:a028704e44a3f110510d7ecd509825900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbcc0627d583ac0b73a3a0b2ff55301"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a4bbcc0627d583ac0b73a3a0b2ff55301">map_pull_back</a> (const xt::xtensor&lt; double, 3 &gt; &amp;u, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K) const</td></tr>
<tr class="separator:a4bbcc0627d583ac0b73a3a0b2ff55301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc44561c208bdd31b9eef64a5a2216ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:acc44561c208bdd31b9eef64a5a2216ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#acc44561c208bdd31b9eef64a5a2216ef">map_pull_back_m</a> (const xt::xtensor&lt; T, 3 &gt; &amp;u, const xt::xtensor&lt; double, 3 &gt; &amp;J, const xtl::span&lt; const double &gt; &amp;detJ, const xt::xtensor&lt; double, 3 &gt; &amp;K, E &amp;&amp;U) const</td></tr>
<tr class="separator:acc44561c208bdd31b9eef64a5a2216ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9501349952715cda61dd48c0e2395ffb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9501349952715cda61dd48c0e2395ffb">entity_dofs</a> () const</td></tr>
<tr class="separator:a9501349952715cda61dd48c0e2395ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f6d20c7990da4441b81bea8aab4ec"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#aff0f6d20c7990da4441b81bea8aab4ec">base_transformations</a> () const</td></tr>
<tr class="separator:aff0f6d20c7990da4441b81bea8aab4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33995ee9439d50bca3a9972e1445992d"><td class="memItemLeft" align="right" valign="top"><a id="a33995ee9439d50bca3a9972e1445992d"></a>
std::vector&lt; xt::xtensor&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a33995ee9439d50bca3a9972e1445992d">entity_transformations</a> () const</td></tr>
<tr class="memdesc:a33995ee9439d50bca3a9972e1445992d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entity dof transformation matricess. <br /></td></tr>
<tr class="separator:a33995ee9439d50bca3a9972e1445992d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d4be5aabe5c1262a41aa906793e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ac51d4be5aabe5c1262a41aa906793e4b">permute_dofs</a> (const xtl::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ac51d4be5aabe5c1262a41aa906793e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04faa96922aa2dd770c08839f38327c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae04faa96922aa2dd770c08839f38327c">unpermute_dofs</a> (const xtl::span&lt; std::int32_t &gt; &amp;dofs, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae04faa96922aa2dd770c08839f38327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5004d8af1a79884ac72e31597f6f07f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5004d8af1a79884ac72e31597f6f07f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#ae5004d8af1a79884ac72e31597f6f07f">apply_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:ae5004d8af1a79884ac72e31597f6f07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a9d7b7e7b94a8f7494d5f50963770265f">apply_inverse_transpose_dof_transformation</a> (const xtl::span&lt; T &gt; &amp;data, int block_size, std::uint32_t cell_info) const</td></tr>
<tr class="separator:a9d7b7e7b94a8f7494d5f50963770265f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507daff721c5d41e9d62b4e68e639bea"><td class="memItemLeft" align="right" valign="top">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">points</a> () const</td></tr>
<tr class="separator:a507daff721c5d41e9d62b4e68e639bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b604f114c15fddb979f4fffee90236"><td class="memItemLeft" align="right" valign="top"><a id="a90b604f114c15fddb979f4fffee90236"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a90b604f114c15fddb979f4fffee90236">num_points</a> () const</td></tr>
<tr class="memdesc:a90b604f114c15fddb979f4fffee90236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of interpolation points. <br /></td></tr>
<tr class="separator:a90b604f114c15fddb979f4fffee90236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61674c5b124276e8ffd697541844d06e"><td class="memItemLeft" align="right" valign="top">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#a61674c5b124276e8ffd697541844d06e">interpolation_matrix</a> () const</td></tr>
<tr class="separator:a61674c5b124276e8ffd697541844d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abd2f2e222254d8f1a3bf69964906e75d"><td class="memItemLeft" align="right" valign="top"><a id="abd2f2e222254d8f1a3bf69964906e75d"></a>
<a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasix_1_1FiniteElement.html#abd2f2e222254d8f1a3bf69964906e75d">map_type</a></td></tr>
<tr class="memdesc:abd2f2e222254d8f1a3bf69964906e75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element map type. <br /></td></tr>
<tr class="separator:abd2f2e222254d8f1a3bf69964906e75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite Element The basis is stored as a set of coefficients, which are applied to the underlying expansion set for that cell type, when tabulating. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c35d60bb22575a33f59bf5b68056514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c35d60bb22575a33f59bf5b68056514">&#9670;&nbsp;</a></span>FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FiniteElement::FiniteElement </td>
          <td>(</td>
          <td class="paramtype">element::family&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a>&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>entity_transformations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 2 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; xt::xtensor&lt; double, 3 &gt;&gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a>&#160;</td>
          <td class="paramname"><em>map_type</em> = <code>maps::type::identity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Document A finite element </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>Expansion coefficients. The shape is (num_dofs, value_size, basis_dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_transformations</td><td>Entity transformations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation points. Shape is (tdim, entity index, point index, dim) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The interpolation matrices. Indices are (tdim, entity index, dof, vs, point_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_type</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5004d8af1a79884ac72e31597f6f07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5004d8af1a79884ac72e31597f6f07f">&#9670;&nbsp;</a></span>apply_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply DOF transformations to some data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d7b7e7b94a8f7494d5f50963770265f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7b7e7b94a8f7494d5f50963770265f">&#9670;&nbsp;</a></span>apply_inverse_transpose_dof_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::apply_inverse_transpose_dof_transformation </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply inverse_transpose DOF transformations to some data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_size</td><td>The number of data points per DOF </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f6d20c7990da4441b81bea8aab4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f6d20c7990da4441b81bea8aab4ec">&#9670;&nbsp;</a></span>base_transformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::base_transformations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the base transformations The base transformations represent the effect of rotating or reflecting a subentity of the cell on the numbering and orientation of the DOFs. This returns a list of matrices with one matrix for each subentity permutation in the following order: Reversing edge 0, reversing edge 1, ... Rotate face 0, reflect face 0, rotate face 1, reflect face 1, ...</p>
<h2>Example: Order 3 Lagrange on a triangle </h2>
<p>This space has 10 dofs arranged like: </p><div class="fragment"><div class="line">2</div>
<div class="line">|\</div>
<div class="line">6 4</div>
<div class="line">|  \</div>
<div class="line">5 9 3</div>
<div class="line">|    \</div>
<div class="line">0-7-8-1</div>
</div><!-- fragment --><p>For this element, the base transformations are: [Matrix swapping 3 and 4, Matrix swapping 5 and 6, Matrix swapping 7 and 8] The first row shows the effect of reversing the diagonal edge. The second row shows the effect of reversing the vertical edge. The third row shows the effect of reversing the horizontal edge.</p>
<h2>Example: Order 1 Raviart-Thomas on a triangle </h2>
<p>This space has 3 dofs arranged like: </p><div class="fragment"><div class="line">  |\</div>
<div class="line">  | \</div>
<div class="line">  |  \</div>
<div class="line">&lt;-1   0</div>
<div class="line">  |  / \</div>
<div class="line">  | L ^ \</div>
<div class="line">  |   |  \</div>
<div class="line">   ---2---</div>
</div><!-- fragment --><p>These DOFs are integrals of normal components over the edges: DOFs 0 and 2 are oriented inward, DOF 1 is oriented outwards. For this element, the base transformation matrices are: </p><div class="fragment"><div class="line">0: [[-1, 0, 0],</div>
<div class="line">    [ 0, 1, 0],</div>
<div class="line">    [ 0, 0, 1]]</div>
<div class="line">1: [[1,  0, 0],</div>
<div class="line">    [0, -1, 0],</div>
<div class="line">    [0,  0, 1]]</div>
<div class="line">2: [[1, 0,  0],</div>
<div class="line">    [0, 1,  0],</div>
<div class="line">    [0, 0, -1]]</div>
</div><!-- fragment --><p>The first matrix reverses DOF 0 (as this is on the first edge). The second matrix reverses DOF 1 (as this is on the second edge). The third matrix reverses DOF 2 (as this is on the third edge).</p>
<h2>Example: DOFs on the face of Order 2 Nedelec first kind on a tetrahedron </h2>
<p>On a face of this tetrahedron, this space has two face tangent DOFs: </p><div class="fragment"><div class="line">|\        |\</div>
<div class="line">| \       | \</div>
<div class="line">|  \      | ^\</div>
<div class="line">|   \     | | \</div>
<div class="line">| 0-&gt;\    | 1  \</div>
<div class="line">|     \   |     \</div>
<div class="line"> ------    ------</div>
</div><!-- fragment --><p>For these DOFs, the subblocks of the base transformation matrices are: </p><div class="fragment"><div class="line">rotation: [[-1, 1],</div>
<div class="line">           [ 1, 0]]</div>
<div class="line">reflection: [[0, 1],</div>
<div class="line">             [1, 0]]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a07e3921459dce5bff1cb731d1713ccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e3921459dce5bff1cb731d1713ccc2">&#9670;&nbsp;</a></span>cell_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1cell.html#a6b9fb94bbe86f3e58ccd241e0e4f2069">cell::type</a> FiniteElement::cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element cell type </p><dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
<a id="a6c9361216564eb22d899f1e961803392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9361216564eb22d899f1e961803392">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element polynomial degree </p><dl class="section return"><dt>Returns</dt><dd>Polynomial degree </dd></dl>

</div>
</div>
<a id="a99d38980ecdf3be924a093b4d2319479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d38980ecdf3be924a093b4d2319479">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimension of the finite element space (number of degrees of freedom for the element) </p><dl class="section return"><dt>Returns</dt><dd>Number of degrees of freedom </dd></dl>

</div>
</div>
<a id="ac5b7c1db36efbc036b8831e9c0ef7f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b7c1db36efbc036b8831e9c0ef7f1a">&#9670;&nbsp;</a></span>dof_transformations_are_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all the identity </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="a46dd5cfd393b08ca5e619c20c63c6ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dd5cfd393b08ca5e619c20c63c6ce5">&#9670;&nbsp;</a></span>dof_transformations_are_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FiniteElement::dof_transformations_are_permutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether the dof transformations are all permutations </p><dl class="section return"><dt>Returns</dt><dd>True or False </dd></dl>

</div>
</div>
<a id="a9501349952715cda61dd48c0e2395ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9501349952715cda61dd48c0e2395ffb">&#9670;&nbsp;</a></span>entity_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; FiniteElement::entity_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dofs on each topological entity: (vertices, edges, faces, cell) in that order. For example, Lagrange degree 2 on a triangle has vertices: [1, 1, 1], edges: [1, 1, 1], cell: [0] The sum of the entity dofs must match the total number of dofs reported by <a class="el" href="classbasix_1_1FiniteElement.html#a99d38980ecdf3be924a093b4d2319479">FiniteElement::dim</a>, </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::vector&lt;int&gt;&gt;&amp; dofs = e.entity_dofs();</div>
<div class="line"><span class="keywordtype">int</span> num_dofs0 = dofs[1][3]; <span class="comment">// Number of dofs associated with edge 3</span></div>
<div class="line"><span class="keywordtype">int</span> num_dofs1 = dofs[2][0]; <span class="comment">// Number of dofs associated with face 0</span></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Number of dofs associated with an entity of a given topological dimension. The shape is (tdim + 1, num_entities). </dd></dl>

</div>
</div>
<a id="aafaa8df68d126f872c9d028a52709aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaa8df68d126f872c9d028a52709aaf">&#9670;&nbsp;</a></span>family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">element::family FiniteElement::family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the finite element family </p><dl class="section return"><dt>Returns</dt><dd>The family </dd></dl>

</div>
</div>
<a id="a61674c5b124276e8ffd697541844d06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61674c5b124276e8ffd697541844d06e">&#9670;&nbsp;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const xt::xtensor&lt; double, 2 &gt; &amp; FiniteElement::interpolation_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a matrix of weights interpolation To interpolate a function in this finite element, the functions should be evaluated at each point given by <a class="el" href="classbasix_1_1FiniteElement.html#a507daff721c5d41e9d62b4e68e639bea">FiniteElement::points()</a>. These function values should then be multiplied by the weight matrix to give the coefficients of the interpolated function. </p>

</div>
</div>
<a id="a4bbcc0627d583ac0b73a3a0b2ff55301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbcc0627d583ac0b73a3a0b2ff55301">&#9670;&nbsp;</a></span>map_pull_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::map_pull_back </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from a physical cell to the reference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The function values on the cell </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the reference </dd></dl>

</div>
</div>
<a id="acc44561c208bdd31b9eef64a5a2216ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc44561c208bdd31b9eef64a5a2216ef">&#9670;&nbsp;</a></span>map_pull_back_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::map_pull_back_m </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Weirdly, the u and U Map function values from a physical cell to the reference </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The function values on the cell </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">U</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec2afa4f636cec9cf68e725b6e29546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2afa4f636cec9cf68e725b6e29546f">&#9670;&nbsp;</a></span>map_push_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 3 &gt; FiniteElement::map_push_forward </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map function values from the reference to a physical cell </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The function values on the reference </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function values on the cell </dd></dl>

</div>
</div>
<a id="a028704e44a3f110510d7ecd509825900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028704e44a3f110510d7ecd509825900">&#9670;&nbsp;</a></span>map_push_forward_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void basix::FiniteElement::map_push_forward_m </td>
          <td>(</td>
          <td class="paramtype">const xt::xtensor&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>detJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct to memory push forward </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The function values on the reference </td></tr>
    <tr><td class="paramname">J</td><td>The Jacobian of the mapping </td></tr>
    <tr><td class="paramname">detJ</td><td>The determinant of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">K</td><td>The inverse of the Jacobian of the mapping </td></tr>
    <tr><td class="paramname">u</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad987bd4ad7cf140bf91101f15995ae69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad987bd4ad7cf140bf91101f15995ae69">&#9670;&nbsp;</a></span>mapping_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebasix_1_1maps.html#acc2c2d4600630fca6e0967d25d0859e9">maps::type</a> FiniteElement::mapping_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mapping type used for this element </p><dl class="section return"><dt>Returns</dt><dd>The mapping </dd></dl>

</div>
</div>
<a id="ac51d4be5aabe5c1262a41aa906793e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d4be5aabe5c1262a41aa906793e4b">&#9670;&nbsp;</a></span>permute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::permute_dofs </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permute the dof numbering on a cell </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507daff721c5d41e9d62b4e68e639bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507daff721c5d41e9d62b4e68e639bea">&#9670;&nbsp;</a></span>points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const xt::xtensor&lt; double, 2 &gt; &amp; FiniteElement::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interpolation points, i.e. the coordinates on the reference element where a function need to be evaluated in order to interpolate it in the finite element space. </p><dl class="section return"><dt>Returns</dt><dd>Array of coordinate with shape <code>(num_points, tdim)</code> </dd></dl>

</div>
</div>
<a id="a0cf3833eba5388b26727768a311c5965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf3833eba5388b26727768a311c5965">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 4 &gt; FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute basis values and derivatives at set of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>The order of derivatives, up to and including, to compute. Use 0 for the basis functions only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which to compute the basis functions. The shape of x is (number of points, geometric dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis functions (and derivatives). The shape is (derivative, point, basis fn index, value index).<ul>
<li>The first index is the derivative, with higher derivatives are stored in triangular (2D) or tetrahedral (3D) ordering, i.e. for the (x,y) derivatives in 2D: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), (3,0)... The function <a class="el" href="namespacebasix.html#a7c1ffad0977ef56fe76213782c7e5e8b">basix::idx</a> can be used to find the appropriate derivative.</li>
<li>The second index is the point index</li>
<li>The third index is the basis function index</li>
<li>The fourth index is the basis function component. Its has size one for scalar basis functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a136cc9018791cc33cc58a5acfbc87544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136cc9018791cc33cc58a5acfbc87544">&#9670;&nbsp;</a></span>tabulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::tabulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xt::xtensor&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct to memory block tabulation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd</td><td>Number of derivatives </td></tr>
    <tr><td class="paramname">x</td><td>Points </td></tr>
    <tr><td class="paramname">basis_data</td><td>Memory location to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae04faa96922aa2dd770c08839f38327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04faa96922aa2dd770c08839f38327c">&#9670;&nbsp;</a></span>unpermute_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FiniteElement::unpermute_dofs </td>
          <td>(</td>
          <td class="paramtype">const xtl::span&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>cell_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpermute the dof numbering on a cell </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dofs</td><td>The dof numbering for the cell </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cell_info</td><td>The permutation info for the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82325b132e0b989ee51338b7727ce38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82325b132e0b989ee51338b7727ce38f">&#9670;&nbsp;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; FiniteElement::value_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value tensor shape, e.g. returning [1] for scalars. </p><dl class="section return"><dt>Returns</dt><dd>Value shape </dd></dl>

</div>
</div>
<a id="a2b0d7ce9c73d76c18f2cc1de08a59cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0d7ce9c73d76c18f2cc1de08a59cb9">&#9670;&nbsp;</a></span>value_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FiniteElement::value_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the element value size This is just a convenience function returning product(value_shape) </p><dl class="section return"><dt>Returns</dt><dd>Value size </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/basix/basix/cpp/basix/<a class="el" href="finite-element_8h_source.html">finite-element.h</a></li>
<li>/home/runner/work/basix/basix/cpp/basix/finite-element.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Form language &#8212; Unified Form Language (UFL) 2022.3.0.dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Example forms" href="examples.html" />
    <link rel="prev" title="Introduction" href="introduction.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="form-language">
<h1>Form language<a class="headerlink" href="#form-language" title="Permalink to this heading">¶</a></h1>
<p>UFL consists of a set of operators and atomic expressions that can be
used to express variational forms and functionals.  Below we will define
all these operators and atomic expressions in detail.</p>
<p>UFL is built on top of the Python language, and any Python code is
valid in the definition of a form.
In particular, comments (lines starting with <code class="docutils literal notranslate"><span class="pre">#</span></code>) and functions
(keyword <code class="docutils literal notranslate"><span class="pre">def</span></code>, see <a class="reference internal" href="#user-defined">user-defined</a>
below) are useful in the definition of a form.  However, it is usually a
good idea to avoid using advanced Python features in the form definition,
to stay close to the mathematical notation.</p>
<p>The entire form language can be imported in Python with the line</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ufl</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This can be useful for experimenting with the language in an
interactive Python interpreter.</p>
<section id="forms-and-integrals">
<h2>Forms and integrals<a class="headerlink" href="#forms-and-integrals" title="Permalink to this heading">¶</a></h2>
<p>UFL is designed to express forms in the following generalized format:</p>
<div class="math notranslate nohighlight">
\[a(\mathbf{v}; \mathbf{w})
   =
       \sum_{k=1}^{n_c} \int_{\Omega_k}
             I^c_k(\mathbf{v}; \mathbf{w}) dx
      +     \sum_{k=1}^{n_e} \int_{\partial\Omega_k}
             I^e_k(\mathbf{v}; \mathbf{w}) ds
      +     \sum_{k=1}^{n_i} \int_{\Gamma_k}
             I^i_k(\mathbf{v}; \mathbf{w}) dS.\]</div>
<p>Here the form <span class="math notranslate nohighlight">\(a\)</span> depends on the <em>form arguments</em> <span class="math notranslate nohighlight">\(\mathbf{v} = (v_1,
\ldots, v_r)\)</span> and the <em>form coefficients</em> <span class="math notranslate nohighlight">\(\mathbf{w} = (w_1, \ldots, w_n)\)</span>,
and its expression is a sum of integrals.  Each term of a valid form
expression must be a scalar-valued expression integrated exactly once. How
to define form arguments and integrand expressions is detailed in the
rest of this chapter.</p>
<p>Integrals are expressed through multiplication with a measure,
representing an integral over either</p>
<blockquote>
<div><ul class="simple">
<li><p>the interior of the domain <span class="math notranslate nohighlight">\(\Omega\)</span> (<code class="docutils literal notranslate"><span class="pre">dx</span></code>, cell integral);</p></li>
<li><p>the boundary <span class="math notranslate nohighlight">\(\partial\Omega\)</span> of <span class="math notranslate nohighlight">\(\Omega\)</span> (<code class="docutils literal notranslate"><span class="pre">ds</span></code>, exterior facet integral);</p></li>
<li><p>the set of interior facets <span class="math notranslate nohighlight">\(\Gamma\)</span> (<code class="docutils literal notranslate"><span class="pre">dS</span></code>, interior facet integral).</p></li>
</ul>
</div></blockquote>
<p>(Note that newer versions of UFL support several other integral
types currently not documented here).
As a basic example, assume <code class="docutils literal notranslate"><span class="pre">v</span></code> is a scalar-valued expression and
consider the integral of <code class="docutils literal notranslate"><span class="pre">v</span></code> over the interior of <span class="math notranslate nohighlight">\(\Omega\)</span>. This
may be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>and the integral of <code class="docutils literal notranslate"><span class="pre">v</span></code> over <span class="math notranslate nohighlight">\(\partial\Omega\)</span> is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="o">.</span>
</pre></div>
</div>
<p>Alternatively, measures can be redefined to represent numbered subsets of
a domain, such that a form evaluates to different expressions on different
parts of the domain.  If <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">e0</span></code> and <code class="docutils literal notranslate"><span class="pre">e1</span></code> are scalar-valued
expressions, then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">e0</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">e1</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>represents</p>
<div class="math notranslate nohighlight">
\[a = \int_\Omega c\,dx + \int_{\partial\Omega_0} e_0 \, ds + \int_{\partial\Omega_1} e_1 \, ds,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\partial\Omega_0 \subset \partial\Omega, \qquad \partial\Omega_1 \subset \partial\Omega.\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The domain <span class="math notranslate nohighlight">\(\Omega\)</span>, its subdomains and boundaries are not known
to UFL. These are defined in a problem solving environment such as DOLFIN,
which uses UFL to specify forms.</p>
</div>
</section>
<section id="finite-element-spaces">
<h2>Finite element spaces<a class="headerlink" href="#finite-element-spaces" title="Permalink to this heading">¶</a></h2>
<p>Before defining forms which can be integrated, it is necessary to describe
the finite element spaces over which the integration takes place.
UFL can represent very flexible general hierarchies of mixed finite elements,
and has predefined names for most common element families.
A finite element space is defined by an element domain, shape functions and nodal variables.
In UFL, the element domain is called a <code class="docutils literal notranslate"><span class="pre">Cell</span></code>.</p>
<section id="cells">
<h3>Cells<a class="headerlink" href="#cells" title="Permalink to this heading">¶</a></h3>
<p>A polygonal cell is defined by a shape name and a geometric dimension, written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">gdim</span><span class="p">)</span>
</pre></div>
</div>
<p>Valid shapes are “interval”, “triangle”, “tetrahedron”, “quadrilateral”,
and “hexahedron”.  Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Regular triangle cell</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;triangle&quot;</span><span class="p">)</span>

<span class="c1"># Triangle cell embedded in 3D space</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Objects for regular cells of all basic shapes are predefined:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Predefined linear cells</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">interval</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">triangle</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">tetrahedron</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">quadrilateral</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">hexahedron</span>
</pre></div>
</div>
<p>In the rest of this document, a variable name <code class="docutils literal notranslate"><span class="pre">cell</span></code> will be used where
any cell is a valid argument, to make the examples dimension-independent
wherever possible.  Using a variable <code class="docutils literal notranslate"><span class="pre">cell</span></code> to hold the cell type used
in a form is highly recommended, since this makes most form definitions
dimension-independent.</p>
</section>
<section id="element-families">
<h3>Element families<a class="headerlink" href="#element-families" title="Permalink to this heading">¶</a></h3>
<p>UFL predefines a set of names of known element families.  When defining
a finite element below, the argument <code class="docutils literal notranslate"><span class="pre">family</span></code> is a string and its
possible values include</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Lagrange&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;CG&quot;</span></code>, representing standard scalar
Lagrange finite elements (continuous piecewise polynomial functions);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Discontinuous</span> <span class="pre">Lagrange&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;DG&quot;</span></code>, representing
scalar discontinuous Lagrange finite elements (discontinuous piecewise
polynomial functions);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Crouzeix-Raviart&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;CR&quot;</span></code>, representing scalar
Crouzeix–Raviart elements;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Brezzi-Douglas-Marini&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;BDM&quot;</span></code>, representing
vector-valued Brezzi–Douglas–Marini H(div) elements;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Brezzi-Douglas-Fortin-Marini</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;BDFM&quot;</span></code>, representing
vector-valued Brezzi–Douglas–Fortin–Marini H(div) elements;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Raviart-Thomas&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;RT&quot;</span></code>, representing
vector-valued Raviart–Thomas H(div) elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Nedelec</span> <span class="pre">1st</span> <span class="pre">kind</span> <span class="pre">H(div)&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;N1div&quot;</span></code>,
representing vector-valued Nedelec H(div) elements
(of the first kind).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Nedelec</span> <span class="pre">2st</span> <span class="pre">kind</span> <span class="pre">H(div)&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;N2div&quot;</span></code>,
representing vector-valued Nedelec H(div) elements
(of the second kind).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Nedelec</span> <span class="pre">1st</span> <span class="pre">kind</span> <span class="pre">H(curl)&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;N1curl&quot;</span></code>, representing
vector-valued Nedelec H(curl) elements
(of the first kind).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Nedelec</span> <span class="pre">2st</span> <span class="pre">kind</span> <span class="pre">H(curl)&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;N2curl&quot;</span></code>,
representing vector-valued Nedelec H(curl) elements
(of the second kind).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Bubble&quot;</span></code>,
representing bubble elements, useful for example to build the mini elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Quadrature&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Q&quot;</span></code>, representing artificial “finite elements”
with degrees of freedom being function evaluations at quadrature points;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Boundary</span> <span class="pre">Quadrature&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;BQ&quot;</span></code>, representing artificial
“finite elements” with degrees of freedom being function evaluations
at quadrature points on the boundary.</p></li>
</ul>
<p>Note that new versions of UFL also support notation from the Periodic Table
of Finite Elements, currently not documented here.</p>
</section>
<section id="basic-elements">
<h3>Basic elements<a class="headerlink" href="#basic-elements" title="Permalink to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code>, sometimes called a basic element, represents a
finite element from some family on a given cell with a certain polynomial
degree. Valid families and cells are explained above.
The notation is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">tetrahedron</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;BDM&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="vector-elements">
<h3>Vector elements<a class="headerlink" href="#vector-elements" title="Permalink to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">VectorElement</span></code> represents a combination of basic elements such that
each component of a vector is represented by the basic element. The size
is usually omitted, the default size equals the geometry dimension.
The notation is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">degree</span><span class="p">[,</span> <span class="n">size</span><span class="p">])</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># A quadratic &quot;P2&quot; vector element on a triangle</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># A linear 3D vector element on a 1D interval</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># A six-dimensional piecewise constant element on a tetrahedron</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">tetrahedron</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="tensor-elements">
<h3>Tensor elements<a class="headerlink" href="#tensor-elements" title="Permalink to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">TensorElement</span></code> represents a combination of basic elements such that
each component of a tensor is represented by the basic element. The
shape is usually omitted, the default shape is :math: <cite>(d, d)</cite> where :math: <cite>d</cite>
is the geometric dimension. The notation is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">degree</span><span class="p">[,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">symmetry</span><span class="p">])</span>
</pre></div>
</div>
<p>Any shape tuple consisting of positive integers is valid,
and the optional symmetry can either be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
which means standard matrix symmetry (like <span class="math notranslate nohighlight">\(A_{ij} = A_{ji}\)</span>),
or a <code class="docutils literal notranslate"><span class="pre">dict</span></code> like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">(0,1):(1,0),</span> <span class="pre">(0,2):(2,0)</span> <span class="pre">}</span></code>
where the <code class="docutils literal notranslate"><span class="pre">dict</span></code> keys are index tuples that are
represented by the corresponding <code class="docutils literal notranslate"><span class="pre">dict</span></code> value.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">element</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)})</span>
</pre></div>
</div>
</section>
<section id="mixed-elements">
<h3>Mixed elements<a class="headerlink" href="#mixed-elements" title="Permalink to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code> represents an arbitrary combination of other elements.
<code class="docutils literal notranslate"><span class="pre">VectorElement</span></code> and <code class="docutils literal notranslate"><span class="pre">TensorElement</span></code> are special cases of a
<code class="docutils literal notranslate"><span class="pre">MixedElement</span></code> where all sub-elements are equal.</p>
<p>General notation for an arbitrary number of subelements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">MixedElement</span><span class="p">(</span><span class="n">element1</span><span class="p">,</span> <span class="n">element2</span><span class="p">[,</span> <span class="n">element3</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Shorthand notation for two subelements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">element1</span> <span class="o">*</span> <span class="n">element2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code> operator is left-associative, such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">element1</span> <span class="o">*</span> <span class="n">element2</span> <span class="o">*</span> <span class="n">element3</span>
</pre></div>
</div>
<p>represents <code class="docutils literal notranslate"><span class="pre">(e1</span> <span class="pre">*</span> <span class="pre">e2)</span> <span class="pre">*</span> <span class="pre">e3</span></code>, i.e. this is a mixed element with two
sub-elements <code class="docutils literal notranslate"><span class="pre">(e1</span> <span class="pre">*</span> <span class="pre">e2)</span></code> and <code class="docutils literal notranslate"><span class="pre">e3</span></code>.</p>
</div>
<p>See <a class="reference internal" href="#form-arguments">Form arguments</a> for details on how defining
functions on mixed spaces can differ from defining functions on other
finite element spaces.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Taylor-Hood element</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">TH</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="n">P</span>

<span class="c1"># A tensor-vector-scalar element</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ME</span> <span class="o">=</span> <span class="n">MixedElement</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="enrichedelement">
<h3>EnrichedElement<a class="headerlink" href="#enrichedelement" title="Permalink to this heading">¶</a></h3>
<p>The data type <code class="docutils literal notranslate"><span class="pre">EnrichedElement</span></code> represents the vector sum of two
(or more) finite elements.</p>
<p>Example: The Mini element can be constructed as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P1</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">B</span>  <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Bubble&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">Q</span>  <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">Mini</span> <span class="o">=</span> <span class="p">(</span><span class="n">P1</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span>
</pre></div>
</div>
</section>
</section>
<section id="form-arguments">
<h2>Form arguments<a class="headerlink" href="#form-arguments" title="Permalink to this heading">¶</a></h2>
<p>Form arguments are divided in two groups, arguments and
coefficients.  An <code class="docutils literal notranslate"><span class="pre">Argument</span></code> represents an
arbitrary basis function in a given discrete finite element space,
while a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> represents a function in a discrete finite
element space that will be provided by the user at a later stage. The
number of <code class="docutils literal notranslate"><span class="pre">Argument</span></code>s that occur in a <code class="docutils literal notranslate"><span class="pre">Form</span></code> equals
the “arity” of the form.</p>
<section id="basis-functions">
<h3>Basis functions<a class="headerlink" href="#basis-functions" title="Permalink to this heading">¶</a></h3>
<p>The data type <code class="docutils literal notranslate"><span class="pre">Argument</span></code> represents a basis function on a
given finite element. An <code class="docutils literal notranslate"><span class="pre">Argument</span></code> must be created for a
previously declared finite element (simple or mixed):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">Argument</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that more than one <code class="docutils literal notranslate"><span class="pre">Argument</span></code> can be declared for the same
<code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code>. Basis functions are associated with the arguments of
a multilinear form in the order of declaration.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code>, the function <code class="docutils literal notranslate"><span class="pre">Arguments</span></code> can be used to
construct tuples of <code class="docutils literal notranslate"><span class="pre">Argument</span></code>s, as illustrated here for a mixed
Taylor–Hood element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Arguments</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Arguments</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
</pre></div>
</div>
<p>For a <code class="docutils literal notranslate"><span class="pre">Argument</span></code> on a <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code> (or <code class="docutils literal notranslate"><span class="pre">VectorElement</span></code>
or <code class="docutils literal notranslate"><span class="pre">TensorElement</span></code>), the function <code class="docutils literal notranslate"><span class="pre">split</span></code> can be used to extract
basis function values on subspaces, as illustrated here for a mixed
Taylor–Hood element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vq</span> <span class="o">=</span> <span class="n">Argument</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to the previous use of <code class="docutils literal notranslate"><span class="pre">Arguments</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Arguments</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
</pre></div>
</div>
<p>For convenience, <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code> and <code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code> are special
instances of <code class="docutils literal notranslate"><span class="pre">Argument</span></code> with the property that a <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code>
will always be the first argument in a form and <code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code> will
always be the second argument in a form (order of declaration does
not matter).  Their usage is otherwise the same as for <code class="docutils literal notranslate"><span class="pre">Argument</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunctions</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="meshes-and-function-spaces">
<h3>Meshes and function spaces<a class="headerlink" href="#meshes-and-function-spaces" title="Permalink to this heading">¶</a></h3>
<p>Note that newer versions of UFL introduce the concept of a
Mesh and a FunctionSpace. These are currently not documented here.</p>
</section>
<section id="coefficient-functions">
<h3>Coefficient functions<a class="headerlink" href="#coefficient-functions" title="Permalink to this heading">¶</a></h3>
<p>The data type <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> represents a function belonging to a given
finite element space, that is, a linear combination of basis functions
of the finite element space. A <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> must be declared for a
previously declared <code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the order in which <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code>s are declared is important,
directly reflected in the ordering they have among the arguments to each
<code class="docutils literal notranslate"><span class="pre">Form</span></code> they are part of.</p>
<p><code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> is used to represent user-defined functions, including, e.g.,
source terms, body forces, variable coefficients and stabilization terms.
UFL treats each <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> as a linear combination of unknown basis
functions with unknown coefficients, that is, UFL knows nothing about
the concrete basis functions of the element and nothing about the value
of the function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that more than one function can be declared for the same
<code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code>. The following example declares two <code class="docutils literal notranslate"><span class="pre">Argument</span></code>s
and two <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code>s for the same <code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">Argument</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Argument</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>For a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> on a <code class="docutils literal notranslate"><span class="pre">MixedElement</span></code> (or <code class="docutils literal notranslate"><span class="pre">VectorElement</span></code> or
<code class="docutils literal notranslate"><span class="pre">TensorElement</span></code>), the function <code class="docutils literal notranslate"><span class="pre">split</span></code> can be used to extract function
values on subspaces, as illustrated here for a mixed Taylor–Hood element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">up</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
</pre></div>
</div>
<p>There is a shorthand for this, whose use is similar to <code class="docutils literal notranslate"><span class="pre">Arguments</span></code>, called
<code class="docutils literal notranslate"><span class="pre">Coefficients</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Coefficients</span><span class="p">(</span><span class="n">TH</span><span class="p">)</span>
</pre></div>
</div>
<p>Spatially constant values can conveniently be represented by
<code class="docutils literal notranslate"><span class="pre">Constant</span></code>, <code class="docutils literal notranslate"><span class="pre">VectorConstant</span></code>, and <code class="docutils literal notranslate"><span class="pre">TensorConstant</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">v0</span> <span class="o">=</span> <span class="n">VectorConstant</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">TensorConstant</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<p>These three lines are equivalent with first defining
DG0 elements and then defining a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code>
on each, illustrated here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DG0</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Discontinuous Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">DG0v</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Discontinuous Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">DG0t</span> <span class="o">=</span> <span class="n">TensorElement</span><span class="p">(</span><span class="s2">&quot;Discontinuous Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">DG0</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">DG0v</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">DG0t</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="basic-datatypes">
<h2>Basic Datatypes<a class="headerlink" href="#basic-datatypes" title="Permalink to this heading">¶</a></h2>
<p>UFL expressions can depend on some other quantities in addition to the
functions and basis functions described above.</p>
<section id="literals-and-geometric-quantities">
<h3>Literals and geometric quantities<a class="headerlink" href="#literals-and-geometric-quantities" title="Permalink to this heading">¶</a></h3>
<p>Some atomic quantities are derived from the cell.  For example, the
(global) spatial coordinates are available as a vector valued expression
<code class="docutils literal notranslate"><span class="pre">SpatialCoordinate(cell)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Linear form for a load vector with a sin(y) coefficient</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Another quantity is the (outwards pointing) facet normal <code class="docutils literal notranslate"><span class="pre">FacetNormal(cell)</span></code>.
The normal vector is only defined on the boundary, so it can’t be used
in a cell integral.</p>
<p>Example functional <code class="docutils literal notranslate"><span class="pre">M</span></code>, an integral of the normal component of a
function <code class="docutils literal notranslate"><span class="pre">g</span></code> over the boundary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>Python scalars (int, float) can be used anywhere a scalar expression
is allowed. Another literal constant type is <code class="docutils literal notranslate"><span class="pre">Identity</span></code> which
represents an <span class="math notranslate nohighlight">\(n\times n\)</span> unit matrix of given size <span class="math notranslate nohighlight">\(n\)</span>,
as in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Geometric dimension</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span>

<span class="c1"># d x d identiy matrix</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="c1"># Kronecker delta</span>
<span class="n">delta_ij</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="indexing-and-tensor-components">
<h2>Indexing and tensor components<a class="headerlink" href="#indexing-and-tensor-components" title="Permalink to this heading">¶</a></h2>
<p>UFL supports index notation, which is often a convenient way to
express forms. The basic principle of index notation is that summation
is implicit over indices repeated twice in each term of an expression.
The following examples illustrate the index notation, assuming that
each of the variables <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> has been declared as
a free <code class="docutils literal notranslate"><span class="pre">Index</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v[i]*w[i]</span></code>: <span class="math notranslate nohighlight">\(\sum_{i=0}^{n-1} v_i w_i = \mathbf{v}\cdot\mathbf{w}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dx(v,</span> <span class="pre">i)*Dx(w,</span> <span class="pre">i)</span></code>:
<span class="math notranslate nohighlight">\(\sum_{i=0}^{d-1} \frac{\partial v}{\partial x_i} \frac{\partial w}{\partial x_i}
= \nabla v \cdot \nabla w\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dx(v[i],</span> <span class="pre">i)</span></code>: <span class="math notranslate nohighlight">\(\sum_{i=0}^{d-1}
\frac{\partial v_i}{\partial x_i} = \nabla \cdot v\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dx(v[i],</span> <span class="pre">j)*Dx(w[i],</span> <span class="pre">j)</span></code>: <span class="math notranslate nohighlight">\(\sum_{i=0}^{n-1} \sum_{j=0}^{d-1}
\frac{\partial v_i}{\partial x_j} \frac{\partial w_i}{\partial x_j}
= \nabla \mathbf{v} : \nabla \mathbf{w}\)</span></p></li>
</ul>
<p>Here we will try to very briefly summarize the basic concepts of tensor
algebra and index notation, just enough to express the operators in UFL.</p>
<p>Assuming an Euclidean space in <span class="math notranslate nohighlight">\(d\)</span> dimensions with <span class="math notranslate nohighlight">\(1 \le
d \le 3\)</span>, and a set of orthonormal basis vectors <span class="math notranslate nohighlight">\(\mathbf{i}_i\)</span> for <span class="math notranslate nohighlight">\(i
\in {0, \ldots, d-1 }\)</span>, we can define the dot product of any two basis
functions as</p>
<div class="math notranslate nohighlight">
\[\mathbf{i}_{i} \cdot \mathbf{i}_{j} = \delta_{ij},\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_{ij}\)</span> is the Kronecker delta</p>
<div class="math notranslate nohighlight">
\[\begin{split}\delta_{ij}
\equiv
\begin{cases}
1, \quad i = j, \\
0, \quad \text{otherwise}.
\end{cases}\end{split}\]</div>
<p>A rank 1 tensor (vector) quantity <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> can be represented in
terms of unit vectors and its scalar components in that basis.  In tensor
algebra it is common to assume implicit summation over indices repeated
twice in a product:</p>
<div class="math notranslate nohighlight">
\[\mathbf{v} = v_k \mathbf{i}_k \equiv \sum_k v_k \mathbf{i}_k.\]</div>
<p>Similarly, a rank two tensor (matrix) quantity <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> can
be represented in terms of unit matrices, that is outer products of
unit vectors:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A} = A_{ij} \mathbf{i}_i \mathbf{i}_j \equiv \sum_i \sum_j A_{ij} \mathbf{i}_i \mathbf{i}_j .\]</div>
<p>This generalizes to tensors of arbitrary rank:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathcal{C} &amp;= C_\iota \mathbf{i}_{\iota_0} \otimes \cdots \otimes \mathbf{i}_{\iota_{r-1}} \\
 &amp;\equiv \sum_{\iota_0} \cdots \sum_{\iota_{r-1}}
 C_\iota \mathbf{i}_{\iota_0}\otimes\cdots \otimes \mathbf{i}_{\iota_{r-1}},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> is a rank <span class="math notranslate nohighlight">\(r\)</span> tensor and <span class="math notranslate nohighlight">\(\iota\)</span>
is a multi-index of length <span class="math notranslate nohighlight">\(r\)</span>.</p>
<p>When writing equations on paper, a mathematician can easily switch
between the <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(v_i\)</span> representations without
stating it explicitly. This is possible because of flexible notation
and conventions. In a programming language, we can’t use the boldface
notation which associates <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(v\)</span> by convention,
and we can’t always interpret such conventions unambiguously.  Therefore,
UFL requires that an expression is explicitly mapped from its tensor
representation (<span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>) to its component
representation (<span class="math notranslate nohighlight">\(v_i\)</span>, <span class="math notranslate nohighlight">\(A_{ij}\)</span>) and back.  This is done using
<code class="docutils literal notranslate"><span class="pre">Index</span></code> objects, the indexing operator (<code class="docutils literal notranslate"><span class="pre">v[i]</span></code>) and the function
<code class="docutils literal notranslate"><span class="pre">as_tensor</span></code>.  More details on these follow.</p>
<p>In the following descriptions of UFL operator syntax, i-l and p-s are
assumed to be predefined indices, and unless otherwise specified the name
v refers to some vector valued expression, and the name A refers to some
matrix valued expression.  The name C refers to a tensor expression of
arbitrary rank.</p>
<section id="defining-indices">
<h3>Defining indices<a class="headerlink" href="#defining-indices" title="Permalink to this heading">¶</a></h3>
<p>A set of indices <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>,
<code class="docutils literal notranslate"><span class="pre">s</span></code> are predefined, and these should be enough for many applications.
Examples will usually use these objects instead of creating new ones to
conserve space.</p>
<p>The data type <code class="docutils literal notranslate"><span class="pre">Index</span></code> represents an index used for subscripting
derivatives or taking components of non-scalar expressions.
To create indices you can either make a single one using <code class="docutils literal notranslate"><span class="pre">Index()</span></code>
or make several at once conveniently using <code class="docutils literal notranslate"><span class="pre">indices(n)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">Index</span><span class="p">()</span>
<span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Each of these represents an <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">range</span></code> determined by the context;
if used to subscript a tensor-valued expression, the range is given
by the shape of the expression, and if used to subscript a derivative,
the range is given by the dimension <span class="math notranslate nohighlight">\(d\)</span> of the underlying shape
of the finite element space.  As we shall see below, indices can be a
powerful tool when used to define forms in tensor notation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Advanced usage</p>
<p>If using UFL inside DOLFIN or another larger programming environment,
it is a good idea to define your indices explicitly just before your
form uses them, to avoid name collisions.  The definition of the
predefined indices is simply:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Advanced usage</p>
<p>Note that in the old FFC notation, the definition</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>meant that the value of the index remained constant.  This does not mean
the same in UFL, and this notation is only meant for internal usage.
Fixed indices are simply integers instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</section>
<section id="taking-components-of-tensors">
<h3>Taking components of tensors<a class="headerlink" href="#taking-components-of-tensors" title="Permalink to this heading">¶</a></h3>
<p>Basic fixed indexing of a vector valued expression v or matrix valued
expression A:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v[0]</span></code>: component access, representing the scalar value of the first
component of v</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[0,1]</span></code>: component access, representing the scalar value of the
first row, second column of A</p></li>
</ul>
<p>Basic indexing:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v[i]</span></code>: component access, representing the scalar value of some
component of v</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,j]</span></code>: component access, representing the scalar value of some
component i,j of A</p></li>
</ul>
<p>More advanced indexing:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,0]</span></code>: component access, representing the scalar value of some
component i of the first column of A</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,:]</span></code>: row access, representing some row i of A, i.e. rank(A[i,:]) == 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[:,j]</span></code>: column access, representing some column j of A,
i.e. rank(A[:,j]) == 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C[...,0]</span></code>: subtensor access, representing the subtensor of A with
the last axis fixed, e.g., A[…,0] == A[:,0]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C[j,...]</span></code>: subtensor access, representing the subtensor of A with
the first axis fixed, e.g., A[j,…] == A[j,:]</p></li>
</ul>
</section>
<section id="making-tensors-from-components">
<h3>Making tensors from components<a class="headerlink" href="#making-tensors-from-components" title="Permalink to this heading">¶</a></h3>
<p>If you have expressions for scalar components of a tensor and wish to
convert them to a tensor, there are two ways to do it. If you have a
single expression with free indices that should map to tensor axes,
like mapping <span class="math notranslate nohighlight">\(v_k\)</span> to <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> or <span class="math notranslate nohighlight">\(A_{ij}\)</span> to
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, the following examples show how this is done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vk</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">())[</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">vk</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,))</span>

<span class="n">Aij</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">v</span></code> will represent unit vector <span class="math notranslate nohighlight">\(\mathbf{i}_0\)</span>, and <code class="docutils literal notranslate"><span class="pre">A</span></code>
will represent the outer product of <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code>.</p>
<p>If you have multiple expressions without indices, you can build tensors
from them just as easily, as illustrated here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">([[</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">([[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> will represent the expressions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{v} &amp;= \mathbf{i}_0 + 2 \mathbf{i}_1 + 3 \mathbf{i}_2, \\
\mathbf{A} &amp;= \begin{bmatrix} u_0 &amp; 0 \\ 0 &amp; u_1 \end{bmatrix}, \\
\mathbf{B} &amp;= \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 2 \end{bmatrix}.\end{split}\]</div>
<p>Note that the function <code class="docutils literal notranslate"><span class="pre">as_tensor</span></code> generalizes from vectors to tensors
of arbitrary rank, while the alternative functions <code class="docutils literal notranslate"><span class="pre">as_vector</span></code> and
<code class="docutils literal notranslate"><span class="pre">as_matrix</span></code> work the same way but are only for constructing vectors
and matrices.  They are included for readability and convenience.</p>
</section>
<section id="implicit-summation">
<h3>Implicit summation<a class="headerlink" href="#implicit-summation" title="Permalink to this heading">¶</a></h3>
<p>Implicit summation can occur in only a few situations.  A product of
two terms that shares the same free index is implicitly treated as a
sum over that free index:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v[i]*v[i]</span></code>: <span class="math notranslate nohighlight">\(\sum_i v_i v_i\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,j]*v[i]*v[j]</span></code>: <span class="math notranslate nohighlight">\(\sum_j (\sum_i A_{ij} v_i) v_j\)</span></p></li>
</ul>
<p>A tensor valued expression indexed twice with the same free index is
treated as a sum over that free index:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,i]</span></code>: <span class="math notranslate nohighlight">\(\sum_i A_{ii}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C[i,j,j,i]</span></code>: <span class="math notranslate nohighlight">\(\sum_i \sum_j C_{ijji}\)</span></p></li>
</ul>
<p>The spatial derivative, in the direction of a free index, of an expression
with the same free index, is treated as a sum over that free index:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v[i].dx(i)</span></code>: <span class="math notranslate nohighlight">\(\sum_i \frac{d(v_{i})}{dx_i}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[i,j].dx(i)</span></code>: <span class="math notranslate nohighlight">\(\sum_i \frac{d(A_{ij})}{dx_i}\)</span></p></li>
</ul>
<p>Note that these examples are some times written <span class="math notranslate nohighlight">\(v_{i,i}\)</span> and
<span class="math notranslate nohighlight">\(A_{ij,i}\)</span> in pen-and-paper index notation.</p>
</section>
</section>
<section id="basic-algebraic-operators">
<h2>Basic algebraic operators<a class="headerlink" href="#basic-algebraic-operators" title="Permalink to this heading">¶</a></h2>
<p>The basic algebraic operators <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code> can be used
freely on UFL expressions. They do have some requirements on their
operands, summarized here:</p>
<p>Addition or subtraction, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span></code>:</p>
<ul class="simple">
<li><p>The operands <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same shape.</p></li>
<li><p>The operands <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same set of free indices.</p></li>
</ul>
<p>Division, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code>:</p>
<ul class="simple">
<li><p>The operand <code class="docutils literal notranslate"><span class="pre">b</span></code> must be a scalar expression.</p></li>
<li><p>The operand <code class="docutils literal notranslate"><span class="pre">b</span></code> must have no free indices.</p></li>
<li><p>The operand <code class="docutils literal notranslate"><span class="pre">a</span></code> can be non-scalar with free indices, in which division
represents scalar division of all components with the scalar <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
</ul>
<p>Multiplication, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code>:</p>
<ul class="simple">
<li><p>The only non-scalar operations allowed is scalar-tensor,
matrix-vector and matrix-matrix multiplication.</p></li>
<li><p>If either of the operands have any free indices, both must be scalar.</p></li>
<li><p>If any free indices are repeated, summation is implied.</p></li>
</ul>
</section>
<section id="basic-nonlinear-functions">
<h2>Basic nonlinear functions<a class="headerlink" href="#basic-nonlinear-functions" title="Permalink to this heading">¶</a></h2>
<p>Some basic nonlinear functions are also available, their meaning mostly
obvious.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abs(f)</span></code>: the absolute value of f.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign(f)</span></code>: the sign of f (+1 or -1).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pow(f,</span> <span class="pre">g)</span></code> or <code class="docutils literal notranslate"><span class="pre">f**g</span></code>: f to the power g, <span class="math notranslate nohighlight">\(f^g\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sqrt(f)</span></code>: square root, <span class="math notranslate nohighlight">\(\sqrt{f}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp(f)</span></code>: exponential of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ln(f)</span></code>: natural logarithm of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cos(f)</span></code>: cosine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sin(f)</span></code>: sine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tan(f)</span></code>: tangent of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cosh(f)</span></code>: hyperbolic cosine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sinh(f)</span></code>: hyperbolic sine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tanh(f)</span></code>: hyperbolic tangent of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">acos(f)</span></code>: inverse cosine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">asin(f)</span></code>: inverse sine of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atan(f)</span></code>: inverse tangent of f</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atan2(f1,</span> <span class="pre">f2)</span></code>: inverse tangent of (f1/f2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">erf(f)</span></code>: error function of f, <span class="math notranslate nohighlight">\({2\over\sqrt{\pi}} \int_0^f \exp(-t^2) \mathop{dt}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bessel_J(nu,</span> <span class="pre">f)</span></code>: Bessel function of the first kind, <span class="math notranslate nohighlight">\(J_\nu(f)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bessel_Y(nu,</span> <span class="pre">f)</span></code>: Bessel function of the second kind, <span class="math notranslate nohighlight">\(Y_\nu(f)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bessel_I(nu,</span> <span class="pre">f)</span></code>: Modified Bessel function of the first kind, <span class="math notranslate nohighlight">\(I_\nu(f)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bessel_K(nu,</span> <span class="pre">f)</span></code>: Modified Bessel function of the second kind, <span class="math notranslate nohighlight">\(K_\nu(f)\)</span></p></li>
</ul>
<p>These functions do not accept non-scalar operands or operands with free
indices or <code class="docutils literal notranslate"><span class="pre">Argument</span></code> dependencies.</p>
</section>
<section id="tensor-algebra-operators">
<h2>Tensor algebra operators<a class="headerlink" href="#tensor-algebra-operators" title="Permalink to this heading">¶</a></h2>
<section id="transpose">
<h3><code class="docutils literal notranslate"><span class="pre">transpose</span></code><a class="headerlink" href="#transpose" title="Permalink to this heading">¶</a></h3>
<p>The transpose of a matrix A can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AT</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">AT</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>
<span class="n">AT</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>The definition of the transpose is</p>
<div class="math notranslate nohighlight">
\[\mathtt{AT[i,j]} \leftrightarrow (A^{\top})_{ij} = A_{ji}\]</div>
<p>For transposing higher order tensor expressions, index notation can
be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AT</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">],</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="tr">
<h3><code class="docutils literal notranslate"><span class="pre">tr</span></code><a class="headerlink" href="#tr" title="Permalink to this heading">¶</a></h3>
<p>The trace of a matrix A is the sum of the diagonal entries.  This can
be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">tr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>The definition of the trace is</p>
<div class="math notranslate nohighlight">
\[\mathtt{tr(A)} \leftrightarrow \mathrm{tr} \mathbf{A} = A_{ii} = \sum_{i=0}^{n-1} A_{ii}.\]</div>
</section>
<section id="dot">
<h3><code class="docutils literal notranslate"><span class="pre">dot</span></code><a class="headerlink" href="#dot" title="Permalink to this heading">¶</a></h3>
<p>The dot product of two tensors a and b can be written:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># General tensors</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Vectors a and b</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># Matrices a and b</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
</pre></div>
</div>
<p>The definition of the dot product of unit vectors is (assuming an
orthonormal basis for a Euclidean space):</p>
<div class="math notranslate nohighlight">
\[\mathbf{i}_i \cdot \mathbf{i}_j = \delta_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_{ij}\)</span> is the Kronecker delta function.  The dot
product of higher order tensors follow from this, as illustrated with
the following examples.</p>
<p>An example with two vectors</p>
<div class="math notranslate nohighlight">
\[\mathbf{v} \cdot \mathbf{u} = (v_i \mathbf{i}_i) \cdot (u_j \mathbf{i}_j)
     = v_i u_j (\mathbf{i}_i \cdot \mathbf{i}_j) = v_i u_j \delta_{ij} = v_i u_i\]</div>
<p>An example with a tensor of rank two</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A} \cdot \mathbf{B}
&amp;= (A_{ij} \mathbf{i}_i \mathbf{i}_j) \cdot (B_{kl} \mathbf{i}_k \mathbf{i}_l) \\
&amp;= (A_{ij}B_{kl}) \mathbf{i}_i(\mathbf{i}_j \cdot \mathbf{i}_k) \mathbf{i}_l \\
&amp;= (A_{ij}B_{kl}\delta_{jk}) \mathbf{i}_i \mathbf{i}_l \\
&amp;= A_{ik}B_{kl} \mathbf{i}_i \mathbf{i}_l.\end{split}\]</div>
<p>This is the same as a matrix-matrix multiplication.</p>
<p>An example with a vector and a tensor of rank two</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{v} \cdot \mathbf{A}
&amp;= (v_j \mathbf{i}_j) \cdot (A_{kl} \mathbf{i}_k \mathbf{i}_l) \\
&amp;= (v_j A_{kl}) (\mathbf{i}_j \cdot \mathbf{i}_k) \mathbf{i}_l \\
&amp;= (v_j A_{kl}\delta_{jk}) \mathbf{i}_l \\
&amp;= v_k A_{kl} \mathbf{i}_l\end{split}\]</div>
<p>This is the same as a vector-matrix multiplication.</p>
<p>This generalizes to tensors of arbitrary rank:
the dot product applies to the last axis of a and the first axis of b.
The tensor rank of the product is rank(a)+rank(b)-2.</p>
</section>
<section id="inner">
<h3><code class="docutils literal notranslate"><span class="pre">inner</span></code><a class="headerlink" href="#inner" title="Permalink to this heading">¶</a></h3>
<p>The inner product is a contraction over all axes of a and b, that is the
sum of all component-wise products.  The operands must have exactly the
same dimensions.  For two vectors it is equivalent to the dot product.
Complex values are supported by UFL taking the complex conjugate of the
second operand.  This has no impact if the values are real.</p>
<p>If <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> are rank two tensors and
<span class="math notranslate nohighlight">\(\mathcal{C}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> are rank 3 tensors
their inner products are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A} : \mathbf{B}   &amp;= A_{ij} B^*_{ij}
\\
\mathcal{C} : \mathcal{D} &amp;= C_{ijk} D^*_{ijk}\end{split}\]</div>
<p>Using UFL notation, for real values, the following sets of declarations are
equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Vectors</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># Matrices</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

<span class="c1"># Rank 3 tensors</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that, in the UFL notation, <cite>dot</cite> and <cite>inner</cite> products are not equivalent
for complex values.</p>
</section>
<section id="outer">
<h3><code class="docutils literal notranslate"><span class="pre">outer</span></code><a class="headerlink" href="#outer" title="Permalink to this heading">¶</a></h3>
<p>The outer product of two tensors a and b can be written:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The general definition of the outer product of two tensors
<span class="math notranslate nohighlight">\(\mathcal{C}\)</span> of rank <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> of rank
<span class="math notranslate nohighlight">\(s\)</span> is</p>
<div class="math notranslate nohighlight">
\[\mathcal{C} \otimes \mathcal{D}
 =
 C^*_{\iota^a_0 \ldots \iota^a_{r-1}} D_{\iota^b_0 \ldots\iota^b_{s-1}}
 \mathbf{i}_{\iota^a_0}\otimes\cdots\otimes\mathbf{i}_{\iota^a_{r-2}}
 \otimes
 \mathbf{i}_{\iota^b_1} \otimes \cdots \otimes \mathbf{i}_{\iota^b_{s-1}}\]</div>
<p>For consistency with the inner product, the complex conjugate is taken of the first operand.</p>
<p>Some examples with vectors and matrices are easier to understand:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{v} \otimes \mathbf{u} = v^*_i u_j \mathbf{i}_i \mathbf{i}_j, \\
\mathbf{v} \otimes \mathbf{B} = v^*_i B_{kl} \mathbf{i}_i \mathbf{i}_k \mathbf{i}_l, \\
\mathbf{A} \otimes \mathbf{B} = A^*_{ij} B_{kl} \mathbf{i}_i \mathbf{i}_j \mathbf{i}_k \mathbf{i}_l .\end{split}\]</div>
<p>The outer product of vectors is often written simply as</p>
<div class="math notranslate nohighlight">
\[\mathbf{v} \otimes \mathbf{u} = \mathbf{v} \mathbf{u},\]</div>
<p>which is what we have done with <span class="math notranslate nohighlight">\(\mathbf{i}_i \mathbf{i}_j\)</span> above.</p>
<p>The rank of the outer product is the sum of the ranks of the operands.</p>
</section>
<section id="cross">
<h3><code class="docutils literal notranslate"><span class="pre">cross</span></code><a class="headerlink" href="#cross" title="Permalink to this heading">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">cross</span></code> accepts as arguments two logically vector-valued
expressions and returns a vector which is the cross product (vector
product) of the two vectors:</p>
<div class="math notranslate nohighlight">
\[ \mathtt{cross(v, w)} \leftrightarrow \mathbf{v} \times \mathbf{w}
= (v_1 w_2 - v_2 w_1, v_2 w_0 - v_0 w_2, v_0 w_1 - v_1 w_0)\]</div>
<p>Note that this operator is only defined for vectors of length three.</p>
</section>
<section id="det">
<h3><code class="docutils literal notranslate"><span class="pre">det</span></code><a class="headerlink" href="#det" title="Permalink to this heading">¶</a></h3>
<p>The determinant of a matrix A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="dev">
<h3><code class="docutils literal notranslate"><span class="pre">dev</span></code><a class="headerlink" href="#dev" title="Permalink to this heading">¶</a></h3>
<p>The deviatoric part of matrix A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">dev</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The definition is</p>
<div class="math notranslate nohighlight">
\[{\rm dev} \mathbf{A} = \mathbf{A} - \frac{\mathbf{A}_{ii}}{d} \mathbf{I}\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the rank of matrix A and <span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix.</p>
</section>
<section id="sym">
<h3><code class="docutils literal notranslate"><span class="pre">sym</span></code><a class="headerlink" href="#sym" title="Permalink to this heading">¶</a></h3>
<p>The symmetric part of A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">sym</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The definition is</p>
<div class="math notranslate nohighlight">
\[{\rm sym} \mathbf{A} = \frac{1}{2}(\mathbf{A} + \mathbf{A}^T)\]</div>
</section>
<section id="skew">
<h3><code class="docutils literal notranslate"><span class="pre">skew</span></code><a class="headerlink" href="#skew" title="Permalink to this heading">¶</a></h3>
<p>The skew symmetric part of A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The definition is</p>
<div class="math notranslate nohighlight">
\[{\rm skew} \mathbf{A} = \frac{1}{2}(\mathbf{A} - \mathbf{A}^T)\]</div>
</section>
<section id="cofac">
<h3><code class="docutils literal notranslate"><span class="pre">cofac</span></code><a class="headerlink" href="#cofac" title="Permalink to this heading">¶</a></h3>
<p>The cofactor of a matrix A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">cofac</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The definition is</p>
<div class="math notranslate nohighlight">
\[{\rm cofac} \mathbf{A} = \det (\mathbf{A}) \mathbf{A}^{-1}\]</div>
<p>The implementation of this is currently rather crude, with a hardcoded
symbolic expression for the cofactor.  Therefore, this is limited to 1x1,
2x2 and 3x3 matrices.</p>
</section>
<section id="inv">
<h3><code class="docutils literal notranslate"><span class="pre">inv</span></code><a class="headerlink" href="#inv" title="Permalink to this heading">¶</a></h3>
<p>The inverse of matrix A can be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ainv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of this is currently rather crude, with a hardcoded
symbolic expression for the inverse.  Therefore, this is limited to 1x1,
2x2 and 3x3 matrices.</p>
</section>
</section>
<section id="differential-operators">
<h2>Differential Operators<a class="headerlink" href="#differential-operators" title="Permalink to this heading">¶</a></h2>
<p>Three different kinds of derivatives are currently supported: spatial
derivatives, derivatives w.r.t. user defined variables, and derivatives
of a form or functional w.r.t. a function.</p>
<section id="basic-spatial-derivatives">
<h3>Basic spatial derivatives<a class="headerlink" href="#basic-spatial-derivatives" title="Permalink to this heading">¶</a></h3>
<p>Spatial derivatives hold a special physical meaning in partial differential equations
and there are several ways to express those. The basic way is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Derivative w.r.t. x_2</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Derivative w.r.t. x_i</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">v</span></code> is a scalar expression, <code class="docutils literal notranslate"><span class="pre">f</span></code> here is the scalar derivative of
<code class="docutils literal notranslate"><span class="pre">v</span></code> with respect to spatial direction <span class="math notranslate nohighlight">\(z\)</span>.  If <code class="docutils literal notranslate"><span class="pre">v</span></code> has no free indices, <code class="docutils literal notranslate"><span class="pre">g</span></code>
is the scalar derivative in spatial direction <span class="math notranslate nohighlight">\(x_i\)</span>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>
has the free index <code class="docutils literal notranslate"><span class="pre">i</span></code>.  This can be expressed compactly as <span class="math notranslate nohighlight">\(v_{,i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}f = \frac{\partial v}{\partial x_2} = v_{,2}, \\
g = \frac{\partial v}{\partial x_i} = v_{,i}.\end{split}\]</div>
<p>If the expression to be differentiated w.r.t. <span class="math notranslate nohighlight">\(x_i\)</span> has <code class="docutils literal notranslate"><span class="pre">i</span></code>
as a free-index, implicit summation is implied:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sum of derivatives w.r.t. x_i for all i</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">g</span></code> will represent the sum of derivatives
w.r.t. <span class="math notranslate nohighlight">\(x_i\)</span> for all <code class="docutils literal notranslate"><span class="pre">i</span></code>, that is</p>
<div class="math notranslate nohighlight">
\[g = \sum_i \frac{\partial v}{\partial x_i} = v_{i,i}.\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>v[i].dx(i)</cite> and <span class="math notranslate nohighlight">\(v_{i,i}\)</span> with compact notation denote implicit summation.</p>
</div>
</section>
<section id="compound-spatial-derivatives">
<h3>Compound spatial derivatives<a class="headerlink" href="#compound-spatial-derivatives" title="Permalink to this heading">¶</a></h3>
<p>UFL implements several common differential operators.  The notation is
simple and their names should be self-explanatory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Df</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">cf</span> <span class="o">=</span> <span class="n">curl</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="n">rf</span> <span class="o">=</span> <span class="n">rot</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The operand <code class="docutils literal notranslate"><span class="pre">f</span></code> can have no free indices.</p>
</section>
<section id="gradient">
<h3>Gradient<a class="headerlink" href="#gradient" title="Permalink to this heading">¶</a></h3>
<p>The gradient of a scalar <span class="math notranslate nohighlight">\(u\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathrm{grad}(u) \equiv \nabla u =
\sum_{k=0}^{d-1} \frac{\partial u}{\partial x_k} \mathbf{i}_k,\]</div>
<p>which is a vector of all spatial partial derivatives of <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>The gradient of a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathrm{grad}(\mathbf{v}) \equiv \nabla \mathbf{v}
= \frac{\partial v_i}{\partial x_j} \mathbf{i}_i \mathbf{i}_j,\]</div>
<p>which, written componentwise, reads</p>
<div class="math notranslate nohighlight">
\[\mathbf{A} = \nabla \mathbf{v}, \qquad A_{ij} = v_{i,j}\]</div>
<p>In general for a tensor <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> of rank <span class="math notranslate nohighlight">\(r\)</span> the definition is</p>
<div class="math notranslate nohighlight">
\[{\rm grad}(\mathbf{A}) \equiv \nabla \mathbf{A}
= (\frac{\partial}{\partial x_i}) (A_\iota\mathbf{i}_{\iota_0}
\otimes\cdots\otimes \mathbf{i}_{\iota_{r-1}}) \otimes \mathbf{i}_i
= \frac{\partial A_\iota}{\partial x_i} \mathbf{i}_{\iota_0}
\otimes \cdots \otimes \mathbf{i}_{\iota_{r-1}} \otimes \mathbf{i}_i,\]</div>
<p>where <span class="math notranslate nohighlight">\(\iota\)</span> is a multi-index of length <span class="math notranslate nohighlight">\(r\)</span>.</p>
<p>In UFL, the following pairs of declarations are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Dfi</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
<span class="n">Dfi</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">Dvi</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
<span class="n">Dvi</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

<span class="n">DAi</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
<span class="n">DAi</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>for a scalar expression <code class="docutils literal notranslate"><span class="pre">f</span></code>, a vector expression <code class="docutils literal notranslate"><span class="pre">v</span></code>, and a tensor
expression <code class="docutils literal notranslate"><span class="pre">A</span></code> of arbitrary rank.</p>
</section>
<section id="divergence">
<h3>Divergence<a class="headerlink" href="#divergence" title="Permalink to this heading">¶</a></h3>
<p>The divergence of any nonscalar (vector or tensor) expression <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
is defined as the contraction of the partial derivative over the last
axis of the expression.</p>
<p>The divergence of a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathrm{div}(\mathbf{v}) \equiv \nabla\cdot\mathbf{v}
= \sum_{k=0}^{d-1}\frac{\partial v_i}{\partial x_i}\]</div>
<p>In UFL, the following declarations are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dv</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="n">dv</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">dA</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">dA</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>for a vector expression v and a tensor expression A.</p>
</section>
<section id="curl-and-rot">
<h3>Curl and rot<a class="headerlink" href="#curl-and-rot" title="Permalink to this heading">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">curl</span></code> or <code class="docutils literal notranslate"><span class="pre">rot</span></code> accepts as argument a vector-valued expression
and returns its curl</p>
<div class="math notranslate nohighlight">
\[\mathrm{curl}(\mathbf{v}) = \nabla \times \mathbf{v}
  = (\frac{\partial v_2}{\partial x_1} - \frac{\partial v_1}{\partial x_2},
  \frac{\partial v_0}{\partial x_2} - \frac{\partial v_2}{\partial x_0},
  \frac{\partial v_1}{\partial x_0} - \frac{\partial v_0}{\partial x_1}).\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>curl</cite> or <cite>rot</cite> operator is only defined for vectors of length three.</p>
</div>
<p>In UFL, the following declarations are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">omega</span> <span class="o">=</span> <span class="n">curl</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="n">omega</span> <span class="o">=</span> <span class="n">rot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="variable-derivatives">
<h3>Variable derivatives<a class="headerlink" href="#variable-derivatives" title="Permalink to this heading">¶</a></h3>
<p>UFL also supports differentiation with respect to user defined
variables. A user defined variable can be any expression that is defined
as a variable.</p>
<p>The notation is illustrated here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define some arbitrary expression</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Annotate expression w as a variable that can be used by &quot;diff&quot;</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

<span class="c1"># This expression is a function of w</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># The derivative of expression F w.r.t. the variable w</span>
<span class="n">dF</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>  <span class="c1"># == 2*w</span>
</pre></div>
</div>
<p>Note that the variable <code class="docutils literal notranslate"><span class="pre">w</span></code> still represents the same expression.</p>
<p>This can be useful for example to implement material laws in
hyperelasticity where the stress tensor is derived from a Helmholtz
strain energy function.</p>
<p>Currently, UFL does not implement time in any particular way,
but differentiation w.r.t. time can be done without this support
through the use of a constant variable t:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">dfdt</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="functional-derivatives">
<h3>Functional derivatives<a class="headerlink" href="#functional-derivatives" title="Permalink to this heading">¶</a></h3>
<p>The third and final kind of derivative are derivatives of functionals
or forms w.r.t. to a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code>.  This is described in more detail in the
section <a class="reference internal" href="#ad">AD</a> about form transformations.</p>
</section>
</section>
<section id="dg-operators">
<h2>DG operators<a class="headerlink" href="#dg-operators" title="Permalink to this heading">¶</a></h2>
<p>UFL provides operators for implementation of discontinuous Galerkin
methods. These include the evaluation of the jump and average
of a function (or in general an expression) over the interior facets
(edges or faces) of a mesh.</p>
<section id="restriction-v-and-v">
<h3>Restriction: <code class="docutils literal notranslate"><span class="pre">v('+')</span></code> and <code class="docutils literal notranslate"><span class="pre">v('-')</span></code><a class="headerlink" href="#restriction-v-and-v" title="Permalink to this heading">¶</a></h3>
<p>When integrating over interior facets (<code class="docutils literal notranslate"><span class="pre">*dS</span></code>), one may restrict
expressions to the positive or negative side of the facet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Discontinuous Lagrange&quot;</span><span class="p">,</span> <span class="n">tetrahedron</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)(</span><span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span><span class="o">*</span><span class="n">dS</span>
</pre></div>
</div>
<p>Restriction may be applied to functions of any finite element space but
will only have effect when applied to expressions that are discontinuous
across facets.</p>
</section>
<section id="jump-jump-v">
<h3>Jump: <code class="docutils literal notranslate"><span class="pre">jump(v)</span></code><a class="headerlink" href="#jump-jump-v" title="Permalink to this heading">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">jump</span></code> may be used to express the jump of a
function across a common facet of two cells. Two versions of the
<code class="docutils literal notranslate"><span class="pre">jump</span></code> operator are provided.</p>
<p>If called with only one argument, then the <code class="docutils literal notranslate"><span class="pre">jump</span></code> operator
evaluates to the difference between the restrictions of the given
expression on the positive and negative sides of the facet:</p>
<div class="math notranslate nohighlight">
\[\mathtt{jump(v)} \leftrightarrow [[ v ]] = v^+ - v^-\]</div>
<p>If the expression <code class="docutils literal notranslate"><span class="pre">v</span></code> is scalar, then <code class="docutils literal notranslate"><span class="pre">jump(v)</span></code> will also be
scalar, and if <code class="docutils literal notranslate"><span class="pre">v</span></code> is vector-valued, then <code class="docutils literal notranslate"><span class="pre">jump(v)</span></code> will also be
vector-valued.</p>
<p>If called with two arguments, <code class="docutils literal notranslate"><span class="pre">jump(v,</span> <span class="pre">n)</span></code> evaluates to the
jump in <code class="docutils literal notranslate"><span class="pre">v</span></code> weighted by <code class="docutils literal notranslate"><span class="pre">n</span></code>. Typically, <code class="docutils literal notranslate"><span class="pre">n</span></code> will
be chosen to represent the unit outward normal of the facet (as seen
from each of the two neighboring cells). If <code class="docutils literal notranslate"><span class="pre">v</span></code> is scalar, then
<code class="docutils literal notranslate"><span class="pre">jump(v,</span> <span class="pre">n)</span></code> is given by</p>
<div class="math notranslate nohighlight">
\[\mathtt{jump(v, n)} \leftrightarrow [[ v ]]_n = v^+ n^+ + v^- n^-\]</div>
<p>If <code class="docutils literal notranslate"><span class="pre">v</span></code> is vector-valued, then <code class="docutils literal notranslate"><span class="pre">jump(v,</span> <span class="pre">n)</span></code> is given by</p>
<div class="math notranslate nohighlight">
\[\mathtt{jump(v, n)} \leftrightarrow [[ v ]]_n = v^+ \cdot n^+ + v^- \cdot n^-\]</div>
<p>Thus, if the expression <code class="docutils literal notranslate"><span class="pre">v</span></code> is scalar, then <code class="docutils literal notranslate"><span class="pre">jump(v,</span> <span class="pre">n)</span></code> will
be vector-valued, and if <code class="docutils literal notranslate"><span class="pre">v</span></code> is vector-valued, then <code class="docutils literal notranslate"><span class="pre">jump(v,</span> <span class="pre">n)</span></code> will be scalar.</p>
</section>
<section id="average-avg-v">
<h3>Average: <code class="docutils literal notranslate"><span class="pre">avg(v)</span></code><a class="headerlink" href="#average-avg-v" title="Permalink to this heading">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">avg</span></code> may be used to express the average
of an expression across a common facet of two cells:</p>
<div class="math notranslate nohighlight">
\[\mathtt{avg(v)} \leftrightarrow [[ v ]] = \frac{1}{2} (v^+ + v^-)\]</div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">avg(v)</span></code> has the same value shape as the expression <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</section>
</section>
<section id="conditional-operators">
<h2>Conditional Operators<a class="headerlink" href="#conditional-operators" title="Permalink to this heading">¶</a></h2>
<section id="conditional">
<h3>Conditional<a class="headerlink" href="#conditional" title="Permalink to this heading">¶</a></h3>
<p>UFL has limited support for branching, but for some PDEs it is needed.
The expression <code class="docutils literal notranslate"><span class="pre">c</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">true_value</span><span class="p">,</span> <span class="n">false_value</span><span class="p">)</span>
</pre></div>
</div>
<p>evaluates to <code class="docutils literal notranslate"><span class="pre">true_value</span></code> at run-time if <code class="docutils literal notranslate"><span class="pre">condition</span></code>
evaluates to true, or to <code class="docutils literal notranslate"><span class="pre">false_value</span></code> otherwise.</p>
<p>This corresponds to the C++ syntax <code class="docutils literal notranslate"><span class="pre">(condition</span> <span class="pre">?</span> <span class="pre">true_value:</span> <span class="pre">false_value)</span></code>,
or the Python syntax <code class="docutils literal notranslate"><span class="pre">(true_value</span> <span class="pre">if</span> <span class="pre">condition</span> <span class="pre">else</span> <span class="pre">false_value)</span></code>.</p>
</section>
<section id="conditions">
<h3>Conditions<a class="headerlink" href="#conditions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eq(a,</span> <span class="pre">b)</span></code> must be used in place of the notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ne(a,</span> <span class="pre">b)</span></code> must be used in place of the notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">le(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ge(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lt(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gt(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of details in the way Python behaves, we cannot overload
the == operator, hence these named operators.</p>
</div>
</section>
</section>
<section id="user-defined-operators">
<span id="user-defined"></span><h2>User-defined operators<a class="headerlink" href="#user-defined-operators" title="Permalink to this heading">¶</a></h2>
<p>A user may define new operators, using standard Python syntax. As an
example, consider the strain-rate operator <span class="math notranslate nohighlight">\(\epsilon\)</span> of linear elasticity,
defined by</p>
<div class="math notranslate nohighlight">
\[\epsilon(v) = \frac{1}{2} (\nabla v + (\nabla v)^{\top}).\]</div>
<p>This operator can be implemented as a function using the Python <code class="docutils literal notranslate"><span class="pre">def</span></code>
keyword:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, using the shorthand <code class="docutils literal notranslate"><span class="pre">lambda</span></code> notation, the
strain operator may be defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">epsilon</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="complex-values">
<h2>Complex values<a class="headerlink" href="#complex-values" title="Permalink to this heading">¶</a></h2>
<p>UFL supports the definition of forms over either the real or the
complex field.  Indeed, UFL does not explicitly define whether
<code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> or <code class="docutils literal notranslate"><span class="pre">Constant</span></code> are real or complex. This is instead a
matter for the form compiler to define. The complex-valued finite
element spaces supported by UFL always have a real basis but complex
coefficients. This means that <code class="docutils literal notranslate"><span class="pre">Constant</span></code> are <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> are
complex-valued, but <code class="docutils literal notranslate"><span class="pre">Argument</span></code> is real-valued.</p>
<section id="complex-operators">
<h3>Complex operators<a class="headerlink" href="#complex-operators" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">conj(f)</span></code> :: complex conjugate of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">imag(f)</span></code> :: imaginary part of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real(f)</span></code> :: real part of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></li>
</ul>
</section>
<section id="sesquilinearity">
<h3>Sesquilinearity<a class="headerlink" href="#sesquilinearity" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">inner</span></code> and <code class="docutils literal notranslate"><span class="pre">outer</span></code> are sesquilinear rather than linear
when applied to complex values. Consequently, forms with two arguments
are also sesquilinear in this case. UFL adopts the convention that
inner products take the complex conjugate of the second operand. This
is the usual convention in complex analysis but the reverse of the
usual convention in physics.</p>
</section>
<section id="complex-values-and-conditionals">
<h3>Complex values and conditionals<a class="headerlink" href="#complex-values-and-conditionals" title="Permalink to this heading">¶</a></h3>
<p>Since the field of complex numbers does not admit a well order,
complex expressions are not permissable as operands to <code class="docutils literal notranslate"><span class="pre">lt</span></code>, <code class="docutils literal notranslate"><span class="pre">gt</span></code>,
<code class="docutils literal notranslate"><span class="pre">le</span></code>, or <code class="docutils literal notranslate"><span class="pre">ge</span></code>. When compiling complex forms, the preprocessing
stage of a compiler will attempt to prove that the relevant operands
are real and will raise an exception if it is unable to do so. The
user may always explicitly use <code class="docutils literal notranslate"><span class="pre">real</span></code> (or <code class="docutils literal notranslate"><span class="pre">imag</span></code>) in order to
ensure that the operand is real.</p>
</section>
<section id="compiling-real-forms">
<h3>Compiling real forms<a class="headerlink" href="#compiling-real-forms" title="Permalink to this heading">¶</a></h3>
<p>When the compiler treats a form as real, the preprocessing stage will
discard all instances of <code class="docutils literal notranslate"><span class="pre">conj</span></code> and <code class="docutils literal notranslate"><span class="pre">real</span></code> in the form. Any
instances of <code class="docutils literal notranslate"><span class="pre">imag</span></code> or complex literal constants will cause an
exception.</p>
</section>
</section>
<section id="form-transformations">
<h2>Form Transformations<a class="headerlink" href="#form-transformations" title="Permalink to this heading">¶</a></h2>
<p>When you have defined a <code class="docutils literal notranslate"><span class="pre">Form</span></code>, you can derive new related
forms from it automatically. UFL defines a set of common
form transformations described in this section.</p>
<section id="replacing-arguments-of-a-form">
<h3>Replacing arguments of a Form<a class="headerlink" href="#replacing-arguments-of-a-form" title="Permalink to this heading">¶</a></h3>
<p>The function <code class="docutils literal notranslate"><span class="pre">replace</span></code> lets you replace terminal objects with
other values, using a mapping defined by a Python dictionary. This can be
used for example to replace a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> with a fixed value for
optimized run-time evaluation.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">{</span> <span class="n">f</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">c</span> <span class="p">})</span>
</pre></div>
</div>
<p>The replacement values must have the same basic properties as the original
values, in particular value shape and free indices.</p>
</section>
<section id="action-of-a-form-on-a-function">
<h3>Action of a form on a function<a class="headerlink" href="#action-of-a-form-on-a-function" title="Permalink to this heading">¶</a></h3>
<p>The action of a bilinear form <span class="math notranslate nohighlight">\(a\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[b(v; w) = a(v, w)\]</div>
<p>The action of a linear form <span class="math notranslate nohighlight">\(L\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[f(;w) = L(w)\]</div>
<p>This operation is implemented in UFL simply by replacing the rightmost
basis function (trial function for <cite>a</cite>, test function for <cite>L</cite>)
in a <code class="docutils literal notranslate"><span class="pre">Form</span></code>, and is used like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>To give a concrete example, these declarations are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>If a is a rank 2 form used to assemble the matrix A, L is a rank 1
form that can be used to assemble the vector <span class="math notranslate nohighlight">\(b = Ax\)</span> directly.
This can be used to define both the form of a matrix and the form of its
action without code duplication, and for the action of a Jacobi matrix
computed using derivative.</p>
<p>If L is a rank 1 form used to assemble the vector b, f is a functional
that can be used to assemble the scalar value <span class="math notranslate nohighlight">\(f = b \cdot w\)</span>
directly. This operation is sometimes used in, e.g., error control with L
being the residual equation and w being the solution to the dual problem.
(However, the discrete vector for the assembled residual equation will
typically be available, so doing the dot product using linear algebra
would be faster than using this feature.)</p>
</section>
<section id="energy-norm-of-a-bilinear-form">
<h3>Energy norm of a bilinear form<a class="headerlink" href="#energy-norm-of-a-bilinear-form" title="Permalink to this heading">¶</a></h3>
<p>The functional representing the energy norm <span class="math notranslate nohighlight">\(|v|_A = v^T A v\)</span> of
a matrix A assembled from a form <span class="math notranslate nohighlight">\(a\)</span> can be computed with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">energy_norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>which is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">action</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="adjoint-of-a-bilinear-form">
<h3>Adjoint of a bilinear form<a class="headerlink" href="#adjoint-of-a-bilinear-form" title="Permalink to this heading">¶</a></h3>
<p>The adjoint <span class="math notranslate nohighlight">\(a'\)</span> of a bilinear form <span class="math notranslate nohighlight">\(a\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[a'(u,v) = a(v,u).\]</div>
<p>This operation is implemented in UFL simply by swapping test and trial
functions in a <code class="docutils literal notranslate"><span class="pre">Form</span></code>, and is used like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aprime</span> <span class="o">=</span> <span class="n">adjoint</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="linear-and-bilinear-parts-of-a-form">
<h3>Linear and bilinear parts of a form<a class="headerlink" href="#linear-and-bilinear-parts-of-a-form" title="Permalink to this heading">¶</a></h3>
<p>Sometimes it is useful to write an equation on the format</p>
<div class="math notranslate nohighlight">
\[a(v,u) - L(v) = 0.\]</div>
<p>Before assembly, we need to extract the forms corresponding to the left
hand side and right hand side. This corresponds to extracting the bilinear and linear
terms of the form respectively, or separating the terms that depend on both a test
and a trial function on one side and the terms that depend on only a
test function on the other.</p>
<p>This is easily done in UFL using <code class="docutils literal notranslate"><span class="pre">lhs</span></code> and <code class="docutils literal notranslate"><span class="pre">rhs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">rhs</span></code> multiplies the extracted terms by -1,
corresponding to moving them from left to right, so this is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>As a slightly more complicated example, this formulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">u</span><span class="p">)))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
</section>
<section id="automatic-functional-differentiation">
<span id="ad"></span><h3>Automatic functional differentiation<a class="headerlink" href="#automatic-functional-differentiation" title="Permalink to this heading">¶</a></h3>
<p>UFL can compute derivatives of functionals or forms w.r.t. to a
<code class="docutils literal notranslate"><span class="pre">Coefficient</span></code>.  This functionality can be used for example to linearize
your nonlinear residual equation automatically, or derive a linear system
from a functional, or compute sensitivity vectors w.r.t. some coefficient.</p>
<p>A functional can be differentiated to obtain a linear form,</p>
<div class="math notranslate nohighlight">
\[F(v; w) = \frac{d}{dw} f(;w)\]</div>
<p>and a linear form can be differentiated to obtain the bilinear form
corresponding to its Jacobi matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note  that by “linear form” we only mean a form that is linear
in its test function, not in the function you differentiate with respect to.</p>
</div>
<div class="math notranslate nohighlight">
\[J(v, u; w) = \frac{d}{dw} F(v; w).\]</div>
<p>The UFL code to express this is (for a simple functional
<span class="math notranslate nohighlight">\(f(w)=\int_\Omega \frac 1 2 w^2\,dx\)</span>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>which is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Assume in the following examples that</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<p>The stiffness matrix can be computed from the functional
<span class="math notranslate nohighlight">\(\int_\Omega \nabla w : \nabla w \, dx\)</span>, by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>which is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span>
</pre></div>
</div>
<p>Note that here the basis functions are provided explicitly, which is
sometimes necessary, e.g., if part of the form is linearlized manually
as in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="n">g</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Derivatives can also be computed w.r.t. functions in mixed spaces.
Consider this example, an implementation of the harmonic map equations
using automatic differentiation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">dx</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">L</span></code> is defined as a functional with two coefficient functions
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> from separate finite element spaces.  However, <code class="docutils literal notranslate"><span class="pre">F</span></code> and
<code class="docutils literal notranslate"><span class="pre">J</span></code> become linear and bilinear forms respectively with basis functions
defined on the mixed finite element</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span>
</pre></div>
</div>
<p>There is a subtle difference between defining <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
separately and this alternative implementation
(reusing the elements <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Y</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">dx</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>The difference is that the forms here have <em>one</em> coefficient function
<code class="docutils literal notranslate"><span class="pre">u</span></code> in the mixed space, and the forms above have <em>two</em> coefficient
functions <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</section>
<section id="combining-form-transformations">
<h3>Combining form transformations<a class="headerlink" href="#combining-form-transformations" title="Permalink to this heading">¶</a></h3>
<p>Form transformations can be combined freely.  Note that, to do this,
derivatives are usually evaluated before applying (e.g.) the action of
a form, because <code class="docutils literal notranslate"><span class="pre">derivative</span></code> changes the arity of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">**</span><span class="mi">4</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">Ja</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">Jp</span> <span class="o">=</span> <span class="n">adjoint</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="n">Jpa</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">Jp</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">Jnorm</span> <span class="o">=</span> <span class="n">energy_norm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="form-files">
<h2>Form files<a class="headerlink" href="#form-files" title="Permalink to this heading">¶</a></h2>
<p>UFL forms and elements can be collected in a <em>form file</em>. Form files
are standard Python files which usually import entire UFL namespace.
Form compilers will typically execute this file with
the global UFL namespace available, and extract forms and elements
that are defined after execution.  The compilers do not compile all
forms and elements that are defined in file, but only those that
are “exported”.  A finite element with the variable name <code class="docutils literal notranslate"><span class="pre">element</span></code>
is exported by default, as are forms with the names <code class="docutils literal notranslate"><span class="pre">M</span></code>, <code class="docutils literal notranslate"><span class="pre">L</span></code>, and
<code class="docutils literal notranslate"><span class="pre">a</span></code>. The default form names are intended for a functional, linear form,
and bilinear form respectively.</p>
<p>To export multiple forms and elements or use other names, an explicit
list with the forms and elements to export can be defined. Simply write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">TH</span><span class="p">]</span>
<span class="n">forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">H1</span><span class="p">]</span>
</pre></div>
</div>
<p>at the end of the file to export the elements and forms held by these
variables.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Unified Form Language (UFL)</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-doc/ufl.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Release notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../manual.html">User manual</a><ul>
      <li>Previous: <a href="introduction.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="examples.html" title="next chapter">Example forms</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, FEniCS Project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/manual/form_language.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
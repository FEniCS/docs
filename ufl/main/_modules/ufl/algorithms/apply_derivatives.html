<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ufl.algorithms.apply_derivatives &#8212; Unified Form Language (UFL) 2023.3.0.dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=25d64d2a"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ufl.algorithms.apply_derivatives</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module contains the apply_derivatives algorithm which computes the derivatives of a form of expression.&quot;&quot;&quot;</span>

<span class="c1"># Copyright (C) 2008-2016 Martin Sandve Aln√¶s</span>
<span class="c1">#</span>
<span class="c1"># This file is part of UFL (https://www.fenicsproject.org)</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier:    LGPL-3.0-or-later</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="kn">from</span> <span class="nn">ufl.action</span> <span class="kn">import</span> <span class="n">Action</span>
<span class="kn">from</span> <span class="nn">ufl.algorithms.analysis</span> <span class="kn">import</span> <span class="n">extract_arguments</span>
<span class="kn">from</span> <span class="nn">ufl.algorithms.map_integrands</span> <span class="kn">import</span> <span class="n">map_integrand_dags</span>
<span class="kn">from</span> <span class="nn">ufl.algorithms.replace_derivative_nodes</span> <span class="kn">import</span> <span class="n">replace_derivative_nodes</span>
<span class="kn">from</span> <span class="nn">ufl.argument</span> <span class="kn">import</span> <span class="n">BaseArgument</span>
<span class="kn">from</span> <span class="nn">ufl.checks</span> <span class="kn">import</span> <span class="n">is_cellwise_constant</span>
<span class="kn">from</span> <span class="nn">ufl.classes</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Coefficient</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">,</span> <span class="n">Conj</span><span class="p">,</span> <span class="n">ConstantValue</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">,</span> <span class="n">ExprMapping</span><span class="p">,</span> <span class="n">FloatValue</span><span class="p">,</span>
                         <span class="n">FormArgument</span><span class="p">,</span> <span class="n">Grad</span><span class="p">,</span> <span class="n">Identity</span><span class="p">,</span> <span class="n">Imag</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">IndexSum</span><span class="p">,</span> <span class="n">JacobianInverse</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">,</span> <span class="n">Product</span><span class="p">,</span>
                         <span class="n">Real</span><span class="p">,</span> <span class="n">ReferenceGrad</span><span class="p">,</span> <span class="n">ReferenceValue</span><span class="p">,</span> <span class="n">SpatialCoordinate</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">ufl.constantvalue</span> <span class="kn">import</span> <span class="n">is_true_ufl_scalar</span><span class="p">,</span> <span class="n">is_ufl_scalar</span>
<span class="kn">from</span> <span class="nn">ufl.core.base_form_operator</span> <span class="kn">import</span> <span class="n">BaseFormOperator</span>
<span class="kn">from</span> <span class="nn">ufl.core.expr</span> <span class="kn">import</span> <span class="n">ufl_err_str</span>
<span class="kn">from</span> <span class="nn">ufl.core.multiindex</span> <span class="kn">import</span> <span class="n">FixedIndex</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">indices</span>
<span class="kn">from</span> <span class="nn">ufl.core.terminal</span> <span class="kn">import</span> <span class="n">Terminal</span>
<span class="kn">from</span> <span class="nn">ufl.corealg.map_dag</span> <span class="kn">import</span> <span class="n">map_expr_dag</span>
<span class="kn">from</span> <span class="nn">ufl.corealg.multifunction</span> <span class="kn">import</span> <span class="n">MultiFunction</span>
<span class="kn">from</span> <span class="nn">ufl.differentiation</span> <span class="kn">import</span> <span class="n">BaseFormCoordinateDerivative</span><span class="p">,</span> <span class="n">BaseFormOperatorDerivative</span><span class="p">,</span> <span class="n">CoordinateDerivative</span>
<span class="kn">from</span> <span class="nn">ufl.domain</span> <span class="kn">import</span> <span class="n">extract_unique_domain</span>
<span class="kn">from</span> <span class="nn">ufl.form</span> <span class="kn">import</span> <span class="n">Form</span><span class="p">,</span> <span class="n">ZeroBaseForm</span>
<span class="kn">from</span> <span class="nn">ufl.operators</span> <span class="kn">import</span> <span class="p">(</span><span class="n">bessel_I</span><span class="p">,</span> <span class="n">bessel_J</span><span class="p">,</span> <span class="n">bessel_K</span><span class="p">,</span> <span class="n">bessel_Y</span><span class="p">,</span> <span class="n">cell_avg</span><span class="p">,</span> <span class="n">conditional</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">facet_avg</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span>
                           <span class="n">sign</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">ufl.pullback</span> <span class="kn">import</span> <span class="n">CustomPullback</span><span class="p">,</span> <span class="n">PhysicalPullback</span>
<span class="kn">from</span> <span class="nn">ufl.tensors</span> <span class="kn">import</span> <span class="n">as_scalar</span><span class="p">,</span> <span class="n">as_scalars</span><span class="p">,</span> <span class="n">as_tensor</span><span class="p">,</span> <span class="n">unit_indexed_tensor</span><span class="p">,</span> <span class="n">unwrap_list_tensor</span>

<span class="c1"># TODO: Add more rulesets?</span>
<span class="c1"># - DivRuleset</span>
<span class="c1"># - CurlRuleset</span>
<span class="c1"># - ReferenceGradRuleset</span>
<span class="c1"># - ReferenceDivRuleset</span>


<div class="viewcode-block" id="GenericDerivativeRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset">[docs]</a><span class="k">class</span> <span class="nc">GenericDerivativeRuleset</span><span class="p">(</span><span class="n">MultiFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">MultiFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span> <span class="o">=</span> <span class="n">var_shape</span>

    <span class="c1"># --- Error checking for missing handlers and unexpected types</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.expr"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing differentiation handler for type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
                         <span class="s2">&quot;Have you added a new type?&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.unexpected"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.unexpected">[docs]</a>    <span class="k">def</span> <span class="nf">unexpected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error about unexpected type.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> in AD rules.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.override"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.override">[docs]</a>    <span class="k">def</span> <span class="nf">override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error about overriding.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must be overridden in specialized AD rule set.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled derivative type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, nested differentiation has failed.&quot;</span><span class="p">)</span></div>

    <span class="c1"># --- Some types just don&#39;t have any derivative, this is just to</span>
    <span class="c1"># --- make algorithm structure generic</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.non_differentiable_terminal"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.non_differentiable_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">non_differentiable_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the non-differentiated object.</span>

<span class="sd">        Labels and indices are not differentiable: it&#39;s convenient to return the non-differentiated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>
    <span class="n">label</span> <span class="o">=</span> <span class="n">non_differentiable_terminal</span>
    <span class="n">multi_index</span> <span class="o">=</span> <span class="n">non_differentiable_terminal</span>

    <span class="c1"># --- Helper functions for creating zeros with the right shapes</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.independent_terminal"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.independent_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">independent_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a zero with the right shape for terminals independent of differentiation variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.independent_operator"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.independent_operator">[docs]</a>    <span class="k">def</span> <span class="nf">independent_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a zero with the right shape and indices for operators independent of differentiation variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_free_indices</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_index_dimensions</span><span class="p">)</span></div>

    <span class="c1"># --- All derivatives need to define grad and averaging</span>

    <span class="n">grad</span> <span class="o">=</span> <span class="n">override</span>
    <span class="n">cell_avg</span> <span class="o">=</span> <span class="n">override</span>
    <span class="n">facet_avg</span> <span class="o">=</span> <span class="n">override</span>

    <span class="c1"># --- Default rules for terminals</span>

    <span class="c1"># Literals are by definition independent of any differentiation variable</span>
    <span class="n">constant_value</span> <span class="o">=</span> <span class="n">independent_terminal</span>

    <span class="c1"># Constants are independent of any differentiation</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">independent_terminal</span>

    <span class="c1"># Rules for form arguments must be specified in specialized rule set</span>
    <span class="n">form_argument</span> <span class="o">=</span> <span class="n">override</span>

    <span class="c1"># Rules for geometric quantities must be specified in specialized rule set</span>
    <span class="n">geometric_quantity</span> <span class="o">=</span> <span class="n">override</span>

    <span class="c1"># These types are currently assumed independent, but for non-affine domains</span>
    <span class="c1"># this no longer holds and we want to implement rules for them.</span>
    <span class="c1"># facet_normal = independent_terminal</span>
    <span class="c1"># spatial_coordinate = independent_terminal</span>
    <span class="c1"># cell_coordinate = independent_terminal</span>

    <span class="c1"># Measures of cell entities, assuming independent although</span>
    <span class="c1"># this will not be true for all of these for non-affine domains</span>
    <span class="c1"># cell_volume = independent_terminal</span>
    <span class="c1"># circumradius = independent_terminal</span>
    <span class="c1"># facet_area = independent_terminal</span>
    <span class="c1"># cell_surface_area = independent_terminal</span>
    <span class="c1"># min_cell_edge_length = independent_terminal</span>
    <span class="c1"># max_cell_edge_length = independent_terminal</span>
    <span class="c1"># min_facet_edge_length = independent_terminal</span>
    <span class="c1"># max_facet_edge_length = independent_terminal</span>

    <span class="c1"># Other stuff</span>
    <span class="c1"># cell_orientation = independent_terminal</span>
    <span class="c1"># quadrature_weigth = independent_terminal</span>

    <span class="c1"># These types are currently not expected to show up in AD pass.</span>
    <span class="c1"># To make some of these available to the end-user, they need to be</span>
    <span class="c1"># implemented here.</span>
    <span class="c1"># facet_coordinate = unexpected</span>
    <span class="c1"># cell_origin = unexpected</span>
    <span class="c1"># facet_origin = unexpected</span>
    <span class="c1"># cell_facet_origin = unexpected</span>
    <span class="c1"># jacobian = unexpected</span>
    <span class="c1"># jacobian_determinant = unexpected</span>
    <span class="c1"># jacobian_inverse = unexpected</span>
    <span class="c1"># facet_jacobian = unexpected</span>
    <span class="c1"># facet_jacobian_determinant = unexpected</span>
    <span class="c1"># facet_jacobian_inverse = unexpected</span>
    <span class="c1"># cell_facet_jacobian = unexpected</span>
    <span class="c1"># cell_facet_jacobian_determinant = unexpected</span>
    <span class="c1"># cell_facet_jacobian_inverse = unexpected</span>
    <span class="c1"># cell_vertices = unexpected</span>
    <span class="c1"># cell_edge_vectors = unexpected</span>
    <span class="c1"># facet_edge_vectors = unexpected</span>
    <span class="c1"># reference_cell_edge_vectors = unexpected</span>
    <span class="c1"># reference_facet_edge_vectors = unexpected</span>
    <span class="c1"># cell_normal = unexpected # TODO: Expecting rename</span>
    <span class="c1"># cell_normals = unexpected</span>
    <span class="c1"># facet_tangents = unexpected</span>
    <span class="c1"># cell_tangents = unexpected</span>
    <span class="c1"># cell_midpoint = unexpected</span>
    <span class="c1"># facet_midpoint = unexpected</span>

    <span class="c1"># --- Default rules for operators</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.variable"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.variable">[docs]</a>    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">unused_l</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">df</span></div>

    <span class="c1"># --- Indexing and component handling</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.indexed"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.indexed">[docs]</a>    <span class="k">def</span> <span class="nf">indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">):</span>  <span class="c1"># TODO: (Partially) duplicated in nesting rules</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an indexed.&quot;&quot;&quot;</span>
        <span class="c1"># Propagate zeros</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c1"># Untangle as_tensor(C[kk], jj)[ii] -&gt; C[ll] to simplify</span>
        <span class="c1"># resulting expression</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">):</span>
            <span class="n">B</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">Ap</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="n">C</span><span class="p">,</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">ufl_operands</span>
                <span class="n">kk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="n">kk</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">):</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">))</span>
                    <span class="n">Cind</span> <span class="o">=</span> <span class="p">[</span><span class="n">rep</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">]</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Cind</span><span class="p">)))</span>
                    <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">ufl_free_indices</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_free_indices</span>
                    <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span>
                    <span class="k">return</span> <span class="n">expr</span>

        <span class="c1"># Otherwise a more generic approach</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ap</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">kk</span><span class="p">))</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">kk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.list_tensor"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.list_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">list_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">dops</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a list_tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ListTensor</span><span class="p">(</span><span class="o">*</span><span class="n">dops</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.component_tensor"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.component_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">component_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a component_tensor.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ap</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">Ap</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">jj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>

    <span class="c1"># --- Algebra operators</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.index_sum"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.index_sum">[docs]</a>    <span class="k">def</span> <span class="nf">index_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Ap</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an index_sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.sum"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">da</span> <span class="o">+</span> <span class="n">db</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.product"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a product.&quot;&quot;&quot;</span>
        <span class="c1"># Even though arguments to o are scalar, da and db may be</span>
        <span class="c1"># tensor valued</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">),</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">as_scalars</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Sum</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ii</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.division"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.division">[docs]</a>    <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a division.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ufl_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not expecting nonscalar nominator&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not expecting nonscalar denominator&quot;</span><span class="p">)</span>

        <span class="c1"># do_df = 1/g</span>
        <span class="c1"># do_dg = -h/g</span>
        <span class="c1"># op = do_df*fp + do_df*gp</span>
        <span class="c1"># op = (fp - o*gp) / g</span>

        <span class="c1"># Get o and gp as scalars, multiply, then wrap as a tensor</span>
        <span class="c1"># again</span>
        <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">sgp</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
        <span class="n">o_gp</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">sgp</span>
        <span class="k">if</span> <span class="n">oi</span> <span class="ow">or</span> <span class="n">gi</span><span class="p">:</span>
            <span class="n">o_gp</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">o_gp</span><span class="p">,</span> <span class="n">oi</span> <span class="o">+</span> <span class="n">gi</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">-</span> <span class="n">o_gp</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>

        <span class="k">return</span> <span class="n">op</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.power"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.power">[docs]</a>    <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a power.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar expression f in f**g.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar expression g in f**g.&quot;</span><span class="p">)</span>

        <span class="c1"># Derivation of the general case: o = f(x)**g(x)</span>
        <span class="c1"># do/df  = g * f**(g-1) = g / f * o</span>
        <span class="c1"># do/dg  = ln(f) * f**g = ln(f) * o</span>
        <span class="c1"># do/df * df + do/dg * dg = o * (g / f * df + ln(f) * dg)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="c1"># This probably produces better results for the common</span>
            <span class="c1"># case of f**constant</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">f</span><span class="o">**</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note: This produces expressions like (1/w)*w**5 instead of w**4</span>
            <span class="c1"># op = o * (fp * g / f + gp * ln(f)) # This reuses o</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">f</span><span class="o">**</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">gp</span><span class="p">)</span>  <span class="c1"># This gives better accuracy in dolfin integration test</span>

        <span class="c1"># Example: d/dx[x**(x**3)]:</span>
        <span class="c1"># f = x</span>
        <span class="c1"># g = x**3</span>
        <span class="c1"># df = 1</span>
        <span class="c1"># dg = 3*x**2</span>
        <span class="c1"># op1 = o * (fp * g / f + gp * ln(f))</span>
        <span class="c1">#     = x**(x**3)   * (x**3/x + 3*x**2*ln(x))</span>
        <span class="c1"># op2 = f**(g-1) * (g*fp + f*ln(f)*gp)</span>
        <span class="c1">#     = x**(x**3-1) * (x**3 + x*3*x**2*ln(x))</span>

        <span class="k">return</span> <span class="n">op</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.abs"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.abs">[docs]</a>    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an abs.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="c1"># return conditional(eq(f, 0), 0, Product(sign(f), df)) abs is</span>
        <span class="c1"># not complex differentiable, so we workaround the case of a</span>
        <span class="c1"># real F in complex mode by defensively casting to real inside</span>
        <span class="c1"># the sign.</span>
        <span class="k">return</span> <span class="n">sign</span><span class="p">(</span><span class="n">Real</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">*</span> <span class="n">df</span></div>

    <span class="c1"># --- Complex algebra</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.conj"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a conj.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Conj</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.real"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.real">[docs]</a>    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a real.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Real</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.imag"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.imag">[docs]</a>    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a imag.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Imag</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

    <span class="c1"># --- Mathfunctions</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.math_function"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.math_function">[docs]</a>    <span class="k">def</span> <span class="nf">math_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a math_function.&quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Introduce a UserOperator type instead of this hack</span>
        <span class="c1"># and define user derivative() function properly</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;derivative&#39;</span><span class="p">):</span>
            <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="k">return</span> <span class="n">df</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown math function.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.sqrt"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.sqrt">[docs]</a>    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sqrt.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.exp"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an exp.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">o</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.ln"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.ln">[docs]</a>    <span class="k">def</span> <span class="nf">ln</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a ln.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="n">f</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.cos"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.cos">[docs]</a>    <span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cos.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.sin"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.sin">[docs]</a>    <span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sin.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.tan"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.tan">[docs]</a>    <span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a tan.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.cosh"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.cosh">[docs]</a>    <span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cosh.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">sinh</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.sinh"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.sinh">[docs]</a>    <span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sinh.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">cosh</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.tanh"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.tanh">[docs]</a>    <span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a tanh.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>

        <span class="k">def</span> <span class="nf">sech</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">cosh</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">sech</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.acos"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.acos">[docs]</a>    <span class="k">def</span> <span class="nf">acos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an acos.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">fp</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.asin"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.asin">[docs]</a>    <span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an asin.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.atan"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.atan">[docs]</a>    <span class="k">def</span> <span class="nf">atan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an atan.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.atan2"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.atan2">[docs]</a>    <span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an atan2.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">-</span> <span class="n">f</span> <span class="o">*</span> <span class="n">gp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">g</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.erf"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.erf">[docs]</a>    <span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an erf.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span></div>

    <span class="c1"># --- Bessel functions</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.bessel_j"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.bessel_j">[docs]</a>    <span class="k">def</span> <span class="nf">bessel_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">nup</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_j.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_J</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_J</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">bessel_J</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.bessel_y"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.bessel_y">[docs]</a>    <span class="k">def</span> <span class="nf">bessel_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">nup</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_y.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_Y</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_Y</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">bessel_Y</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.bessel_i"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.bessel_i">[docs]</a>    <span class="k">def</span> <span class="nf">bessel_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">nup</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_i.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">bessel_I</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_I</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">bessel_I</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.bessel_k"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.bessel_k">[docs]</a>    <span class="k">def</span> <span class="nf">bessel_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">nup</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_k.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_K</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_K</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">bessel_K</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span></div>

    <span class="c1"># --- Restrictions</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.restricted"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.restricted">[docs]</a>    <span class="k">def</span> <span class="nf">restricted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a restricted.&quot;&quot;&quot;</span>
        <span class="c1"># Restriction and differentiation commutes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">ConstantValue</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fp</span>  <span class="c1"># TODO: Add simplification to Restricted instead?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fp</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>  <span class="c1"># (f+-)&#39; == (f&#39;)+-</span></div>

    <span class="c1"># --- Conditionals</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.binary_condition"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.binary_condition">[docs]</a>    <span class="k">def</span> <span class="nf">binary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">dr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a binary_condition.&quot;&quot;&quot;</span>
        <span class="c1"># Should not be used anywhere...</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.not_condition"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.not_condition">[docs]</a>    <span class="k">def</span> <span class="nf">not_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a not_condition.&quot;&quot;&quot;</span>
        <span class="c1"># Should not be used anywhere...</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.conditional"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.conditional">[docs]</a>    <span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">unused_dc</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a conditional.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="c1"># Assuming dt and df have the same indices here, which</span>
            <span class="c1"># should be the case</span>
            <span class="k">return</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not placing t[1],f[1] outside, allowing arguments inside</span>
            <span class="c1"># conditionals.  This will make legacy ffc fail, but</span>
            <span class="c1"># should work with uflacs.</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">conditional</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.max_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.max_value">[docs]</a>    <span class="k">def</span> <span class="nf">max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a max_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dx max(f, g) =</span>
        <span class="c1"># f &gt; g: df/dx</span>
        <span class="c1"># f &lt; g: dg/dx</span>
        <span class="c1"># Placing df,dg outside here to avoid getting arguments inside</span>
        <span class="c1"># conditionals</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dg</span></div>

<div class="viewcode-block" id="GenericDerivativeRuleset.min_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.min_value">[docs]</a>    <span class="k">def</span> <span class="nf">min_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a min_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dx min(f, g) =</span>
        <span class="c1">#  f &lt; g: df/dx</span>
        <span class="c1">#  else: dg/dx</span>
        <span class="c1">#  Placing df,dg outside here to avoid getting arguments</span>
        <span class="c1">#  inside conditionals</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dg</span></div></div>


<div class="viewcode-block" id="GradRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset">[docs]</a><span class="k">class</span> <span class="nc">GradRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take the grad derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometric_dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_shape</span><span class="o">=</span><span class="p">(</span><span class="n">geometric_dimension</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">geometric_dimension</span><span class="p">)</span>

    <span class="c1"># --- Specialized rules for geometric quantities</span>

<div class="viewcode-block" id="GradRuleset.geometric_quantity"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.geometric_quantity">[docs]</a>    <span class="k">def</span> <span class="nf">geometric_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a geometric_quantity.</span>

<span class="sd">        Default for geometric quantities is do/dx = 0 if piecewise constant,</span>
<span class="sd">        otherwise transform derivatives to reference derivatives.</span>
<span class="sd">        Override for specific types if other behaviour is needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Do</span></div>

<div class="viewcode-block" id="GradRuleset.jacobian_inverse"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.jacobian_inverse">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a jacobian_inverse.&quot;&quot;&quot;</span>
        <span class="c1"># grad(K) == K_ji rgrad(K)_rj</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Do</span></div>

    <span class="c1"># TODO: Add more explicit geometry type handlers here, with</span>
    <span class="c1"># non-affine domains several should be non-zero.</span>

<div class="viewcode-block" id="GradRuleset.spatial_coordinate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.spatial_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">spatial_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.</span>

<span class="sd">        dx/dx = I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span></div>

<div class="viewcode-block" id="GradRuleset.cell_coordinate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.cell_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">cell_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_coordinate.</span>

<span class="sd">        dX/dx = inv(dx/dX) = inv(J) = K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Is this true for manifolds? What about orientation?</span>
        <span class="k">return</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">))</span></div>

    <span class="c1"># --- Specialized rules for form arguments</span>

<div class="viewcode-block" id="GradRuleset.base_form_operator"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.base_form_operator">[docs]</a>    <span class="k">def</span> <span class="nf">base_form_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a base_form_operator.&quot;&quot;&quot;</span>
        <span class="c1"># Push the grad through the operator is not legal in most cases:</span>
        <span class="c1">#    -&gt; Not enouth regularity for chain rule to hold!</span>
        <span class="c1"># By the time we evaluate `grad(o)`, the operator `o` will have been assembled and substituted by its output.</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="GradRuleset.coefficient"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="GradRuleset.argument"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.argument">[docs]</a>    <span class="k">def</span> <span class="nf">argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an argument.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Enable this after fixing issue#13, unless we move</span>
        <span class="c1"># simplificat ion to a separate stage?</span>
        <span class="c1"># if is_cellwise_constant(o):</span>
        <span class="c1">#     # Collapse gradient of cellwise constant function to zero</span>
        <span class="c1">#     # TODO: Missing this type</span>
        <span class="c1">#     return AnnotatedZero(o.ufl_shape + self._var_shape, arguments=(o,))</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

    <span class="c1"># --- Rules for values or derivatives in reference frame</span>

<div class="viewcode-block" id="GradRuleset.reference_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.reference_value">[docs]</a>    <span class="k">def</span> <span class="nf">reference_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="c1"># grad(o) == grad(rv(f)) -&gt; K_ji*rgrad(rv(f))_rj</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">pullback</span><span class="p">,</span> <span class="n">PhysicalPullback</span><span class="p">):</span>
            <span class="c1"># TODO: Do we need to be more careful for immersed things?</span>
            <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Do</span></div>

<div class="viewcode-block" id="GradRuleset.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="c1"># grad(o) == grad(rgrad(rv(f))) -&gt; K_ji*rgrad(rgrad(rv(f)))_rj</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">valid_operand</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_in_reference_frame_</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">JacobianInverse</span><span class="p">,</span> <span class="n">SpatialCoordinate</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_operand</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceGrad can only wrap a reference frame type!&quot;</span><span class="p">)</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Do</span></div>

    <span class="c1"># --- Nesting of gradients</span>

<div class="viewcode-block" id="GradRuleset.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.</span>

<span class="sd">        Represent grad(grad(f)) as Grad(Grad(f)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Grad</span><span class="p">,</span> <span class="n">Terminal</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a _grad.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        <span class="c1"># TODO: Not sure how to detect that gradient of f is cellwise constant.</span>
        <span class="c1">#       Can we trust element degrees?</span>
        <span class="c1"># if is_cellwise_constant(o):</span>
        <span class="c1">#     return self.terminal(o)</span>
        <span class="c1"># TODO: Maybe we can ask &quot;f.has_derivatives_of_order(n)&quot; to check</span>
        <span class="c1">#       if we should make a zero here?</span>
        <span class="c1"># 1) n = count number of Grads, get f</span>
        <span class="c1"># 2) if not f.has_derivatives(n): return zero(...)</span>

    <span class="n">cell_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span>
    <span class="n">facet_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span></div>


<div class="viewcode-block" id="grad_to_reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.grad_to_reference_grad">[docs]</a><span class="k">def</span> <span class="nf">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Relates grad(o) to reference_grad(o) using the Jacobian inverse.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: Operand</span>
<span class="sd">        K: Jacobian inverse</span>
<span class="sd">    Returns:</span>
<span class="sd">        grad(o) written in terms of reference_grad(o) and K</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">))</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># grad(o) == K_ji rgrad(o)_rj</span>
    <span class="n">Do</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)[</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="p">,)],</span> <span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">Do</span></div>


<div class="viewcode-block" id="ReferenceGradRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset">[docs]</a><span class="k">class</span> <span class="nc">ReferenceGradRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the reference grad derivative.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topological_dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                          <span class="n">var_shape</span><span class="o">=</span><span class="p">(</span><span class="n">topological_dimension</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">topological_dimension</span><span class="p">)</span>

    <span class="c1"># --- Specialized rules for geometric quantities</span>

<div class="viewcode-block" id="ReferenceGradRuleset.geometric_quantity"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.geometric_quantity">[docs]</a>    <span class="k">def</span> <span class="nf">geometric_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a geometric_quantity.</span>

<span class="sd">        dg/dX = 0 if piecewise constant, otherwise ReferenceGrad(g).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Which types does this involve? I don&#39;t think the</span>
            <span class="c1"># form compilers will handle this.</span>
            <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReferenceGradRuleset.spatial_coordinate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.spatial_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">spatial_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.</span>

<span class="sd">        dx/dX = J.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Don&#39;t convert back to J, otherwise we get in a loop</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReferenceGradRuleset.cell_coordinate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.cell_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">cell_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_coordinate.</span>

<span class="sd">        dX/dX = I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span></div>

    <span class="c1"># TODO: Add more geometry types here, with non-affine domains</span>
    <span class="c1"># several should be non-zero.</span>

    <span class="c1"># --- Specialized rules for form arguments</span>

<div class="viewcode-block" id="ReferenceGradRuleset.reference_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.reference_value">[docs]</a>    <span class="k">def</span> <span class="nf">reference_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReferenceGradRuleset.coefficient"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coefficient should be wrapped in ReferenceValue by now&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReferenceGradRuleset.argument"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.argument">[docs]</a>    <span class="k">def</span> <span class="nf">argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an argument.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument should be wrapped in ReferenceValue by now&quot;</span><span class="p">)</span></div>

    <span class="c1"># --- Nesting of gradients</span>

<div class="viewcode-block" id="ReferenceGradRuleset.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grad should have been transformed by this point, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReferenceGradRuleset.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.</span>

<span class="sd">        Represent ref_grad(ref_grad(f)) as RefGrad(RefGrad(f)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                          <span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">,</span> <span class="n">ReferenceValue</span><span class="p">,</span> <span class="n">Terminal</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

    <span class="n">cell_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span>
    <span class="n">facet_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span></div>


<div class="viewcode-block" id="VariableRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset">[docs]</a><span class="k">class</span> <span class="nc">VariableRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Differentiate with respect to a variable.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_shape</span><span class="o">=</span><span class="n">var</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ufl_free_indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Differentiation variable cannot have free indices.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a _make_identity.</span>

<span class="sd">        Creates a higher order identity tensor to represent dv/dv.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sh</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># Scalar dv/dv is scalar</span>
            <span class="k">return</span> <span class="n">FloatValue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Vector v makes dv/dv the identity matrix</span>
            <span class="k">return</span> <span class="n">Identity</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Add a type for this higher order identity?</span>
            <span class="c1"># II[i0,i1,i2,j0,j1,j2] = 1 if all((i0==j0, i1==j1, i2==j2)) else 0</span>
            <span class="c1"># Tensor v makes dv/dv some kind of higher rank identity tensor</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">ind2</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sh</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">dij</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">dij</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">*=</span> <span class="n">dij</span>
                <span class="n">ind1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
                <span class="n">ind2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span><span class="p">,)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">+</span> <span class="n">ind2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span>

    <span class="c1"># Explicitly defining dg/dw == 0</span>
    <span class="n">geometric_quantity</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

    <span class="c1"># Explicitly defining da/dw == 0</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

    <span class="c1"># def _argument(self, o):</span>
    <span class="c1">#    return AnnotatedZero(o.ufl_shape + self._var_shape, arguments=(o,))  # TODO: Missing this type</span>

<div class="viewcode-block" id="VariableRuleset.coefficient"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.</span>

<span class="sd">        df/dv = Id if v is f else 0.</span>

<span class="sd">        Note that if v = variable(f), df/dv is still 0,</span>
<span class="sd">        but if v == f, i.e. isinstance(v, Coefficient) == True,</span>
<span class="sd">        then df/dv == df/df = Id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Coefficient</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = 0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="VariableRuleset.variable"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.variable">[docs]</a>    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a variable.&quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = df</span>
            <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="VariableRuleset.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.</span>

<span class="sd">        Variable derivative of a gradient of a terminal must be 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Grad</span><span class="p">,</span> <span class="n">Terminal</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

    <span class="c1"># --- Rules for values or derivatives in reference frame</span>

<div class="viewcode-block" id="VariableRuleset.reference_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.reference_value">[docs]</a>    <span class="k">def</span> <span class="nf">reference_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dv(o) == d/dv(rv(f)) = 0 if v is not f, or rv(dv/df)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Coefficient</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">pullback</span><span class="o">.</span><span class="n">is_identity</span><span class="p">:</span>
                <span class="c1"># FIXME: This is a bit tricky, instead of Identity it is</span>
                <span class="c1">#   actually inverse(transform), or we should rather not</span>
                <span class="c1">#   convert to reference frame in the first place</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Missing implementation: To handle derivatives of rv(f) w.r.t. f for &quot;</span>
                    <span class="s2">&quot;mapped elements, rewriting to reference frame should not happen first...&quot;</span><span class="p">)</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = 0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="VariableRuleset.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.</span>

<span class="sd">        Variable derivative of a gradient of a terminal must be 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                          <span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">,</span> <span class="n">ReferenceValue</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected argument to reference_grad.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

    <span class="n">cell_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span>
    <span class="n">facet_avg</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_operator</span></div>


<div class="viewcode-block" id="GateauxDerivativeRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset">[docs]</a><span class="k">class</span> <span class="nc">GateauxDerivativeRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to expression.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](e) = d/dtau e(w+tau v)|tau=0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">pending_operations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_shape</span><span class="o">=</span><span class="p">())</span>

        <span class="c1"># Type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of coefficients.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">ExprMapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a coefficient-coefficient ExprMapping.&quot;</span><span class="p">)</span>

        <span class="c1"># The coefficient(s) to differentiate w.r.t. and the</span>
        <span class="c1"># argument(s) s.t. D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)}</span>

        <span class="c1"># Build more convenient dict {f: df/dw} for each coefficient f</span>
        <span class="c1"># where df/dw is nonzero</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">coefficient_derivatives</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span> <span class="o">=</span> <span class="p">{</span><span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]:</span> <span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)}</span>

        <span class="c1"># Record the operations delayed to the derivative expansion phase:</span>
        <span class="c1"># Example: dN(u)/du where `N` is an ExternalOperator and `u` a Coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">=</span> <span class="n">pending_operations</span>

    <span class="c1"># Explicitly defining dg/dw == 0</span>
    <span class="n">geometric_quantity</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

<div class="viewcode-block" id="GateauxDerivativeRuleset.cell_avg"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.cell_avg">[docs]</a>    <span class="k">def</span> <span class="nf">cell_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_avg.&quot;&quot;&quot;</span>
        <span class="c1"># Cell average of a single function and differentiation</span>
        <span class="c1"># commutes, D_f[v](cell_avg(f)) = cell_avg(v)</span>
        <span class="k">return</span> <span class="n">cell_avg</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.facet_avg"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.facet_avg">[docs]</a>    <span class="k">def</span> <span class="nf">facet_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a facet_avg.&quot;&quot;&quot;</span>
        <span class="c1"># Facet average of a single function and differentiation</span>
        <span class="c1"># commutes, D_f[v](facet_avg(f)) = facet_avg(v)</span>
        <span class="k">return</span> <span class="n">facet_avg</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span></div>

    <span class="c1"># Explicitly defining da/dw == 0</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

<div class="viewcode-block" id="GateauxDerivativeRuleset.coefficient"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="c1"># Define dw/dw := d/ds [w + s v] = v</span>

        <span class="c1"># Return corresponding argument if we can find o among w</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>

        <span class="c1"># Look for o among coefficient derivatives</span>
        <span class="n">dos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If o is not among coefficient derivatives, return</span>
            <span class="c1"># do/dw=0</span>
            <span class="n">do</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute do/dw_j = do/dw_h : v.</span>
            <span class="c1"># Since we may actually have a tuple of oprimes and vs in a</span>
            <span class="c1"># &#39;mixed&#39; space, sum over them all to get the complete inner</span>
            <span class="c1"># product. Using indices to define a non-compound inner product.</span>

            <span class="c1"># Example:</span>
            <span class="c1"># (f:g) -&gt; (dfdu:v):g + f:(dgdu:v)</span>
            <span class="c1"># shape(dfdu) == shape(f) + shape(v)</span>
            <span class="c1"># shape(f) == shape(g) == shape(dfdu : v)</span>

            <span class="c1"># Make sure we have a tuple to match the self._v tuple</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dos</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">dos</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos</span><span class="p">,)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got a tuple of arguments, expecting a matching tuple of coefficient derivatives.&quot;</span><span class="p">)</span>
            <span class="n">dosum</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">do</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">do</span><span class="p">)</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oi</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
                <span class="n">oi1</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[:</span><span class="n">rv</span><span class="p">]</span>
                <span class="n">oi2</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[</span><span class="n">rv</span><span class="p">:]</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">oi2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">oi1</span><span class="p">:</span>
                    <span class="n">dosum</span> <span class="o">+=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">oi1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dosum</span> <span class="o">+=</span> <span class="n">prod</span>
            <span class="k">return</span> <span class="n">dosum</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.reference_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.reference_value">[docs]</a>    <span class="k">def</span> <span class="nf">reference_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently no support for ReferenceValue in CoefficientDerivative.&quot;</span><span class="p">)</span></div>
        <span class="c1"># TODO: This is implementable for regular derivative(M(f),f,v)</span>
        <span class="c1">#       but too messy if customized coefficient derivative</span>
        <span class="c1">#       relations are given by the user.  We would only need</span>
        <span class="c1">#       this to allow the user to write</span>
        <span class="c1">#       derivative(...ReferenceValue...,...).</span>
        <span class="c1"># f, = o.ufl_operands</span>
        <span class="c1"># if not f._ufl_is_terminal_:</span>
        <span class="c1">#     raise ValueError(&quot;ReferenceValue can only wrap terminals directly.&quot;)</span>
        <span class="c1"># FIXME: check all cases like in coefficient</span>
        <span class="c1"># if f is w:</span>
        <span class="c1">#     # FIXME: requires that v is an Argument with the same element mapping!</span>
        <span class="c1">#     return ReferenceValue(v)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return self.independent_terminal(o)</span>

<div class="viewcode-block" id="GateauxDerivativeRuleset.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently no support for ReferenceGrad in CoefficientDerivative.&quot;</span><span class="p">)</span></div>
        <span class="c1"># TODO: This is implementable for regular derivative(M(f),f,v)</span>
        <span class="c1">#       but too messy if customized coefficient derivative</span>
        <span class="c1">#       relations are given by the user.  We would only need</span>
        <span class="c1">#       this to allow the user to write</span>
        <span class="c1">#       derivative(...ReferenceValue...,...).</span>

<div class="viewcode-block" id="GateauxDerivativeRuleset.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="c1"># If we hit this type, it has already been propagated to a</span>
        <span class="c1"># coefficient (or grad of a coefficient) or a base form operator, # FIXME: Assert</span>
        <span class="c1"># this!  so we need to take the gradient of the variation or</span>
        <span class="c1"># return zero.  Complications occur when dealing with</span>
        <span class="c1"># derivatives w.r.t. single components...</span>

        <span class="c1"># Figure out how many gradients are around the inner terminal</span>
        <span class="n">ngrads</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Grad</span><span class="p">):</span>
            <span class="n">o</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">ngrads</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># `grad(N)` where N is a BaseFormOperator is treated as if `N` was a Coefficient.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="n">FormArgument</span><span class="p">,</span> <span class="n">BaseFormOperator</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting gradient of a FormArgument, not </span><span class="si">{</span><span class="n">ufl_err_str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">apply_grads</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngrads</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># Find o among all w without any indexing, which makes this</span>
        <span class="c1"># easy</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v]</span>
                <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># If o is not among coefficient derivatives, return do/dw=0</span>
        <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="c1"># Analyse variation argument</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w[...] + t v]</span>
                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v[...]]</span>
                <span class="c1"># Case: d/dt [w[...] + t v[...]]</span>
                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span>
                <span class="n">vcomp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vcomp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting argument or component of argument.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">FixedIndex</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vcomp</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only fixed indices in variation.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span>

        <span class="k">def</span> <span class="nf">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">):</span>
            <span class="c1"># Apply gradients directly to argument vval, and get the</span>
            <span class="c1"># right indexed scalar component(s)</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">ngrads</span><span class="p">)</span>
            <span class="n">Dvkk</span> <span class="o">=</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">vval</span><span class="p">)[</span><span class="n">vcomp</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
            <span class="c1"># Place scalar component(s) Dvkk into the right tensor</span>
            <span class="c1"># positions</span>
            <span class="k">if</span> <span class="n">wshape</span><span class="p">:</span>
                <span class="n">Ejj</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">unit_indexed_tensor</span><span class="p">(</span><span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ejj</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">()</span>
            <span class="n">gprimeterm</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">Ejj</span> <span class="o">*</span> <span class="n">Dvkk</span><span class="p">,</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gprimeterm</span>

        <span class="c1"># Accumulate contributions from variations in different</span>
        <span class="c1"># components</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>

            <span class="c1"># -- Analyse differentiation variable coefficient -- #</span>

            <span class="c1"># Can differentiate a Form wrt a BaseFormOperator</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">FormArgument</span><span class="p">,</span> <span class="n">BaseFormOperator</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">wshape</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">ufl_shape</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                    <span class="c1"># Case: d/dt [w + t v]</span>
                    <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">):</span>
                    <span class="c1"># Case: d/dt [w + t &lt;...,v,...&gt;]</span>
                    <span class="k">for</span> <span class="n">wcomp</span><span class="p">,</span> <span class="n">vsub</span> <span class="ow">in</span> <span class="n">unwrap_list_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vsub</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                            <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">vsub</span><span class="p">)</span>
                            <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wshape</span> <span class="o">!=</span> <span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar coefficient in this branch.&quot;</span><span class="p">)</span>
                    <span class="c1"># Case: d/dt [w + t v[...]]</span>
                    <span class="n">wval</span><span class="p">,</span> <span class="n">wcomp</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="p">()</span>

                    <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span>
                                                               <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span>
                                                               <span class="n">wcomp</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>  <span class="c1"># This path is tested in unit tests, but not actually used?</span>
                <span class="c1"># Case: d/dt [w[...] + t v[...]]</span>
                <span class="c1"># Case: d/dt [w[...] + t v]</span>
                <span class="n">wval</span><span class="p">,</span> <span class="n">wcomp</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">ufl_operands</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">wval</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wval</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">FixedIndex</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wcomp</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only fixed indices in differentiation variable.&quot;</span><span class="p">)</span>
                <span class="n">wshape</span> <span class="o">=</span> <span class="n">wval</span><span class="o">.</span><span class="n">ufl_shape</span>

                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting coefficient or component of coefficient.&quot;</span><span class="p">)</span>

        <span class="c1"># FIXME: Handle other coefficient derivatives: oprimes =</span>
        <span class="c1"># self._cd.get(o)</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">oprimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oprimes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="p">:</span>
                    <span class="c1"># TODO: Make it possible to silence this message</span>
                    <span class="c1">#       in particular?  It may be good to have for</span>
                    <span class="c1">#       debugging...</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assuming d</span><span class="se">{{</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="se">}}</span><span class="s2">/d</span><span class="se">{{</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="si">}</span><span class="se">}}</span><span class="s2"> = 0.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Make sure we have a tuple to match the self._v tuple</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oprimes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">oprimes</span> <span class="o">=</span> <span class="p">(</span><span class="n">oprimes</span><span class="p">,)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oprimes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Got a tuple of arguments, expecting a&quot;</span>
                            <span class="s2">&quot; matching tuple of coefficient derivatives.&quot;</span><span class="p">)</span>

                <span class="c1"># Compute dg/dw_j = dg/dw_h : v.</span>
                <span class="c1"># Since we may actually have a tuple of oprimes and vs</span>
                <span class="c1"># in a &#39;mixed&#39; space, sum over them all to get the</span>
                <span class="c1"># complete inner product. Using indices to define a</span>
                <span class="c1"># non-compound inner product.</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">oprime</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oprimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;FIXME: Figure out how to do this with ngrads&quot;</span><span class="p">)</span>
                    <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">oprime</span><span class="p">)</span>
                    <span class="n">rv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
                    <span class="n">oi1</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[:</span><span class="o">-</span><span class="n">rv</span><span class="p">]</span>
                    <span class="n">oi2</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[</span><span class="o">-</span><span class="n">rv</span><span class="p">:]</span>
                    <span class="n">prod</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">oi2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">oi1</span><span class="p">:</span>
                        <span class="n">gprimesum</span> <span class="o">+=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">oi1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gprimesum</span> <span class="o">+=</span> <span class="n">prod</span>

        <span class="k">return</span> <span class="n">gprimesum</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.coordinate_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.coordinate_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">coordinate_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">CoordinateDerivative</span><span class="p">(</span><span class="n">map_expr_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">o</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.base_form_operator"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.base_form_operator">[docs]</a>    <span class="k">def</span> <span class="nf">base_form_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a base_form_operator.</span>

<span class="sd">        If d_coeff = 0 =&gt; BaseFormOperator&#39;s derivative is taken wrt a variable =&gt; we call the appropriate handler.</span>
<span class="sd">        Otherwise =&gt; differentiation done wrt the BaseFormOperator (dF/dN[Nhat]) =&gt; we treat o as a Coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># It also handles the non-scalar case</span>
        <span class="k">if</span> <span class="n">d_coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">o</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">d_coeff</span></div>

    <span class="c1"># -- Handlers for BaseForm objects -- #</span>

<div class="viewcode-block" id="GateauxDerivativeRuleset.cofunction"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.cofunction">[docs]</a>    <span class="k">def</span> <span class="nf">cofunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cofunction.&quot;&quot;&quot;</span>
        <span class="c1"># Same rule than for Coefficient except that we use a Coargument.</span>
        <span class="c1"># The coargument is already attached to the class (self._v)</span>
        <span class="c1"># which `self.coefficient` relies on.</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Convert ufl.Zero into ZeroBaseForm</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.coargument"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.coargument">[docs]</a>    <span class="k">def</span> <span class="nf">coargument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coargument.&quot;&quot;&quot;</span>
        <span class="c1"># Same rule than for Argument (da/dw == 0).</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Convert ufl.Zero into ZeroBaseForm</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span></div>

<div class="viewcode-block" id="GateauxDerivativeRuleset.matrix"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a matrix.&quot;&quot;&quot;</span>
        <span class="c1"># Matrix rule: D_w[v](M) = v if M == w else 0</span>
        <span class="c1"># We can&#39;t differentiate wrt a matrix so always return zero in the appropriate space</span>
        <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset">[docs]</a><span class="k">class</span> <span class="nc">BaseFormOperatorDerivativeRuleset</span><span class="p">(</span><span class="n">GateauxDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to BaseFormOperator.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](B) = d/dtau B(w+tau v)|tau=0 where B is a ufl.BaseFormOperator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">pending_operations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GateauxDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">pending_operations</span><span class="p">)</span>

<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.pending_operations_recording"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.pending_operations_recording">[docs]</a>    <span class="k">def</span> <span class="nf">pending_operations_recording</span><span class="p">(</span><span class="n">base_form_operator_handler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decorate a function to record pending operations.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_form_op</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Decorate.&quot;&quot;&quot;</span>
            <span class="c1"># Get the outer `BaseFormOperator` expression, i.e. the operator that is being differentiated.</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span><span class="o">.</span><span class="n">expression</span>
            <span class="c1"># If the base form operator we observe is different from the outer `BaseFormOperator`:</span>
            <span class="c1"># -&gt; Record that `BaseFormOperator` so that `d(expression)/d(base_form_op)` can then be computed later.</span>
            <span class="c1"># Else:</span>
            <span class="c1"># -&gt; Compute the Gateaux derivative of `base_form_ops` by calling the appropriate handler.</span>
            <span class="k">if</span> <span class="n">expression</span> <span class="o">!=</span> <span class="n">base_form_op</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base_form_op</span><span class="p">,)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">base_form_op</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">base_form_operator_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_form_op</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span></div>

<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.interpolate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.interpolate">[docs]</a>    <span class="nd">@pending_operations_recording</span>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_op</span><span class="p">,</span> <span class="n">dw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an interpolate.&quot;&quot;&quot;</span>
        <span class="c1"># Interpolate rule: D_w[v](i_op(w, v*)) = i_op(v, v*), by linearity of Interpolate!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dw</span><span class="p">:</span>
            <span class="c1"># i_op doesn&#39;t depend on w:</span>
            <span class="c1">#  -&gt; It also covers the Hessian case since Interpolate is linear,</span>
            <span class="c1">#     e.g. D_w[v](D_w[v](i_op(w, v*))) = D_w[v](i_op(v, v*)) = 0 (since w not found).</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">i_op</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i_op</span><span class="o">.</span><span class="n">_ufl_expr_reconstruct_</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">dw</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.external_operator"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.external_operator">[docs]</a>    <span class="nd">@pending_operations_recording</span>
    <span class="k">def</span> <span class="nf">external_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an external_operator.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="p">):</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dj</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">dj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">derivatives</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Handle the symbolic differentiation of external operators.</span>
                <span class="c1"># This bit returns:</span>
                <span class="c1">#</span>
                <span class="c1">#   `\sum_{i} dNdOi(..., Oi, ...; DOi(u)[v], ..., v*)`</span>
                <span class="c1">#</span>
                <span class="c1"># where we differentate wrt u, Oi is the i-th operand, N(..., Oi, ...; ..., v*) an ExternalOperator</span>
                <span class="c1"># and v the direction (Argument). dNdOi(..., Oi, ...; DOi(u)[v]) is an ExternalOperator</span>
                <span class="c1"># representing the Gateaux-derivative of N. For example:</span>
                <span class="c1">#  -&gt; From N(u) = u**2, we get `dNdu(u; uhat, v*) = 2 * u * uhat`.</span>
                <span class="n">new_args</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">argument_slots</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">df</span><span class="p">,)</span>
                <span class="n">extop</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">_ufl_expr_reconstruct_</span><span class="p">(</span><span class="o">*</span><span class="n">N</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">,</span> <span class="n">derivatives</span><span class="o">=</span><span class="n">derivatives</span><span class="p">,</span> <span class="n">argument_slots</span><span class="o">=</span><span class="n">new_args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extop</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Frechet derivative of external operators need to be provided!&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extop</span><span class="p">,)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DerivativeRuleDispatcher"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher">[docs]</a><span class="k">class</span> <span class="nc">DerivativeRuleDispatcher</span><span class="p">(</span><span class="n">MultiFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dispatch a derivative rule.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">MultiFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># caches for reuse in the dispatched transformers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Record the operations delayed to the derivative expansion phase:</span>
        <span class="c1"># Example: dN(u)/du where `N` is a BaseFormOperator and `u` a Coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">=</span> <span class="p">()</span>

<div class="viewcode-block" id="DerivativeRuleDispatcher.terminal"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.terminal">[docs]</a>    <span class="k">def</span> <span class="nf">terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a terminal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a derivative.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing derivative handler for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

    <span class="n">ufl_type</span> <span class="o">=</span> <span class="n">MultiFunction</span><span class="o">.</span><span class="n">reuse_if_untouched</span>

<div class="viewcode-block" id="DerivativeRuleDispatcher.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a grad.&quot;&quot;&quot;</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">GradRuleset</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">GradRuleset</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                            <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                            <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a reference_grad.&quot;&quot;&quot;</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">ReferenceGradRuleset</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># FIXME: Look over this and test better.</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">ReferenceGradRuleset</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                            <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                            <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.variable_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.variable_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">variable_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dummy_v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a variable_derivative.&quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">VariableRuleset</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">VariableRuleset</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                            <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                            <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.coefficient_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.coefficient_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">dummy_v</span><span class="p">,</span> <span class="n">dummy_cd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coefficient_derivative.&quot;&quot;&quot;</span>
        <span class="n">dummy</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">pending_operations</span> <span class="o">=</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="o">=</span><span class="n">cd</span><span class="p">)</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">GateauxDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">pending_operations</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">GateauxDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="c1"># We need to go through the dag first to record the pending operations</span>
        <span class="n">mapped_expr</span> <span class="o">=</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                   <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                   <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="c1"># Need to account for pending operations that have been stored in other integrands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="n">pending_operations</span>
        <span class="k">return</span> <span class="n">mapped_expr</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.base_form_operator_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.base_form_operator_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">base_form_operator_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">dummy_v</span><span class="p">,</span> <span class="n">dummy_cd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a base_form_operator_derivative.&quot;&quot;&quot;</span>
        <span class="n">dummy</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">pending_operations</span> <span class="o">=</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="o">=</span><span class="n">cd</span><span class="p">)</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">BaseFormOperatorDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">pending_operations</span><span class="o">=</span><span class="n">pending_operations</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">BaseFormOperatorDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZeroBaseForm</span><span class="p">):</span>
            <span class="n">arg</span><span class="p">,</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">arguments</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span>
            <span class="c1"># derivative(F, u, du) with `du` a Coefficient</span>
            <span class="c1"># is equivalent to taking the action of the derivative.</span>
            <span class="c1"># In that case, we don&#39;t add arguments to `ZeroBaseForm`.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">BaseArgument</span><span class="p">):</span>
                <span class="n">arguments</span> <span class="o">+=</span> <span class="p">(</span><span class="n">arg</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
        <span class="c1"># We need to go through the dag first to record the pending operations</span>
        <span class="n">mapped_expr</span> <span class="o">=</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                   <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                   <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="n">mapped_f</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mapped_f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If dN/dN needs to return an Argument in N space</span>
            <span class="c1"># with N a BaseFormOperator.</span>
            <span class="k">return</span> <span class="n">mapped_f</span>
        <span class="c1"># Need to account for pending operations that have been stored in other integrands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="n">pending_operations</span>
        <span class="k">return</span> <span class="n">mapped_expr</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.coordinate_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.coordinate_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">coordinate_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">dummy_v</span><span class="p">,</span> <span class="n">dummy_cd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">o_</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">CoordinateDerivative</span><span class="p">,</span> <span class="n">o_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">CoordinateDerivative</span><span class="p">(</span><span class="n">map_expr_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                 <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                                    <span class="n">o_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">o_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">o_</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.base_form_coordinate_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.base_form_coordinate_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">base_form_coordinate_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dummy_w</span><span class="p">,</span> <span class="n">dummy_v</span><span class="p">,</span> <span class="n">dummy_cd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a base_form_coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">o_</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">BaseFormCoordinateDerivative</span><span class="p">,</span> <span class="n">o_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">BaseFormCoordinateDerivative</span><span class="p">(</span><span class="n">map_expr_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcaches</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                         <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcaches</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                                            <span class="n">o_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">o_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">o_</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span></div>

<div class="viewcode-block" id="DerivativeRuleDispatcher.indexed"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.indexed">[docs]</a>    <span class="k">def</span> <span class="nf">indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">):</span>  <span class="c1"># TODO: (Partially) duplicated in generic rules</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to an indexed.&quot;&quot;&quot;</span>
        <span class="c1"># Reuse if untouched</span>
        <span class="k">if</span> <span class="n">Ap</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">o</span>

        <span class="c1"># Untangle as_tensor(C[kk], jj)[ii] -&gt; C[ll] to simplify</span>
        <span class="c1"># resulting expression</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">):</span>
            <span class="n">B</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">Ap</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="n">C</span><span class="p">,</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">ufl_operands</span>

                <span class="n">kk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="n">kk</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">):</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">))</span>
                    <span class="n">Cind</span> <span class="o">=</span> <span class="p">[</span><span class="n">rep</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">]</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Cind</span><span class="p">)))</span>
                    <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">ufl_free_indices</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_free_indices</span>
                    <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span>
                    <span class="k">return</span> <span class="n">expr</span>

        <span class="c1"># Otherwise a more generic approach</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ap</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">kk</span><span class="p">))</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">kk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div></div>


<div class="viewcode-block" id="BaseFormOperatorDerivativeRecorder"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRecorder">[docs]</a><span class="k">class</span> <span class="nc">BaseFormOperatorDerivativeRecorder</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A derivative recorded for a base form operator.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;base_form_ops&quot;</span><span class="p">,</span> <span class="p">())</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="p">{</span><span class="s1">&#39;arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;coefficient_derivatives&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only `arguments` and `coefficient_derivatives` are allowed as derivative arguments.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">base_form_ops</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert to a bool.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">base_form_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">der_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Derivative arguments must match when summing </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> objects.&quot;</span><span class="p">)</span>
            <span class="n">base_form_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">base_form_ops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sum of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects is not supported.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
                                                  <span class="n">base_form_ops</span><span class="o">=</span><span class="n">base_form_ops</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="c1"># Recording order doesn&#39;t matter as collected `BaseFormOperator`s are sorted later on.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_form_ops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="apply_derivatives"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.apply_derivatives">[docs]</a><span class="k">def</span> <span class="nf">apply_derivatives</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply derivatives to an expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        expression: A Form, an Expr or a BaseFormOperator to be differentiated</span>

<span class="sd">    Returns:</span>
<span class="sd">        A differentiated expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Notation: Let `var` be the thing we are differentating with respect to.</span>

    <span class="n">rules</span> <span class="o">=</span> <span class="n">DerivativeRuleDispatcher</span><span class="p">()</span>

    <span class="c1"># If we hit a base form operator (bfo), then if `var` is:</span>
    <span class="c1">#    - a BaseFormOperator ‚Üí Return `d(expression)/dw` where `w` is the coefficient produced by the bfo `var`.</span>
    <span class="c1">#    - else ‚Üí Record the bfo on the MultiFunction object and returns 0.</span>
    <span class="c1"># Example:</span>
    <span class="c1">#    ‚Üí If derivative(F(u, N(u); v), u) was taken the following line would compute `‚àÇF/‚àÇu`.</span>
    <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="n">map_integrand_dags</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>

    <span class="c1"># Get the recorded delayed operations</span>
    <span class="n">pending_operations</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">pending_operations</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pending_operations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dexpression_dvar</span>

    <span class="c1"># Don&#39;t take into account empty Forms</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">,</span> <span class="n">Form</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="o">.</span><span class="n">integrals</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="p">()</span>

    <span class="c1"># Retrieve the base form operators, var, and the argument and coefficient_derivatives for `derivative`</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">var</span>
    <span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">base_form_ops</span>
    <span class="n">der_kwargs</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">der_kwargs</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">base_form_ops</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">()):</span>
        <span class="c1"># -- Replace dexpr/dvar by dexpr/dN -- #</span>
        <span class="c1"># We don&#39;t use `apply_derivatives` since the differentiation is done via `\partial` and not `d`.</span>
        <span class="n">dexpr_dN</span> <span class="o">=</span> <span class="n">map_integrand_dags</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">replace_derivative_nodes</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">{</span><span class="n">var</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">N</span><span class="p">}))</span>
        <span class="c1"># -- Add the BaseFormOperatorDerivative node -- #</span>
        <span class="n">var_arg</span><span class="p">,</span> <span class="o">=</span> <span class="n">der_kwargs</span><span class="p">[</span><span class="s1">&#39;arguments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">der_kwargs</span><span class="p">[</span><span class="s1">&#39;coefficient_derivatives&#39;</span><span class="p">]</span>
        <span class="c1"># Not always the case since `derivative`&#39;s syntax enables one to use a Coefficient as the Gateaux direction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_arg</span><span class="p">,</span> <span class="n">BaseArgument</span><span class="p">):</span>
            <span class="c1"># Construct the argument number based on the BaseFormOperator arguments instead of naively</span>
            <span class="c1"># using `var_arg`. This is critical when BaseFormOperators are used inside 0-forms.</span>
            <span class="c1">#</span>
            <span class="c1"># Example: F = 0.5 * u** 2 * dx + 0.5 * N(u; v*)** 2 * dx</span>
            <span class="c1">#    -&gt; dFdu[vhat] = &lt;u, vhat&gt; + Action(&lt;N(u; v*), v0&gt;, dNdu(u; v1, v*))</span>
            <span class="c1"># with `vhat` a 0-numbered argument, and where `v1` and `vhat` have the same function space but</span>
            <span class="c1"># a different number. Here, applying `vhat` (`var_arg`) naively would result in `dNdu(u; vhat, v*)`,</span>
            <span class="c1"># i.e. the 2-forms `dNdu` would have two 0-numbered arguments. Instead we increment the argument number</span>
            <span class="c1"># of `vhat` to form `v1`.</span>
            <span class="n">var_arg</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_arg</span><span class="p">)(</span><span class="n">var_arg</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">(),</span> <span class="n">number</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">arguments</span><span class="p">()),</span> <span class="n">part</span><span class="o">=</span><span class="n">var_arg</span><span class="o">.</span><span class="n">part</span><span class="p">())</span>
        <span class="n">dN_dvar</span> <span class="o">=</span> <span class="n">apply_derivatives</span><span class="p">(</span><span class="n">BaseFormOperatorDerivative</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">(</span><span class="n">var_arg</span><span class="p">),</span> <span class="n">cd</span><span class="p">))</span>
        <span class="c1"># -- Sum the Action: dF/du = ‚àÇF/‚àÇu + \sum_{i=1,...} Action(‚àÇF/‚àÇNi, dNi/du) -- #</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dexpr_dN</span><span class="p">,</span> <span class="n">Form</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dexpr_dN</span><span class="o">.</span><span class="n">integrals</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># In this case: Action &lt;=&gt; ufl.action since `dN_var` has 2 arguments.</span>
            <span class="c1"># We use Action to handle the trivial case `dN_dvar` = 0.</span>
            <span class="n">dexpression_dvar</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Action</span><span class="p">(</span><span class="n">dexpr_dN</span><span class="p">,</span> <span class="n">dN_dvar</span><span class="p">),)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoordinateDerivativeRuleset"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset">[docs]</a><span class="k">class</span> <span class="nc">CoordinateDerivativeRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to expression.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
<span class="sd">    where &#39;e&#39; is a ufl form after pullback and w is a SpatialCoordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">coefficient_derivatives</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_shape</span><span class="o">=</span><span class="p">())</span>

        <span class="c1"># Type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of coefficients.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">ExprMapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a coefficient-coefficient ExprMapping.&quot;</span><span class="p">)</span>

        <span class="c1"># The coefficient(s) to differentiate w.r.t. and the</span>
        <span class="c1"># argument(s) s.t. D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)}</span>

        <span class="c1"># Build more convenient dict {f: df/dw} for each coefficient f</span>
        <span class="c1"># where df/dw is nonzero</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">coefficient_derivatives</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span> <span class="o">=</span> <span class="p">{</span><span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]:</span> <span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)}</span>

    <span class="c1"># Explicitly defining dg/dw == 0</span>
    <span class="n">geometric_quantity</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

    <span class="c1"># Explicitly defining da/dw == 0</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">GenericDerivativeRuleset</span><span class="o">.</span><span class="n">independent_terminal</span>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.coefficient"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;CoordinateDerivative of coefficient in physical space is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;CoordinateDerivative grad in physical space is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.spatial_coordinate"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.spatial_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">spatial_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.&quot;&quot;&quot;</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># d x /d x =&gt; Argument(x.function_space())</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;CoordinateDerivative found a SpatialCoordinate that is different &quot;</span>
                                      <span class="s2">&quot;from the one being differentiated.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.reference_value"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.reference_value">[docs]</a>    <span class="k">def</span> <span class="nf">reference_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="c1"># d (grad_X(...(x)) / dx =&gt; grad_X(...(Argument(x.function_space()))</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">ngrads</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ReferenceGrad</span><span class="p">):</span>
            <span class="n">o</span><span class="p">,</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">ngrads</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SpatialCoordinate</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FormArgument</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting gradient of a FormArgument, not </span><span class="si">{</span><span class="n">ufl_err_str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">apply_grads</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngrads</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># Find o among all w without any indexing, which makes this</span>
        <span class="c1"># easy</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ReferenceValue</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v]</span>
                <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleset.jacobian"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a jacobian.&quot;&quot;&quot;</span>
        <span class="c1"># d (grad_X(x))/d x =&gt; grad_X(Argument(x.function_space())</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher">[docs]</a><span class="k">class</span> <span class="nc">CoordinateDerivativeRuleDispatcher</span><span class="p">(</span><span class="n">MultiFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dispatcher.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">MultiFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.terminal"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.terminal">[docs]</a>    <span class="k">def</span> <span class="nf">terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a terminal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a derivative.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing derivative handler for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">MultiFunction</span><span class="o">.</span><span class="n">reuse_if_untouched</span>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a grad.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.reference_grad"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.reference_grad">[docs]</a>    <span class="k">def</span> <span class="nf">reference_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a reference_grad.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.coefficient_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.coefficient_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coefficient_derivative.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.coordinate_derivative"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.coordinate_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">coordinate_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ufl.algorithms</span> <span class="kn">import</span> <span class="n">extract_unique_elements</span>
        <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">extract_unique_elements</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">pullback</span><span class="p">,</span> <span class="n">CustomPullback</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;CoordinateDerivative is not supported for elements with custom pull back.&quot;</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">CoordinateDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">CoordinateDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">map_expr_dag</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vcache</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">rcache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rcache</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="apply_coordinate_derivatives"><a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.apply_coordinate_derivatives">[docs]</a><span class="k">def</span> <span class="nf">apply_coordinate_derivatives</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply coordinate derivatives to an expression.&quot;&quot;&quot;</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="n">CoordinateDerivativeRuleDispatcher</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">map_integrand_dags</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Unified Form Language (UFL)</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api-doc/ufl.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Release notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, FEniCS Project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>
<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ufl.algorithms.apply_derivatives &#8212; Unified Form Language (UFL) 2025.2.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=53f08d36"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ufl.algorithms.apply_derivatives</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Apply derivatives algorithm which computes the derivatives of a form of expression.&quot;&quot;&quot;</span>

<span class="c1"># Copyright (C) 2008-2016 Martin Sandve Aln√¶s</span>
<span class="c1">#</span>
<span class="c1"># This file is part of UFL (https://www.fenicsproject.org)</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier:    LGPL-3.0-or-later</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">singledispatchmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.action</span><span class="w"> </span><span class="kn">import</span> <span class="n">Action</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.algorithms.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_arguments</span><span class="p">,</span> <span class="n">extract_coefficients</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.algorithms.map_integrands</span><span class="w"> </span><span class="kn">import</span> <span class="n">map_integrands</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.algorithms.replace_derivative_nodes</span><span class="w"> </span><span class="kn">import</span> <span class="n">replace_derivative_nodes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.argument</span><span class="w"> </span><span class="kn">import</span> <span class="n">Argument</span><span class="p">,</span> <span class="n">BaseArgument</span><span class="p">,</span> <span class="n">Coargument</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.averaging</span><span class="w"> </span><span class="kn">import</span> <span class="n">CellAvg</span><span class="p">,</span> <span class="n">FacetAvg</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.checks</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_cellwise_constant</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.classes</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Abs</span><span class="p">,</span>
    <span class="n">CellCoordinate</span><span class="p">,</span>
    <span class="n">Coefficient</span><span class="p">,</span>
    <span class="n">Cofunction</span><span class="p">,</span>
    <span class="n">ComponentTensor</span><span class="p">,</span>
    <span class="n">Conj</span><span class="p">,</span>
    <span class="n">Constant</span><span class="p">,</span>
    <span class="n">ConstantValue</span><span class="p">,</span>
    <span class="n">Division</span><span class="p">,</span>
    <span class="n">Expr</span><span class="p">,</span>
    <span class="n">ExprList</span><span class="p">,</span>
    <span class="n">ExprMapping</span><span class="p">,</span>
    <span class="n">FacetNormal</span><span class="p">,</span>
    <span class="n">FloatValue</span><span class="p">,</span>
    <span class="n">FormArgument</span><span class="p">,</span>
    <span class="n">GeometricQuantity</span><span class="p">,</span>
    <span class="n">Grad</span><span class="p">,</span>
    <span class="n">Identity</span><span class="p">,</span>
    <span class="n">Imag</span><span class="p">,</span>
    <span class="n">Indexed</span><span class="p">,</span>
    <span class="n">IndexSum</span><span class="p">,</span>
    <span class="n">Jacobian</span><span class="p">,</span>
    <span class="n">JacobianDeterminant</span><span class="p">,</span>
    <span class="n">JacobianInverse</span><span class="p">,</span>
    <span class="n">Label</span><span class="p">,</span>
    <span class="n">ListTensor</span><span class="p">,</span>
    <span class="n">Power</span><span class="p">,</span>
    <span class="n">Product</span><span class="p">,</span>
    <span class="n">Real</span><span class="p">,</span>
    <span class="n">ReferenceGrad</span><span class="p">,</span>
    <span class="n">ReferenceValue</span><span class="p">,</span>
    <span class="n">SpatialCoordinate</span><span class="p">,</span>
    <span class="n">Sum</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">,</span>
    <span class="n">Zero</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.conditional</span><span class="w"> </span><span class="kn">import</span> <span class="n">BinaryCondition</span><span class="p">,</span> <span class="n">Conditional</span><span class="p">,</span> <span class="n">NotCondition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.constantvalue</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_true_ufl_scalar</span><span class="p">,</span> <span class="n">is_ufl_scalar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.base_form_operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseFormOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.expr</span><span class="w"> </span><span class="kn">import</span> <span class="n">ufl_err_str</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.external_operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExternalOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">Interpolate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.multiindex</span><span class="w"> </span><span class="kn">import</span> <span class="n">FixedIndex</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.core.terminal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Terminal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.corealg.dag_traverser</span><span class="w"> </span><span class="kn">import</span> <span class="n">DAGTraverser</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.differentiation</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseFormCoordinateDerivative</span><span class="p">,</span>
    <span class="n">BaseFormOperatorDerivative</span><span class="p">,</span>
    <span class="n">CoefficientDerivative</span><span class="p">,</span>
    <span class="n">CoordinateDerivative</span><span class="p">,</span>
    <span class="n">Derivative</span><span class="p">,</span>
    <span class="n">VariableDerivative</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">MeshSequence</span><span class="p">,</span> <span class="n">extract_unique_domain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.form</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseForm</span><span class="p">,</span> <span class="n">Form</span><span class="p">,</span> <span class="n">ZeroBaseForm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.mathfunctions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Acos</span><span class="p">,</span>
    <span class="n">Asin</span><span class="p">,</span>
    <span class="n">Atan</span><span class="p">,</span>
    <span class="n">Atan2</span><span class="p">,</span>
    <span class="n">BesselI</span><span class="p">,</span>
    <span class="n">BesselJ</span><span class="p">,</span>
    <span class="n">BesselK</span><span class="p">,</span>
    <span class="n">BesselY</span><span class="p">,</span>
    <span class="n">Cos</span><span class="p">,</span>
    <span class="n">Cosh</span><span class="p">,</span>
    <span class="n">Erf</span><span class="p">,</span>
    <span class="n">Exp</span><span class="p">,</span>
    <span class="n">Ln</span><span class="p">,</span>
    <span class="n">MathFunction</span><span class="p">,</span>
    <span class="n">Sin</span><span class="p">,</span>
    <span class="n">Sinh</span><span class="p">,</span>
    <span class="n">Sqrt</span><span class="p">,</span>
    <span class="n">Tan</span><span class="p">,</span>
    <span class="n">Tanh</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.matrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.operators</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">MaxValue</span><span class="p">,</span>
    <span class="n">MinValue</span><span class="p">,</span>
    <span class="n">bessel_I</span><span class="p">,</span>
    <span class="n">bessel_J</span><span class="p">,</span>
    <span class="n">bessel_K</span><span class="p">,</span>
    <span class="n">bessel_Y</span><span class="p">,</span>
    <span class="n">cell_avg</span><span class="p">,</span>
    <span class="n">conditional</span><span class="p">,</span>
    <span class="n">cos</span><span class="p">,</span>
    <span class="n">cosh</span><span class="p">,</span>
    <span class="n">exp</span><span class="p">,</span>
    <span class="n">facet_avg</span><span class="p">,</span>
    <span class="n">ln</span><span class="p">,</span>
    <span class="n">sign</span><span class="p">,</span>
    <span class="n">sin</span><span class="p">,</span>
    <span class="n">sinh</span><span class="p">,</span>
    <span class="n">sqrt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.pullback</span><span class="w"> </span><span class="kn">import</span> <span class="n">CustomPullback</span><span class="p">,</span> <span class="n">PhysicalPullback</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.restriction</span><span class="w"> </span><span class="kn">import</span> <span class="n">Restricted</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl.tensors</span><span class="w"> </span><span class="kn">import</span> <span class="n">as_scalar</span><span class="p">,</span> <span class="n">as_scalars</span><span class="p">,</span> <span class="n">as_tensor</span><span class="p">,</span> <span class="n">unit_indexed_tensor</span><span class="p">,</span> <span class="n">unwrap_list_tensor</span>

<span class="c1"># TODO: Add more rulesets?</span>
<span class="c1"># - DivRuleset</span>
<span class="c1"># - CurlRuleset</span>
<span class="c1"># - ReferenceGradRuleset</span>
<span class="c1"># - ReferenceDivRuleset</span>


<div class="viewcode-block" id="flatten_domain_element">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.flatten_domain_element">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_domain_element</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the flattened (domain, element) pairs for mixed domain problems.</span>

<span class="sd">    Args:</span>
<span class="sd">        domain: `Mesh` or `MeshSequence`.</span>
<span class="sd">        element: `FiniteElement`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Nested tuples of (domain, element) pairs; just ((domain, element),)</span>
<span class="sd">        if domain is a `Mesh` (and not a `MeshSequence`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">MeshSequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">domain</span><span class="p">,</span> <span class="n">element</span><span class="p">),)</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">sub_elements</span><span class="p">):</span>
        <span class="n">flattened</span> <span class="o">+=</span> <span class="n">flatten_domain_element</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flattened</span></div>



<div class="viewcode-block" id="GenericDerivativeRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericDerivativeRuleset</span><span class="p">(</span><span class="n">DAGTraverser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">var_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span> <span class="o">=</span> <span class="n">var_shape</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.unexpected">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.unexpected">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unexpected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error about unexpected type.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> in AD rules.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenericDerivativeRuleset.override">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.override">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error about overriding.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must be overridden in specialized AD rule set.&quot;</span>
        <span class="p">)</span></div>


    <span class="c1"># --- Some types just don&#39;t have any derivative, this is just to</span>
    <span class="c1"># --- make algorithm structure generic</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.non_differentiable_terminal">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.non_differentiable_terminal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_differentiable_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the non-differentiated object.</span>

<span class="sd">        Labels and indices are not differentiable: it&#39;s convenient to</span>
<span class="sd">        return the non-differentiated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span></div>


    <span class="c1"># --- Helper functions for creating zeros with the right shapes</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.independent_terminal">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.independent_terminal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">independent_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A zero with correct shape for terminals independent of diff. variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenericDerivativeRuleset.independent_operator">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.independent_operator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">independent_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A zero with correct shape and indices for operators independent of diff. variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_free_indices</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_index_dimensions</span><span class="p">)</span></div>


    <span class="c1"># --- Error checking for missing handlers and unexpected types</span>

<div class="viewcode-block" id="GenericDerivativeRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GenericDerivativeRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Missing differentiation handler for type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Have you added a new type?&quot;</span>
        <span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Derivative</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise error.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unhandled derivative type </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">_ufl_class_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="s2">&quot;nested differentiation has failed.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Label</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">MultiIndex</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_differentiable_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># --- All derivatives need to define grad and averaging</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellAvg</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FacetAvg</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">override</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># --- Default rules for terminals</span>

    <span class="c1"># Literals are by definition independent of any differentiation variable</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ConstantValue</span><span class="p">)</span>
    <span class="c1"># Constants are independent of any differentiation</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Constant</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># Zero may have free indices</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Zero</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># Rules for form arguments must be specified in specialized rule set</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FormArgument</span><span class="p">)</span>
    <span class="c1"># Rules for geometric quantities must be specified in specialized rule set</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">override</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># These types are currently assumed independent, but for non-affine domains</span>
    <span class="c1"># this no longer holds and we want to implement rules for them.</span>
    <span class="c1"># facet_normal = independent_terminal</span>
    <span class="c1"># spatial_coordinate = independent_terminal</span>
    <span class="c1"># cell_coordinate = independent_terminal</span>

    <span class="c1"># Measures of cell entities, assuming independent although</span>
    <span class="c1"># this will not be true for all of these for non-affine domains</span>
    <span class="c1"># cell_volume = independent_terminal</span>
    <span class="c1"># circumradius = independent_terminal</span>
    <span class="c1"># facet_area = independent_terminal</span>
    <span class="c1"># cell_surface_area = independent_terminal</span>
    <span class="c1"># min_cell_edge_length = independent_terminal</span>
    <span class="c1"># max_cell_edge_length = independent_terminal</span>
    <span class="c1"># min_facet_edge_length = independent_terminal</span>
    <span class="c1"># max_facet_edge_length = independent_terminal</span>

    <span class="c1"># Other stuff</span>
    <span class="c1"># cell_orientation = independent_terminal</span>
    <span class="c1"># quadrature_weigth = independent_terminal</span>

    <span class="c1"># These types are currently not expected to show up in AD pass.</span>
    <span class="c1"># To make some of these available to the end-user, they need to be</span>
    <span class="c1"># implemented here.</span>
    <span class="c1"># facet_coordinate = unexpected</span>
    <span class="c1"># cell_origin = unexpected</span>
    <span class="c1"># facet_origin = unexpected</span>
    <span class="c1"># cell_facet_origin = unexpected</span>
    <span class="c1"># jacobian = unexpected</span>
    <span class="c1"># jacobian_determinant = unexpected</span>
    <span class="c1"># jacobian_inverse = unexpected</span>
    <span class="c1"># facet_jacobian = unexpected</span>
    <span class="c1"># facet_jacobian_determinant = unexpected</span>
    <span class="c1"># facet_jacobian_inverse = unexpected</span>
    <span class="c1"># cell_facet_jacobian = unexpected</span>
    <span class="c1"># cell_facet_jacobian_determinant = unexpected</span>
    <span class="c1"># cell_facet_jacobian_inverse = unexpected</span>
    <span class="c1"># cell_vertices = unexpected</span>
    <span class="c1"># cell_edge_vectors = unexpected</span>
    <span class="c1"># facet_edge_vectors = unexpected</span>
    <span class="c1"># reference_cell_edge_vectors = unexpected</span>
    <span class="c1"># reference_facet_edge_vectors = unexpected</span>
    <span class="c1"># cell_normal = unexpected # TODO: Expecting rename</span>
    <span class="c1"># cell_normals = unexpected</span>
    <span class="c1"># facet_tangents = unexpected</span>
    <span class="c1"># cell_tangents = unexpected</span>
    <span class="c1"># cell_midpoint = unexpected</span>
    <span class="c1"># facet_midpoint = unexpected</span>

    <span class="c1"># --- Default rules for operators</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Variable</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a variable.&quot;&quot;&quot;</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="c1"># --- Indexing and component handling</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Indexed</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">Ap</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ii</span><span class="p">:</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an indexed.&quot;&quot;&quot;</span>
        <span class="c1"># Propagate zeros</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ap</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">kk</span><span class="p">))</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">kk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ListTensor</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a list_tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ListTensor</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">))</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ComponentTensor</span><span class="p">,</span> <span class="n">Ap</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ii</span><span class="p">:</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a component_tensor.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ap</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">Ap</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">jj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="c1"># --- Algebra operators</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">IndexSum</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Ap</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ii</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an index_sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Sum</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">da</span> <span class="o">+</span> <span class="n">db</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">da</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a product.&quot;&quot;&quot;</span>
        <span class="c1"># Even though arguments to o are scalar, da and db may be</span>
        <span class="c1"># tensor valued</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">),</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">as_scalars</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Sum</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ii</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Division</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a division.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ufl_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not expecting nonscalar nominator&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not expecting nonscalar denominator&quot;</span><span class="p">)</span>
        <span class="c1"># do_df = 1/g</span>
        <span class="c1"># do_dg = -h/g</span>
        <span class="c1"># op = do_df*fp + do_df*gp</span>
        <span class="c1"># op = (fp - o*gp) / g</span>
        <span class="c1"># Get o and gp as scalars, multiply, then wrap as a tensor</span>
        <span class="c1"># again</span>
        <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">sgp</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
        <span class="n">o_gp</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">sgp</span>
        <span class="k">if</span> <span class="n">oi</span> <span class="ow">or</span> <span class="n">gi</span><span class="p">:</span>
            <span class="n">o_gp</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">o_gp</span><span class="p">,</span> <span class="n">oi</span> <span class="o">+</span> <span class="n">gi</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">-</span> <span class="n">o_gp</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Power</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a power.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar expression f in f**g.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_true_ufl_scalar</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar expression g in f**g.&quot;</span><span class="p">)</span>
        <span class="c1"># Derivation of the general case: o = f(x)**g(x)</span>
        <span class="c1"># do/df  = g * f**(g-1) = g / f * o</span>
        <span class="c1"># do/dg  = ln(f) * f**g = ln(f) * o</span>
        <span class="c1"># do/df * df + do/dg * dg = o * (g / f * df + ln(f) * dg)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="c1"># This probably produces better results for the common</span>
            <span class="c1"># case of f**constant</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">f</span> <span class="o">**</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note: This produces expressions like (1/w)*w**5 instead of w**4</span>
            <span class="c1"># op = o * (fp * g / f + gp * ln(f)) # This reuses o</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">f</span> <span class="o">**</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">g</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="n">ln</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">gp</span>
            <span class="p">)</span>  <span class="c1"># This gives better accuracy in dolfin integration test</span>
        <span class="c1"># Example: d/dx[x**(x**3)]:</span>
        <span class="c1"># f = x</span>
        <span class="c1"># g = x**3</span>
        <span class="c1"># df = 1</span>
        <span class="c1"># dg = 3*x**2</span>
        <span class="c1"># op1 = o * (fp * g / f + gp * ln(f))</span>
        <span class="c1">#     = x**(x**3)   * (x**3/x + 3*x**2*ln(x))</span>
        <span class="c1"># op2 = f**(g-1) * (g*fp + f*ln(f)*gp)</span>
        <span class="c1">#     = x**(x**3-1) * (x**3 + x*3*x**2*ln(x))</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Abs</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an abs.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="c1"># return conditional(eq(f, 0), 0, Product(sign(f), df)) abs is</span>
        <span class="c1"># not complex differentiable, so we workaround the case of a</span>
        <span class="c1"># real F in complex mode by defensively casting to real inside</span>
        <span class="c1"># the sign.</span>
        <span class="k">return</span> <span class="n">sign</span><span class="p">(</span><span class="n">Real</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">*</span> <span class="n">df</span>

    <span class="c1"># --- Complex algebra</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Conj</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a conj.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Conj</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Real</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a real.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Real</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Imag</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a imag.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Imag</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># --- Mathfunctions</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">MathFunction</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a math_function.&quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Introduce a UserOperator type instead of this hack</span>
        <span class="c1"># and define user derivative() function properly</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;derivative&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">df</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown math function.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Sqrt</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sqrt.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Exp</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an exp.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Ln</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a ln.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="n">f</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Cos</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cos.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Sin</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sin.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Tan</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a tan.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Cosh</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cosh.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">sinh</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Sinh</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a sinh.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">cosh</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Tanh</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a tanh.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sech</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">cosh</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="n">sech</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Acos</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an acos.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">fp</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Asin</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an asin.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Atan</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an atan.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Atan2</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">gp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an atan2.&quot;&quot;&quot;</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">fp</span> <span class="o">-</span> <span class="n">f</span> <span class="o">*</span> <span class="n">gp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">g</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Erf</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an erf.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">fp</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># --- Bessel functions</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BesselJ</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">nup</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_j.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_J</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_J</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">bessel_J</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BesselY</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">nup</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_y.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_Y</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_Y</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">bessel_Y</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BesselI</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">nup</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_i.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">bessel_I</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_I</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">bessel_I</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BesselK</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">nup</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a bessel_k.&quot;&quot;&quot;</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nup</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Differentiation of bessel function w.r.t. nu is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="n">bessel_K</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_K</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">bessel_K</span><span class="p">(</span><span class="n">nu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">op</span> <span class="o">*</span> <span class="n">fp</span>

    <span class="c1"># --- Restrictions</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Restricted</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Restricted</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a restricted.&quot;&quot;&quot;</span>
        <span class="c1"># Restriction and differentiation commutes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">ConstantValue</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fp</span>  <span class="c1"># TODO: Add simplification to Restricted instead?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fp</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>  <span class="c1"># (f+-)&#39; == (f&#39;)+-</span>

    <span class="c1"># --- Conditionals</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BinaryCondition</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">BinaryCondition</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a binary_condition.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can not differentiate a binary_condition.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">NotCondition</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">NotCondition</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a not_condition.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can not differentiate a not_condition.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Conditional</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a conditional.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="c1"># Assuming dt and df have the same indices here, which</span>
            <span class="c1"># should be the case</span>
            <span class="k">return</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not placing t[1],f[1] outside, allowing arguments inside</span>
            <span class="c1"># conditionals.  This will make legacy ffc fail, but</span>
            <span class="c1"># should work with uflacs.</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">conditional</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">MaxValue</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">dg</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a max_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dx max(f, g) =</span>
        <span class="c1"># f &gt; g: df/dx</span>
        <span class="c1"># f &lt; g: dg/dx</span>
        <span class="c1"># Placing df,dg outside here to avoid getting arguments inside</span>
        <span class="c1"># conditionals</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dg</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">MinValue</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">dg</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a min_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dx min(f, g) =</span>
        <span class="c1">#  f &lt; g: df/dx</span>
        <span class="c1">#  else: dg/dx</span>
        <span class="c1">#  Placing df,dg outside here to avoid getting arguments</span>
        <span class="c1">#  inside conditionals</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dc</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dc</span><span class="p">)</span> <span class="o">*</span> <span class="n">dg</span></div>



<div class="viewcode-block" id="GradRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GradRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take the grad derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geometric_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="p">(</span><span class="n">geometric_dimension</span><span class="p">,),</span>
            <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span>
            <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span>
            <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">geometric_dimension</span><span class="p">)</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="GradRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GradRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="c1"># --- Specialized rules for geometric quantities</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a geometric_quantity.</span>

<span class="sd">        Default for geometric quantities is do/dx = 0 if piecewise constant,</span>
<span class="sd">        otherwise transform derivatives to reference derivatives.</span>
<span class="sd">        Override for specific types if other behaviour is needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Do</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">JacobianInverse</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">JacobianInverse</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a jacobian_inverse.&quot;&quot;&quot;</span>
        <span class="c1"># grad(K) == K_ji rgrad(K)_rj</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="n">Do</span> <span class="o">=</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Do</span>

    <span class="c1"># TODO: Add more explicit geometry type handlers here, with</span>
    <span class="c1"># non-affine domains several should be non-zero.</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">SpatialCoordinate</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.</span>

<span class="sd">        dx/dx = I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellCoordinate</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_coordinate.</span>

<span class="sd">        dX/dx = inv(dx/dX) = inv(J) = K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: Is this true for manifolds? What about orientation?</span>
        <span class="k">return</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

    <span class="c1"># --- Specialized rules for form arguments</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseFormOperator</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a base_form_operator.&quot;&quot;&quot;</span>
        <span class="c1"># Push the grad through the operator is not legal in most cases:</span>
        <span class="c1">#    -&gt; Not enouth regularity for chain rule to hold!</span>
        <span class="c1"># By the time we evaluate `grad(o)`, the operator `o` will have</span>
        <span class="c1"># been assembled and substituted by its output.</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coefficient</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Argument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an argument.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Enable this after fixing issue#13, unless we move</span>
        <span class="c1"># simplificat ion to a separate stage?</span>
        <span class="c1"># if is_cellwise_constant(o):</span>
        <span class="c1">#     # Collapse gradient of cellwise constant function to zero</span>
        <span class="c1">#     # TODO: Missing this type</span>
        <span class="c1">#     return AnnotatedZero(o.ufl_shape + self._var_shape, arguments=(o,))</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># --- Rules for values or derivatives in reference frame</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceValue</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ReferenceValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="c1"># grad(o) == grad(rv(f)) -&gt; K_ji*rgrad(rv(f))_rj</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">expand_mesh_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">MeshSequence</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">num_sub_elements</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">element</span><span class="o">.</span><span class="n">num_sub_elements</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Get monolithic representation of rgrad(o); o might live in a mixed space.</span>
            <span class="n">rgrad</span> <span class="o">=</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="n">ref_dim</span> <span class="o">=</span> <span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Apply K_ji(d) to the corresponding components of rgrad, store them in a list,</span>
            <span class="c1"># and put them back together at the end using as_tensor().</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dofoffset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">flatten_domain_element</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
                <span class="n">esh</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">reference_value_shape</span>
                <span class="n">ndof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">esh</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">ndof</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">pullback</span><span class="p">,</span> <span class="n">PhysicalPullback</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ref_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                            PhysicalPullback not handled for immersed domain :</span>
<span class="s2">                            reference dim (</span><span class="si">{ref_dim}</span><span class="s2">) != physical dim (self._var_shape[0])&quot;&quot;&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ref_dim</span><span class="p">):</span>
                            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgrad</span><span class="p">[(</span><span class="n">dofoffset</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="n">rdim</span><span class="p">,</span> <span class="n">gdim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span>
                    <span class="k">if</span> <span class="n">rdim</span> <span class="o">!=</span> <span class="n">ref_dim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">rdim</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">ref_dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">gdim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gdim</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="c1"># Note that rgrad[dofoffset + [0,ndof), [0,rdim)] are the components</span>
                    <span class="c1"># corresponding to (d, e).</span>
                    <span class="c1"># For each row, rgrad[dofoffset + idx, [0,rdim)], we apply</span>
                    <span class="c1"># K_ji(d)[[0,rdim), [0,gdim)].</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gdim</span><span class="p">):</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rdim</span><span class="p">):</span>
                                <span class="n">temp</span> <span class="o">+=</span> <span class="n">rgrad</span><span class="p">[(</span><span class="n">dofoffset</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="p">,)]</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">dofoffset</span> <span class="o">+=</span> <span class="n">ndof</span>
            <span class="k">return</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">pullback</span><span class="p">,</span> <span class="n">PhysicalPullback</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># TODO: Do we need to be more careful for immersed things?</span>
                <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># grad(o) == grad(rgrad(rv(f))) -&gt; K_ji*rgrad(rgrad(rv(f)))_rj</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">valid_operand</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_in_reference_frame_</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">JacobianInverse</span> <span class="o">|</span> <span class="n">SpatialCoordinate</span> <span class="o">|</span> <span class="n">Jacobian</span> <span class="o">|</span> <span class="n">JacobianDeterminant</span> <span class="o">|</span> <span class="n">FacetNormal</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_operand</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceGrad can only wrap a reference frame type!&quot;</span><span class="p">)</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">expand_mesh_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">MeshSequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_in_reference_frame_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Expecting a reference frame type&quot;</span><span class="p">)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
                <span class="p">(</span><span class="n">f</span><span class="p">,)</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">num_sub_elements</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">element</span><span class="o">.</span><span class="n">num_sub_elements</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Get monolithic representation of rgrad(o); o might live in a mixed space.</span>
            <span class="n">rgrad</span> <span class="o">=</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="n">ref_dim</span> <span class="o">=</span> <span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Apply K_ji(d) to the corresponding components of rgrad, store them in a list,</span>
            <span class="c1"># and put them back together at the end using as_tensor().</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dofoffset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">flatten_domain_element</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
                <span class="n">esh</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">reference_value_shape</span>
                <span class="n">ndof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">esh</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">ndof</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">rdim</span><span class="p">,</span> <span class="n">gdim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span>
                <span class="k">if</span> <span class="n">rdim</span> <span class="o">!=</span> <span class="n">ref_dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">rdim</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">ref_dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gdim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gdim</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Note that rgrad[dofoffset + [0,ndof), [0,rdim), [0,rdim)] are the components</span>
                <span class="c1"># corresponding to (d, e).</span>
                <span class="c1"># For each row, rgrad[dofoffset + idx, [0,rdim), [0,rdim)], we apply</span>
                <span class="c1"># K_ji(d)[[0,rdim), [0,gdim)].</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">midx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gdim</span><span class="p">):</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rdim</span><span class="p">):</span>
                                <span class="n">temp</span> <span class="o">+=</span> <span class="n">rgrad</span><span class="p">[(</span><span class="n">dofoffset</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,)</span> <span class="o">+</span> <span class="n">midx</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="p">,)]</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">dofoffset</span> <span class="o">+=</span> <span class="n">ndof</span>
            <span class="k">if</span> <span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dofoffset</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">dofoffset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rgrad</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">JacobianInverse</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

    <span class="c1"># --- Nesting of gradients</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.</span>

<span class="sd">        Represent grad(grad(f)) as Grad(Grad(f)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Grad</span> <span class="o">|</span> <span class="n">Terminal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Grad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a _grad.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        <span class="c1"># TODO: Not sure how to detect that gradient of f is cellwise constant.</span>
        <span class="c1">#       Can we trust element degrees?</span>
        <span class="c1"># if is_cellwise_constant(o):</span>
        <span class="c1">#     return self.terminal(o)</span>
        <span class="c1"># TODO: Maybe we can ask &quot;f.has_derivatives_of_order(n)&quot; to check</span>
        <span class="c1">#       if we should make a zero here?</span>
        <span class="c1"># 1) n = count number of Grads, get f</span>
        <span class="c1"># 2) if not f.has_derivatives(n): return zero(...)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellAvg</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FacetAvg</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>



<div class="viewcode-block" id="grad_to_reference_grad">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.grad_to_reference_grad">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">grad_to_reference_grad</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Relates grad(o) to reference_grad(o) using the Jacobian inverse.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: Operand</span>
<span class="sd">        K: Jacobian inverse</span>
<span class="sd">    Returns:</span>
<span class="sd">        grad(o) written in terms of reference_grad(o) and K</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">))</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># grad(o) == K_ji rgrad(o)_rj</span>
    <span class="n">Do</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)[</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="p">,)],</span> <span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">Do</span></div>



<div class="viewcode-block" id="ReferenceGradRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReferenceGradRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the reference grad derivative.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">topological_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="p">(</span><span class="n">topological_dimension</span><span class="p">,),</span>
            <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span>
            <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span>
            <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">topological_dimension</span><span class="p">)</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="ReferenceGradRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.ReferenceGradRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="c1"># --- Specialized rules for geometric quantities</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a geometric_quantity.</span>

<span class="sd">        dg/dX = 0 if piecewise constant, otherwise ReferenceGrad(g).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_cellwise_constant</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Which types does this involve? I don&#39;t think the</span>
            <span class="c1"># form compilers will handle this.</span>
            <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">SpatialCoordinate</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.</span>

<span class="sd">        dx/dX = J.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Don&#39;t convert back to J, otherwise we get in a loop</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellCoordinate</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_coordinate.</span>

<span class="sd">        dX/dX = I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>

    <span class="c1"># TODO: Add more geometry types here, with non-affine domains</span>
    <span class="c1"># several should be non-zero.</span>

    <span class="c1"># --- Specialized rules for form arguments</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceValue</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_ufl_is_terminal_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferenceValue can only wrap a terminal&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coefficient</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coefficient should be wrapped in ReferenceValue by now&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Argument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an argument.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument should be wrapped in ReferenceValue by now&quot;</span><span class="p">)</span>

    <span class="c1"># --- Nesting of gradients</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Grad should have been transformed by this point, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.</span>

<span class="sd">        Represent ref_grad(ref_grad(f)) as RefGrad(RefGrad(f)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ReferenceGrad</span> <span class="o">|</span> <span class="n">ReferenceValue</span> <span class="o">|</span> <span class="n">Terminal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellAvg</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FacetAvg</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>



<div class="viewcode-block" id="VariableRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariableRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Differentiate with respect to a variable.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">var</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">var</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ufl_free_indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Differentiation variable cannot have free indices.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_shape</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a _make_identity.</span>

<span class="sd">        Creates a higher order identity tensor to represent dv/dv.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sh</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># Scalar dv/dv is scalar</span>
            <span class="k">return</span> <span class="n">FloatValue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Vector v makes dv/dv the identity matrix</span>
            <span class="k">return</span> <span class="n">Identity</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Add a type for this higher order identity?</span>
            <span class="c1"># II[i0,i1,i2,j0,j1,j2] = 1 if all((i0==j0, i1==j1, i2==j2)) else 0</span>
            <span class="c1"># Tensor v makes dv/dv some kind of higher rank identity tensor</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">ind2</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sh</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">dij</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">dij</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">*=</span> <span class="n">dij</span>
                <span class="n">ind1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
                <span class="n">ind2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span><span class="p">,)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">+</span> <span class="n">ind2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="VariableRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.VariableRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining dg/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Argument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining da/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coefficient</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.</span>

<span class="sd">        df/dv = Id if v is f else 0.</span>

<span class="sd">        Note that if v = variable(f), df/dv is still 0,</span>
<span class="sd">        but if v == f, i.e. isinstance(v, Coefficient) == True,</span>
<span class="sd">        then df/dv == df/df = Id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Coefficient</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = 0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Variable</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a variable.&quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = df</span>
            <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.</span>

<span class="sd">        Variable derivative of a gradient of a terminal must be 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that o is a &quot;differential terminal&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Grad</span> <span class="o">|</span> <span class="n">Terminal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only grads applied to a terminal.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># --- Rules for values or derivatives in reference frame</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceValue</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="c1"># d/dv(o) == d/dv(rv(f)) = 0 if v is not f, or rv(dv/df)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Coefficient</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">pullback</span><span class="o">.</span><span class="n">is_identity</span><span class="p">:</span>
                <span class="c1"># FIXME: This is a bit tricky, instead of Identity it is</span>
                <span class="c1">#   actually inverse(transform), or we should rather not</span>
                <span class="c1">#   convert to reference frame in the first place</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Missing implementation: To handle derivatives of rv(f) w.r.t. f for &quot;</span>
                    <span class="s2">&quot;mapped elements, rewriting to reference frame should not happen first...&quot;</span>
                <span class="p">)</span>
            <span class="c1"># dv/dv = identity of rank 2*rank(v)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># df/v = 0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.</span>

<span class="sd">        Variable derivative of a gradient of a terminal must be 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellAvg</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FacetAvg</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_operator</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>



<div class="viewcode-block" id="GateauxDerivativeRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GateauxDerivativeRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to expression.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](e) = d/dtau e(w+tau v)|tau=0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coefficients</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">coefficient_derivatives</span><span class="p">:</span> <span class="n">ExprMapping</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="p">(),</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span>
        <span class="p">)</span>
        <span class="c1"># Type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of coefficients.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">ExprMapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a coefficient-coefficient ExprMapping.&quot;</span><span class="p">)</span>
        <span class="c1"># The coefficient(s) to differentiate w.r.t. and the</span>
        <span class="c1"># argument(s) s.t. D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)}</span>
        <span class="c1"># Build more convenient dict {f: df/dw} for each coefficient f</span>
        <span class="c1"># where df/dw is nonzero</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">coefficient_derivatives</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span> <span class="o">=</span> <span class="p">{</span><span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]:</span> <span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="c1"># Record the operations delayed to the derivative expansion phase:</span>
        <span class="c1"># Example: dN(u)/du where `N` is an ExternalOperator and `u` a Coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">=</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">(</span>
            <span class="n">coefficients</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span>
            <span class="n">coefficient_derivatives</span><span class="o">=</span><span class="n">coefficient_derivatives</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="GateauxDerivativeRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.GateauxDerivativeRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="c1"># --- Specialized rules for geometric quantities</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining dg/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CellAvg</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cell_avg.&quot;&quot;&quot;</span>
        <span class="c1"># Cell average of a single function and differentiation</span>
        <span class="c1"># commutes, D_f[v](cell_avg(f)) = cell_avg(v)</span>
        <span class="k">return</span> <span class="n">cell_avg</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FacetAvg</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a facet_avg.&quot;&quot;&quot;</span>
        <span class="c1"># Facet average of a single function and differentiation</span>
        <span class="c1"># commutes, D_f[v](facet_avg(f)) = facet_avg(v)</span>
        <span class="k">return</span> <span class="n">facet_avg</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Argument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Argument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining da/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_argument</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Argument</span> <span class="o">|</span> <span class="n">Coargument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coefficient</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Coefficient</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_coefficient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an Expr or a BaseForm.&quot;&quot;&quot;</span>
        <span class="c1"># Define dw/dw := d/ds [w + s v] = v</span>

        <span class="c1"># Return corresponding argument if we can find o among w</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>

        <span class="c1"># Look for o among coefficient derivatives</span>
        <span class="n">dos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">dos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If o is not among coefficient derivatives, return</span>
            <span class="c1"># do/dw=0</span>
            <span class="n">do</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute do/dw_j = do/dw_h : v.</span>
            <span class="c1"># Since we may actually have a tuple of oprimes and vs in a</span>
            <span class="c1"># &#39;mixed&#39; space, sum over them all to get the complete inner</span>
            <span class="c1"># product. Using indices to define a non-compound inner product.</span>

            <span class="c1"># Example:</span>
            <span class="c1"># (f:g) -&gt; (dfdu:v):g + f:(dgdu:v)</span>
            <span class="c1"># shape(dfdu) == shape(f) + shape(v)</span>
            <span class="c1"># shape(f) == shape(g) == shape(dfdu : v)</span>

            <span class="c1"># Make sure we have a tuple to match the self._v tuple</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dos</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">dos</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos</span><span class="p">,)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Got a tuple of arguments, expecting a &quot;</span>
                    <span class="s2">&quot;matching tuple of coefficient derivatives.&quot;</span>
                <span class="p">)</span>
            <span class="n">dosum</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">do</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">do</span><span class="p">)</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oi</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
                <span class="n">oi1</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[:</span><span class="n">rv</span><span class="p">]</span>
                <span class="n">oi2</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[</span><span class="n">rv</span><span class="p">:]</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">oi2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">oi1</span><span class="p">:</span>
                    <span class="n">dosum</span> <span class="o">+=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">oi1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dosum</span> <span class="o">+=</span> <span class="n">prod</span>
            <span class="k">return</span> <span class="n">dosum</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceValue</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Currently no support for ReferenceValue in CoefficientDerivative.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># TODO: This is implementable for regular derivative(M(f),f,v)</span>
        <span class="c1">#       but too messy if customized coefficient derivative</span>
        <span class="c1">#       relations are given by the user.  We would only need</span>
        <span class="c1">#       this to allow the user to write</span>
        <span class="c1">#       derivative(...ReferenceValue...,...).</span>
        <span class="c1"># f, = o.ufl_operands</span>
        <span class="c1"># if not f._ufl_is_terminal_:</span>
        <span class="c1">#     raise ValueError(&quot;ReferenceValue can only wrap terminals directly.&quot;)</span>
        <span class="c1"># FIXME: check all cases like in coefficient</span>
        <span class="c1"># if f is w:</span>
        <span class="c1">#     # FIXME: requires that v is an Argument with the same element mapping!</span>
        <span class="c1">#     return ReferenceValue(v)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return self.independent_terminal(o)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extract_coefficients</span><span class="p">(</span><span class="n">o</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Currently no support for ReferenceGrad in CoefficientDerivative.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
        <span class="c1"># TODO: This is implementable for regular derivative(M(f),f,v)</span>
        <span class="c1">#       but too messy if customized coefficient derivative</span>
        <span class="c1">#       relations are given by the user.  We would only need</span>
        <span class="c1">#       this to allow the user to write</span>
        <span class="c1">#       derivative(...ReferenceValue...,...).</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="c1"># If we hit this type, it has already been propagated to a</span>
        <span class="c1"># coefficient (or grad of a coefficient) or a base form operator, # FIXME: Assert</span>
        <span class="c1"># this!  so we need to take the gradient of the variation or</span>
        <span class="c1"># return zero.  Complications occur when dealing with</span>
        <span class="c1"># derivatives w.r.t. single components...</span>

        <span class="c1"># Figure out how many gradients are around the inner terminal</span>
        <span class="n">ngrads</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Grad</span><span class="p">):</span>
            <span class="p">(</span><span class="n">o</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">ngrads</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># `grad(N)` where N is a BaseFormOperator is treated as if `N` was a Coefficient.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">FormArgument</span> <span class="o">|</span> <span class="n">BaseFormOperator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting gradient of a FormArgument, not </span><span class="si">{</span><span class="n">ufl_err_str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">apply_grads</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngrads</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">Grad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># Find o among all w without any indexing, which makes this</span>
        <span class="c1"># easy</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v]</span>
                <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># If o is not among coefficient derivatives, return do/dw=0</span>
        <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="c1"># Analyse variation argument</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w[...] + t v]</span>
                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v[...]]</span>
                <span class="c1"># Case: d/dt [w[...] + t v[...]]</span>
                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span>
                <span class="n">vcomp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vcomp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting argument or component of argument.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">FixedIndex</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vcomp</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only fixed indices in variation.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">):</span>
            <span class="c1"># Apply gradients directly to argument vval, and get the</span>
            <span class="c1"># right indexed scalar component(s)</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">ngrads</span><span class="p">)</span>
            <span class="n">Dvkk</span> <span class="o">=</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">vval</span><span class="p">)[</span><span class="n">vcomp</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
            <span class="c1"># Place scalar component(s) Dvkk into the right tensor</span>
            <span class="c1"># positions</span>
            <span class="k">if</span> <span class="n">wshape</span><span class="p">:</span>
                <span class="n">Ejj</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">unit_indexed_tensor</span><span class="p">(</span><span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ejj</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">()</span>
            <span class="n">gprimeterm</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">Ejj</span> <span class="o">*</span> <span class="n">Dvkk</span><span class="p">,</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gprimeterm</span>

        <span class="c1"># Accumulate contributions from variations in different</span>
        <span class="c1"># components</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="c1"># -- Analyse differentiation variable coefficient -- #</span>

            <span class="c1"># Can differentiate a Form wrt a BaseFormOperator</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">FormArgument</span> <span class="o">|</span> <span class="n">BaseFormOperator</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">wshape</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">ufl_shape</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">):</span>
                    <span class="c1"># Case: d/dt [w + t v]</span>
                    <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">):</span>
                    <span class="c1"># Case: d/dt [w + t &lt;...,v,...&gt;]</span>
                    <span class="k">for</span> <span class="n">wcomp</span><span class="p">,</span> <span class="n">vsub</span> <span class="ow">in</span> <span class="n">unwrap_list_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vsub</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                            <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">vsub</span><span class="p">)</span>
                            <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span>
                                <span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span>
                            <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                    <span class="k">pass</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wshape</span> <span class="o">!=</span> <span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting scalar coefficient in this branch.&quot;</span><span class="p">)</span>
                    <span class="c1"># Case: d/dt [w + t v[...]]</span>
                    <span class="n">wval</span><span class="p">,</span> <span class="n">wcomp</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="p">()</span>

                    <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">Indexed</span>
            <span class="p">):</span>  <span class="c1"># This path is tested in unit tests, but not actually used?</span>
                <span class="c1"># Case: d/dt [w[...] + t v[...]]</span>
                <span class="c1"># Case: d/dt [w[...] + t v]</span>
                <span class="n">wval</span><span class="p">,</span> <span class="n">wcomp</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">ufl_operands</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">wval</span> <span class="o">==</span> <span class="n">o</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wval</span><span class="p">,</span> <span class="n">FormArgument</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">FixedIndex</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wcomp</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting only fixed indices in differentiation variable.&quot;</span><span class="p">)</span>
                <span class="n">wshape</span> <span class="o">=</span> <span class="n">wval</span><span class="o">.</span><span class="n">ufl_shape</span>

                <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span> <span class="o">=</span> <span class="n">analyse_variation_argument</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">gprimesum</span> <span class="o">=</span> <span class="n">gprimesum</span> <span class="o">+</span> <span class="n">compute_gprimeterm</span><span class="p">(</span><span class="n">ngrads</span><span class="p">,</span> <span class="n">vval</span><span class="p">,</span> <span class="n">vcomp</span><span class="p">,</span> <span class="n">wshape</span><span class="p">,</span> <span class="n">wcomp</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting coefficient or component of coefficient.&quot;</span><span class="p">)</span>

        <span class="c1"># FIXME: Handle other coefficient derivatives: oprimes =</span>
        <span class="c1"># self._cd.get(o)</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">oprimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oprimes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="p">:</span>
                    <span class="c1"># TODO: Make it possible to silence this message</span>
                    <span class="c1">#       in particular?  It may be good to have for</span>
                    <span class="c1">#       debugging...</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assuming d</span><span class="se">{{</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="se">}}</span><span class="s2">/d</span><span class="se">{{</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="si">}</span><span class="se">}}</span><span class="s2"> = 0.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Make sure we have a tuple to match the self._v tuple</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oprimes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">oprimes</span> <span class="o">=</span> <span class="p">(</span><span class="n">oprimes</span><span class="p">,)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oprimes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Got a tuple of arguments, expecting a&quot;</span>
                            <span class="s2">&quot; matching tuple of coefficient derivatives.&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># Compute dg/dw_j = dg/dw_h : v.</span>
                <span class="c1"># Since we may actually have a tuple of oprimes and vs</span>
                <span class="c1"># in a &#39;mixed&#39; space, sum over them all to get the</span>
                <span class="c1"># complete inner product. Using indices to define a</span>
                <span class="c1"># non-compound inner product.</span>
                <span class="k">for</span> <span class="n">oprime</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oprimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;FIXME: Figure out how to do this with ngrads&quot;</span><span class="p">)</span>
                    <span class="n">so</span><span class="p">,</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">as_scalar</span><span class="p">(</span><span class="n">oprime</span><span class="p">)</span>
                    <span class="n">rv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span>
                    <span class="n">oi1</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[:</span><span class="o">-</span><span class="n">rv</span><span class="p">]</span>
                    <span class="n">oi2</span> <span class="o">=</span> <span class="n">oi</span><span class="p">[</span><span class="o">-</span><span class="n">rv</span><span class="p">:]</span>
                    <span class="n">prod</span> <span class="o">=</span> <span class="n">so</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">oi2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">oi1</span><span class="p">:</span>
                        <span class="n">gprimesum</span> <span class="o">+=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">oi1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gprimesum</span> <span class="o">+=</span> <span class="n">prod</span>

        <span class="k">return</span> <span class="n">gprimesum</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CoordinateDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">o0</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">CoordinateDerivative</span><span class="p">(</span><span class="n">o0</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseFormOperator</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">BaseFormOperator</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a base_form_operator.</span>

<span class="sd">        If d_coeff = 0 =&gt; BaseFormOperator&#39;s derivative is taken wrt a</span>
<span class="sd">        variable =&gt; we call the appropriate handler. Otherwise =&gt;</span>
<span class="sd">        differentiation done wrt the BaseFormOperator (dF/dN[Nhat]) =&gt;</span>
<span class="sd">        we treat o as a Coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_coefficient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># It also handles the non-scalar case</span>
        <span class="k">if</span> <span class="n">d_coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">o</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">d_coeff</span>

    <span class="c1"># -- Handlers for BaseForm objects -- #</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Cofunction</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Cofunction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a cofunction.&quot;&quot;&quot;</span>
        <span class="c1"># Same rule than for Coefficient except that we use a Coargument.</span>
        <span class="c1"># The coargument is already attached to the class (self._v)</span>
        <span class="c1"># which `self.coefficient` relies on.</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_coefficient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">dc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Convert ufl.Zero into ZeroBaseForm</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">dc</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coargument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Coargument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coargument.&quot;&quot;&quot;</span>
        <span class="c1"># Same rule than for Argument (da/dw == 0).</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_argument</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Convert ufl.Zero into ZeroBaseForm</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">dc</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Matrix</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">Matrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a matrix.&quot;&quot;&quot;</span>
        <span class="c1"># Matrix rule: D_w[v](M) = v if M == w else 0</span>
        <span class="c1"># We can&#39;t differentiate wrt a matrix so always return zero in</span>
        <span class="c1"># the appropriate space</span>
        <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span></div>



<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseFormOperatorDerivativeRuleset</span><span class="p">(</span><span class="n">GateauxDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to BaseFormOperator.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](B) = d/dtau B(w+tau v)|tau=0 where B is a ufl.BaseFormOperator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.pending_operations_recording">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.pending_operations_recording">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pending_operations_recording</span><span class="p">(</span><span class="n">base_form_operator_handler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decorate a function to record pending operations.&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_form_op</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Decorate.&quot;&quot;&quot;</span>
            <span class="c1"># Get the outer `BaseFormOperator` expression, i.e. the</span>
            <span class="c1"># operator that is being differentiated.</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_base_form_op</span>
            <span class="c1"># If the base form operator we observe is different from the</span>
            <span class="c1"># outer `BaseFormOperator`:</span>
            <span class="c1"># -&gt; Record that `BaseFormOperator` so that</span>
            <span class="c1"># `d(expression)/d(base_form_op)` can then be computed</span>
            <span class="c1"># later.</span>
            <span class="c1"># Else:</span>
            <span class="c1"># -&gt; Compute the Gateaux derivative of `base_form_ops` by</span>
            <span class="c1"># calling the appropriate handler.</span>
            <span class="k">if</span> <span class="n">expression</span> <span class="o">!=</span> <span class="n">base_form_op</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base_form_op</span><span class="p">,)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_coefficient</span><span class="p">(</span><span class="n">base_form_op</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">base_form_operator_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_form_op</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coefficients</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">coefficient_derivatives</span><span class="p">:</span> <span class="n">ExprMapping</span><span class="p">,</span>
        <span class="n">outer_base_form_op</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">coefficients</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">,</span>
            <span class="n">coefficient_derivatives</span><span class="p">,</span>
            <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span>
            <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span>
            <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_base_form_op</span> <span class="o">=</span> <span class="n">outer_base_form_op</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Interpolate</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="nd">@pending_operations_recording</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_op</span><span class="p">:</span> <span class="n">Interpolate</span><span class="p">,</span> <span class="n">dw</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an interpolate.&quot;&quot;&quot;</span>
        <span class="c1"># Interpolate rule: D_w[v](i_op(w, v*)) = i_op(v, v*), by linearity of Interpolate!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dw</span><span class="p">:</span>
            <span class="c1"># i_op doesn&#39;t depend on w:</span>
            <span class="c1">#  -&gt; It also covers the Hessian case since Interpolate is linear,</span>
            <span class="c1">#     e.g. D_w[v](D_w[v](i_op(w, v*))) = D_w[v](i_op(v, v*)) = 0 (since w not found).</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">i_op</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">i_op</span><span class="o">.</span><span class="n">_ufl_expr_reconstruct_</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">dw</span><span class="p">)</span>

<div class="viewcode-block" id="BaseFormOperatorDerivativeRuleset.external_operator">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRuleset.external_operator">[docs]</a>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ExternalOperator</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="nd">@pending_operations_recording</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">external_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">ExternalOperator</span><span class="p">,</span> <span class="o">*</span><span class="n">dfs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate an external_operator.&quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="p">):</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dj</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">dj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">derivatives</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Handle the symbolic differentiation of external operators.</span>
                <span class="c1"># This bit returns:</span>
                <span class="c1">#</span>
                <span class="c1">#   `\sum_{i} dNdOi(..., Oi, ...; DOi(u)[v], ..., v*)`</span>
                <span class="c1">#</span>
                <span class="c1"># where we differentate wrt u, Oi is the i-th operand,</span>
                <span class="c1"># N(..., Oi, ...; ..., v*) an ExternalOperator and v the</span>
                <span class="c1"># direction (Argument). dNdOi(..., Oi, ...; DOi(u)[v])</span>
                <span class="c1"># is an ExternalOperator representing the</span>
                <span class="c1"># Gateaux-derivative of N. For example:</span>
                <span class="c1">#  -&gt; From N(u) = u**2, we get `dNdu(u; uhat, v*) = 2 * u * uhat`.</span>
                <span class="n">new_args</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">argument_slots</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">df</span><span class="p">,)</span>
                <span class="n">extop</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">_ufl_expr_reconstruct_</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">N</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">,</span> <span class="n">derivatives</span><span class="o">=</span><span class="n">derivatives</span><span class="p">,</span> <span class="n">argument_slots</span><span class="o">=</span><span class="n">new_args</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extop</span> <span class="o">=</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">arguments</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Frechet derivative of external operators need to be provided!&quot;</span>
                <span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extop</span><span class="p">,)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>
</div>



<div class="viewcode-block" id="DerivativeRuleDispatcher">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DerivativeRuleDispatcher</span><span class="p">(</span><span class="n">DAGTraverser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dispatch a derivative rule.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">)</span>
        <span class="c1"># Record the operations delayed to the derivative expansion phase:</span>
        <span class="c1"># Example: dN(u)/du where `N` is a BaseFormOperator and `u` a Coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">=</span> <span class="p">()</span>
        <span class="c1"># Create DAGTraverser caches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">],</span>
            <span class="n">DAGTraverser</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="DerivativeRuleDispatcher.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.DerivativeRuleDispatcher.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseForm</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to expr and base form.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reuse_if_untouched</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Terminal</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Terminal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Terminal</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a terminal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Derivative</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Derivative</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a derivative.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing derivative handler for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Grad</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a grad.&quot;&quot;&quot;</span>
        <span class="n">gdim</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">GradRuleset</span><span class="p">,</span> <span class="n">gdim</span><span class="p">)</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">GradRuleset</span><span class="p">(</span><span class="n">gdim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">ReferenceGrad</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a reference_grad.&quot;&quot;&quot;</span>
        <span class="n">tdim</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">ReferenceGradRuleset</span><span class="p">,</span> <span class="n">tdim</span><span class="p">)</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ReferenceGradRuleset</span><span class="p">(</span><span class="n">tdim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">VariableDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a variable_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">VariableRuleset</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">VariableRuleset</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CoefficientDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">CoefficientDerivative</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coefficient_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">GateauxDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="c1"># We need to go through the dag first to record the pending</span>
        <span class="c1"># operations</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">GateauxDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="c1"># If f has been seen by the traverser, it immediately returns</span>
        <span class="c1"># the cached value.</span>
        <span class="n">mapped_expr</span> <span class="o">=</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="c1"># Need to account for pending operations that have been stored</span>
        <span class="c1"># in other integrands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="n">dag_traverser</span><span class="o">.</span><span class="n">pending_operations</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">mapped_expr</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseFormOperatorDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">BaseFormOperatorDerivative</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a base_form_operator_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZeroBaseForm</span><span class="p">):</span>
            <span class="p">(</span><span class="n">arg</span><span class="p">,)</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span>  <span class="c1"># type: ignore</span>
            <span class="n">arguments</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">arguments</span><span class="p">()</span>
            <span class="c1"># derivative(F, u, du) with `du` a Coefficient</span>
            <span class="c1"># is equivalent to taking the action of the derivative.</span>
            <span class="c1"># In that case, we don&#39;t add arguments to `ZeroBaseForm`.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">BaseArgument</span><span class="p">):</span>
                <span class="n">arguments</span> <span class="o">+=</span> <span class="p">(</span><span class="n">arg</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">ZeroBaseForm</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
        <span class="c1"># Need a BaseFormOperatorDerivativeRuleset object</span>
        <span class="c1"># for each outer_base_form_op (= f).</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">BaseFormOperatorDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="c1"># We need to go through the dag first to record the pending operations</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
            <span class="n">BaseFormOperatorDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="c1"># If f has been seen by the traverser, it immediately returns</span>
        <span class="c1"># the cached value.</span>
        <span class="n">mapped_expr</span> <span class="o">=</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">mapped_f</span> <span class="o">=</span> <span class="n">dag_traverser</span><span class="o">.</span><span class="n">_process_coefficient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">mapped_f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If dN/dN needs to return an Argument in N space</span>
            <span class="c1"># with N a BaseFormOperator.</span>
            <span class="k">return</span> <span class="n">mapped_f</span>
        <span class="c1"># Need to account for pending operations that have been stored in other integrands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_operations</span> <span class="o">+=</span> <span class="n">dag_traverser</span><span class="o">.</span><span class="n">pending_operations</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">mapped_expr</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CoordinateDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoordinateDerivative</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">CoordinateDerivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseFormCoordinateDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseFormCoordinateDerivative</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a base_form_coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="k">return</span> <span class="n">BaseFormCoordinateDerivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Indexed</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">Ap</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ii</span><span class="p">:</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to an indexed.&quot;&quot;&quot;</span>
        <span class="c1"># Reuse if untouched</span>
        <span class="k">if</span> <span class="n">Ap</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">o</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ap</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span> <span class="o">+</span> <span class="n">kk</span><span class="p">))</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">as_tensor</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">kk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Ap</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>



<div class="viewcode-block" id="BaseFormOperatorDerivativeRecorder">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.BaseFormOperatorDerivativeRecorder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseFormOperatorDerivativeRecorder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A derivative recorded for a base form operator.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;base_form_ops&quot;</span><span class="p">,</span> <span class="p">())</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="p">{</span><span class="s2">&quot;arguments&quot;</span><span class="p">,</span> <span class="s2">&quot;coefficient_derivatives&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only `arguments` and `coefficient_derivatives` are &quot;</span>
                <span class="s2">&quot;allowed as derivative arguments.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">base_form_ops</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert to a bool.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">base_form_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">der_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Derivative arguments must match when summing </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> objects.&quot;</span>
                <span class="p">)</span>
            <span class="n">base_form_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">base_form_ops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sum of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">base_form_ops</span><span class="o">=</span><span class="n">base_form_ops</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">der_kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="c1"># Recording order doesn&#39;t matter as collected</span>
        <span class="c1"># `BaseFormOperator`s are sorted later on.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseFormOperatorDerivativeRecorder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_form_ops</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_form_ops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="apply_derivatives">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.apply_derivatives">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_derivatives</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply derivatives to an expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        expression: A Form, an Expr or a BaseFormOperator to be differentiated</span>

<span class="sd">    Returns:</span>
<span class="sd">        A differentiated expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Notation: Let `var` be the thing we are differentating with respect to.</span>

    <span class="n">dag_traverser</span> <span class="o">=</span> <span class="n">DerivativeRuleDispatcher</span><span class="p">()</span>

    <span class="c1"># If we hit a base form operator (bfo), then if `var` is:</span>
    <span class="c1">#    - a BaseFormOperator ‚Üí Return `d(expression)/dw` where `w` is</span>
    <span class="c1">#      the coefficient produced by the bfo `var`.</span>
    <span class="c1">#    - else ‚Üí Record the bfo on the DAGTraverser object and returns</span>
    <span class="c1">#    - 0.</span>
    <span class="c1"># Example:</span>
    <span class="c1">#    ‚Üí If derivative(F(u, N(u); v), u) was taken the following line would compute `‚àÇF/‚àÇu`.</span>
    <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="n">map_integrands</span><span class="p">(</span><span class="n">dag_traverser</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">BaseForm</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">dexpression_dvar</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="c1"># The arguments got lost, just keep an empty Form</span>
        <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="n">Form</span><span class="p">([])</span>

    <span class="c1"># Get the recorded delayed operations</span>
    <span class="n">pending_operations</span> <span class="o">=</span> <span class="n">dag_traverser</span><span class="o">.</span><span class="n">pending_operations</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pending_operations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dexpression_dvar</span>

    <span class="c1"># Don&#39;t take into account empty Forms</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">,</span> <span class="n">Form</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dexpression_dvar</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dexpression_dvar</span> <span class="o">=</span> <span class="p">[</span><span class="n">dexpression_dvar</span><span class="p">]</span>

    <span class="c1"># Retrieve the base form operators, var, and the argument and</span>
    <span class="c1"># coefficient_derivatives for `derivative`</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">var</span>
    <span class="n">base_form_ops</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">base_form_ops</span>
    <span class="n">der_kwargs</span> <span class="o">=</span> <span class="n">pending_operations</span><span class="o">.</span><span class="n">der_kwargs</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">base_form_ops</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">()):</span>
        <span class="c1"># -- Replace dexpr/dvar by dexpr/dN -- #</span>
        <span class="c1"># We don&#39;t use `apply_derivatives` since the differentiation is</span>
        <span class="c1"># done via `\partial` and not `d`.</span>
        <span class="n">dexpr_dN</span> <span class="o">=</span> <span class="n">map_integrands</span><span class="p">(</span>
            <span class="n">dag_traverser</span><span class="p">,</span> <span class="n">replace_derivative_nodes</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">{</span><span class="n">var</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">N</span><span class="p">})</span>
        <span class="p">)</span>
        <span class="c1"># Don&#39;t take into account empty Forms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dexpr_dN</span><span class="p">,</span> <span class="n">Form</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dexpr_dN</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="c1"># -- Add the BaseFormOperatorDerivative node -- #</span>
        <span class="p">(</span><span class="n">var_arg</span><span class="p">,)</span> <span class="o">=</span> <span class="n">der_kwargs</span><span class="p">[</span><span class="s2">&quot;arguments&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">der_kwargs</span><span class="p">[</span><span class="s2">&quot;coefficient_derivatives&quot;</span><span class="p">]</span>
        <span class="c1"># Not always the case since `derivative`&#39;s syntax enables one to</span>
        <span class="c1"># use a Coefficient as the Gateaux direction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_arg</span><span class="p">,</span> <span class="n">BaseArgument</span><span class="p">):</span>
            <span class="c1"># Construct the argument number based on the</span>
            <span class="c1"># BaseFormOperator arguments instead of naively using</span>
            <span class="c1"># `var_arg`. This is critical when BaseFormOperators are</span>
            <span class="c1"># used inside 0-forms.</span>
            <span class="c1">#</span>
            <span class="c1"># Example: F = 0.5 * u** 2 * dx + 0.5 * N(u; v*)** 2 * dx</span>
            <span class="c1">#    -&gt; dFdu[vhat] = &lt;u, vhat&gt; + Action(&lt;N(u; v*), v0&gt;, dNdu(u; v1, v*))</span>
            <span class="c1"># with `vhat` a 0-numbered argument, and where `v1` and</span>
            <span class="c1"># `vhat` have the same function space but a different</span>
            <span class="c1"># number. Here, applying `vhat` (`var_arg`) naively would</span>
            <span class="c1"># result in `dNdu(u; vhat, v*)`, i.e. the 2-forms `dNdu`</span>
            <span class="c1"># would have two 0-numbered arguments. Instead we increment</span>
            <span class="c1"># the argument number of `vhat` to form `v1`.</span>
            <span class="n">var_arg</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_arg</span><span class="p">)(</span>
                <span class="n">var_arg</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">(),</span> <span class="n">number</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">arguments</span><span class="p">()),</span> <span class="n">part</span><span class="o">=</span><span class="n">var_arg</span><span class="o">.</span><span class="n">part</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="n">dN_dvar</span> <span class="o">=</span> <span class="n">apply_derivatives</span><span class="p">(</span><span class="n">BaseFormOperatorDerivative</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">(</span><span class="n">var_arg</span><span class="p">),</span> <span class="n">cd</span><span class="p">))</span>
        <span class="c1"># -- Sum the Action: dF/du = ‚àÇF/‚àÇu + \sum_{i=1,...} Action(‚àÇF/‚àÇNi, dNi/du) -- #</span>
        <span class="c1"># In this case: Action &lt;=&gt; ufl.action since `dN_var` has 2 arguments.</span>
        <span class="c1"># We use Action to handle the trivial case `dN_dvar` = 0.</span>
        <span class="n">dexpression_dvar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Action</span><span class="p">(</span><span class="n">dexpr_dN</span><span class="p">,</span> <span class="n">dN_dvar</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dexpression_dvar</span><span class="p">)</span></div>



<div class="viewcode-block" id="CoordinateDerivativeRuleset">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CoordinateDerivativeRuleset</span><span class="p">(</span><span class="n">GenericDerivativeRuleset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply AFD (Automatic Functional Differentiation) to expression.</span>

<span class="sd">    Implements rules for the Gateaux derivative D_w[v](...) defined as</span>
<span class="sd">    D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
<span class="sd">    where &#39;e&#39; is a ufl form after pullback and w is a SpatialCoordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coefficients</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">ExprList</span><span class="p">,</span>
        <span class="n">coefficient_derivatives</span><span class="p">:</span> <span class="n">ExprMapping</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="p">(),</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span>
        <span class="p">)</span>
        <span class="c1"># Type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of coefficients.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">ExprList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a ExprList of arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefficient_derivatives</span><span class="p">,</span> <span class="n">ExprMapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a coefficient-coefficient ExprMapping.&quot;</span><span class="p">)</span>
        <span class="c1"># The coefficient(s) to differentiate w.r.t. and the</span>
        <span class="c1"># argument(s) s.t. D_w[v](e) = d/dtau e(w+tau v)|tau=0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)}</span>
        <span class="c1"># Build more convenient dict {f: df/dw} for each coefficient f</span>
        <span class="c1"># where df/dw is nonzero</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">coefficient_derivatives</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span> <span class="o">=</span> <span class="p">{</span><span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]:</span> <span class="n">cd</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)}</span>

    <span class="c1"># Work around singledispatchmethod inheritance issue;</span>
    <span class="c1"># see https://bugs.python.org/issue36457.</span>
<div class="viewcode-block" id="CoordinateDerivativeRuleset.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleset.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GeometricQuantity</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining dg/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Argument</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="c1"># Explicitly defining da/dw == 0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Coefficient</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a coefficient.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;CoordinateDerivative of coefficient in physical space is not implemented.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a grad.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;CoordinateDerivative grad in physical space is not implemented.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">SpatialCoordinate</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a spatial_coordinate.&quot;&quot;&quot;</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w2v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="c1"># d x /d x =&gt; Argument(x.function_space())</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;CoordinateDerivative found a SpatialCoordinate that is different &quot;</span>
                <span class="s2">&quot;from the one being differentiated.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceValue</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_value.&quot;&quot;&quot;</span>
        <span class="n">do</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="n">do</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">do</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a reference_grad.&quot;&quot;&quot;</span>
        <span class="c1"># d (grad_X(...(x)) / dx =&gt; grad_X(...(Argument(x.function_space()))</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">ngrads</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ReferenceGrad</span><span class="p">):</span>
            <span class="p">(</span><span class="n">o</span><span class="p">,)</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
            <span class="n">ngrads</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SpatialCoordinate</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FormArgument</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting gradient of a FormArgument, not </span><span class="si">{</span><span class="n">ufl_err_str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">apply_grads</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngrads</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># Find o among all w without any indexing, which makes this</span>
        <span class="c1"># easy</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">o</span> <span class="o">==</span> <span class="n">w</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ReferenceValue</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FormArgument</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Case: d/dt [w + t v]</span>
                <span class="k">return</span> <span class="n">apply_grads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Jacobian</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differentiate a jacobian.&quot;&quot;&quot;</span>
        <span class="c1"># d (grad_X(x))/d x =&gt; grad_X(Argument(x.function_space())</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_unique_domain</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">ufl_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                <span class="n">FormArgument</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">ReferenceGrad</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_terminal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>



<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CoordinateDerivativeRuleDispatcher</span><span class="p">(</span><span class="n">DAGTraverser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dispatcher.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">visited_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span> <span class="n">visited_cache</span><span class="o">=</span><span class="n">visited_cache</span><span class="p">,</span> <span class="n">result_cache</span><span class="o">=</span><span class="n">result_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">],</span> <span class="n">DAGTraverser</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="CoordinateDerivativeRuleDispatcher.process">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.CoordinateDerivativeRuleDispatcher.process">[docs]</a>
    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process ``o``.</span>

<span class="sd">        Args:</span>
<span class="sd">            o: `Expr` to be processed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Processed object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span>
    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BaseForm</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span> <span class="o">|</span> <span class="n">BaseForm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to expr and base form.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reuse_if_untouched</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Terminal</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a terminal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Derivative</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a derivative.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing derivative handler for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a grad.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ReferenceGrad</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a reference_grad.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CoefficientDerivative</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coefficient_derivative.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="nd">@process</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">CoordinateDerivative</span><span class="p">)</span>
    <span class="nd">@DAGTraverser</span><span class="o">.</span><span class="n">postorder_only_children</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply to a coordinate_derivative.&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ufl.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_unique_elements</span>

        <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">extract_unique_elements</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">pullback</span><span class="p">,</span> <span class="n">CustomPullback</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;CoordinateDerivative is not supported for elements with custom pull back.&quot;</span>
                <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ufl_operands</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">CoordinateDerivativeRuleset</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>
        <span class="n">dag_traverser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dag_traverser_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">CoordinateDerivativeRuleset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cd</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag_traverser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_coordinate_derivatives">
<a class="viewcode-back" href="../../../api-doc/ufl.algorithms.html#ufl.algorithms.apply_derivatives.apply_coordinate_derivatives">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_coordinate_derivatives</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply coordinate derivatives to an expression.&quot;&quot;&quot;</span>
    <span class="n">dag_traverser</span> <span class="o">=</span> <span class="n">CoordinateDerivativeRuleDispatcher</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">map_integrands</span><span class="p">(</span><span class="n">dag_traverser</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Unified Form Language (UFL)</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api-doc/ufl.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Release notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2026, FEniCS Project.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>
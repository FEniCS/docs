
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Algorithms &#8212; Unified Form Language (UFL) 2022.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ufl package" href="../api-doc/ufl.html" />
    <link rel="prev" title="Internal representation details" href="internal_representation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="algorithms">
<h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading">¶</a></h1>
<p>Algorithms to work with UFL forms and expressions can be found in the
submodule <code class="docutils literal notranslate"><span class="pre">ufl.algorithms</span></code>.  You can import all of them with
the line</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ufl.algorithms</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This chapter gives an overview of (most of) the implemented algorithms.
The intended audience is primarily developers, but advanced users may
find information here useful for debugging.</p>
<p>While domain specific languages introduce notation to express particular
ideas more easily, which can reduce the probability of bugs in user code,
they also add yet another layer of abstraction which can make debugging
more difficult when the need arises.  Many of the utilities described
here can be useful in that regard.</p>
<section id="formatting-expressions">
<h2>Formatting expressions<a class="headerlink" href="#formatting-expressions" title="Permalink to this heading">¶</a></h2>
<p>Expressions can be formatted in various ways for inspection, which is
particularly useful for debugging.  We use the following as an example
form for the formatting sections below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<section id="str">
<h3>str<a class="headerlink" href="#str" title="Permalink to this heading">¶</a></h3>
<p>Compact, human readable pretty printing.  Useful in interactive Python
sessions.  Example output of <code class="docutils literal notranslate"><span class="pre">str(a)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">v_0</span> <span class="o">*</span> <span class="n">v_1</span> <span class="o">*</span> <span class="n">w_0</span> <span class="p">}</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="o">&lt;</span><span class="n">Mesh</span> <span class="c1">#-1 with coordinates parameterized by &lt;Lagrange vector element of degree 1 on a triangle: 2 x &lt;CG1 on a triangle&gt;&gt;&gt;[everywhere], {})</span>
<span class="o">+</span>  <span class="p">{</span> <span class="n">v_0</span> <span class="o">*</span> <span class="n">w_1</span> <span class="p">}</span> <span class="o">*</span> <span class="n">ds</span><span class="p">(</span><span class="o">&lt;</span><span class="n">Mesh</span> <span class="c1">#-1 with coordinates parameterized by &lt;Lagrange vector element of degree 1 on a triangle: 2 x &lt;CG1 on a triangle&gt;&gt;&gt;[everywhere], {})</span>
</pre></div>
</div>
</section>
<section id="repr">
<h3>repr<a class="headerlink" href="#repr" title="Permalink to this heading">¶</a></h3>
<p>Accurate description of an expression, with the property that
<code class="docutils literal notranslate"><span class="pre">eval(repr(a))</span> <span class="pre">==</span> <span class="pre">a</span></code>.  Useful to see which representation types
occur in an expression, especially if <code class="docutils literal notranslate"><span class="pre">str(a)</span></code> is ambiguous.
Example output of <code class="docutils literal notranslate"><span class="pre">repr(a)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Form</span><span class="p">([</span><span class="n">Integral</span><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Product</span><span class="p">(</span><span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">))),</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;everywhere&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)),</span> <span class="s1">&#39;exterior_facet&#39;</span><span class="p">,</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;everywhere&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="kc">None</span><span class="p">)])</span>
</pre></div>
</div>
</section>
<section id="tree-formatting">
<h3>Tree formatting<a class="headerlink" href="#tree-formatting" title="Permalink to this heading">¶</a></h3>
<p>ASCII tree formatting, useful to inspect the tree structure of
an expression in interactive Python sessions.  Example output of
<code class="docutils literal notranslate"><span class="pre">tree_format(a)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Form</span><span class="p">:</span>
  <span class="n">Integral</span><span class="p">:</span>
    <span class="n">integral</span> <span class="nb">type</span><span class="p">:</span> <span class="n">cell</span>
    <span class="n">subdomain</span> <span class="nb">id</span><span class="p">:</span> <span class="n">everywhere</span>
    <span class="n">integrand</span><span class="p">:</span>
      <span class="n">Product</span>
      <span class="p">(</span>
        <span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">Product</span>
        <span class="p">(</span>
          <span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
          <span class="n">Coefficient</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
      <span class="p">)</span>
<span class="n">Integral</span><span class="p">:</span>
  <span class="n">integral</span> <span class="nb">type</span><span class="p">:</span> <span class="n">exterior_facet</span>
  <span class="n">subdomain</span> <span class="nb">id</span><span class="p">:</span> <span class="n">everywhere</span>
  <span class="n">integrand</span><span class="p">:</span>
    <span class="n">Product</span>
    <span class="p">(</span>
      <span class="n">Argument</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
      <span class="n">Coefficient</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">Mesh</span><span class="p">(</span><span class="n">VectorElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="inspecting-and-manipulating-the-expression-tree">
<h2>Inspecting and manipulating the expression tree<a class="headerlink" href="#inspecting-and-manipulating-the-expression-tree" title="Permalink to this heading">¶</a></h2>
<p>This subsection is mostly for form compiler developers and technically
interested users.</p>
<section id="traversing-expressions">
<h3>Traversing expressions<a class="headerlink" href="#traversing-expressions" title="Permalink to this heading">¶</a></h3>
<section id="iter-expressions">
<h4><code class="docutils literal notranslate"><span class="pre">iter_expressions</span></code><a class="headerlink" href="#iter-expressions" title="Permalink to this heading">¶</a></h4>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iter_expressions</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="nb">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_0</span> <span class="o">*</span> <span class="n">v_1</span> <span class="o">*</span> <span class="n">w_0</span>
<span class="n">v_0</span> <span class="o">*</span> <span class="n">w_1</span>
</pre></div>
</div>
</section>
</section>
<section id="transforming-expressions">
<h3>Transforming expressions<a class="headerlink" href="#transforming-expressions" title="Permalink to this heading">¶</a></h3>
<p>So far we presented algorithms meant to inspect expressions
in various ways. Some recurring patterns occur when writing algorithms
to modify expressions, either to apply mathematical transformations or
to change their representation. Usually, different expression node types
need different treatment.</p>
<p>To assist in such algorithms, UFL provides the <code class="docutils literal notranslate"><span class="pre">Transformer</span></code>
class. This implements a variant of the Visitor pattern to enable easy
definition of transformation rules for the types you wish to handle.</p>
<p>Shown here is maybe the simplest transformer possible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Printer</span><span class="p">(</span><span class="n">Transformer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Transformer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;Visiting&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="s2">&quot;with operands:&quot;</span>
        <span class="nb">print</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">operands</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">o</span>

<span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Printer</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">visit</span></code> will traverse <code class="docutils literal notranslate"><span class="pre">a</span></code> and call
<code class="docutils literal notranslate"><span class="pre">Printer.expr</span></code> on all expression nodes in post–order, with the
argument <code class="docutils literal notranslate"><span class="pre">operands</span></code> holding the return values from visits to the
operands of <code class="docutils literal notranslate"><span class="pre">o</span></code>. The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Visiting</span> <span class="n">v_0</span> <span class="o">*</span> <span class="n">v_1</span> <span class="k">with</span> <span class="n">operands</span><span class="p">:</span>
<span class="n">v_0</span><span class="p">,</span> <span class="n">v_1</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\((v^0_h)(v^1_h)\)</span></p>
<p>Implementing <code class="docutils literal notranslate"><span class="pre">expr</span></code> above provides a default handler for any
expression node type. For each subclass of <code class="docutils literal notranslate"><span class="pre">Expr</span></code> you can
define a handler function to override the default by using the name
of the type in underscore notation, e.g. <code class="docutils literal notranslate"><span class="pre">vector_constant</span></code>
for <code class="docutils literal notranslate"><span class="pre">VectorConstant</span></code>.  The constructor of <code class="docutils literal notranslate"><span class="pre">Transformer</span></code>
and implementation of <code class="docutils literal notranslate"><span class="pre">Transformer.visit</span></code> handles the mapping
from type to handler function automatically.</p>
<p>Here is a simple example to show how to override default behaviour:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ufl.classes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">class</span> <span class="nc">CoefficientReplacer</span><span class="p">(</span><span class="n">Transformer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Transformer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">reuse_if_possible</span>
    <span class="n">terminal</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">always_reuse</span>

    <span class="k">def</span> <span class="nf">coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FloatValue</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>

<span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">CoefficientReplacer</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">b</span>
</pre></div>
</div>
<p>which outputs</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">v_0</span>
</pre></div>
</div>
<p>The output of this code is the transformed expression <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span>
<span class="pre">3.14*v</span></code>.  This code also demonstrates how to reuse existing handlers.
The handler <code class="docutils literal notranslate"><span class="pre">Transformer.reuse_if_possible</span></code> will return the
input object if the operands have not changed, and otherwise reconstruct
a new instance of the same type but with the new transformed operands.
The handler <code class="docutils literal notranslate"><span class="pre">Transformer.always_reuse</span></code> always reuses the instance
without recursing into its children, usually applied to terminals.
To set these defaults with less code, inherit <code class="docutils literal notranslate"><span class="pre">ReuseTransformer</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">Transformer</span></code>. This ensures that the parts of the
expression tree that are not changed by the transformation algorithms
will always reuse the same instances.</p>
<p>We have already mentioned the difference between pre–traversal
and post–traversal, and some times you need to combine the
two. <code class="docutils literal notranslate"><span class="pre">Transformer</span></code> makes this easy by checking the number of
arguments to your handler functions to see if they take transformed
operands as input or not.  If a handler function does not take more
than a single argument in addition to self, its children are not visited
automatically, and the handler function must call <code class="docutils literal notranslate"><span class="pre">visit</span></code> on its
operands itself.</p>
<p>Here is an example of mixing pre- and post-traversal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Traverser</span><span class="p">(</span><span class="n">ReuseTransformer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ReuseTransformer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">operands</span><span class="p">()</span>
        <span class="n">newoperands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
            <span class="n">newoperands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">newoperands</span><span class="p">)</span>

<span class="n">element</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">+</span><span class="n">g</span><span class="o">+</span><span class="n">h</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">Traverser</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">b</span>
</pre></div>
</div>
<p>This code inherits the <code class="docutils literal notranslate"><span class="pre">ReuseTransformer</span></code> as explained above,
so the default behaviour is to recurse into children first and then call
<code class="docutils literal notranslate"><span class="pre">Transformer.reuse_if_possible</span></code> to reuse or reconstruct each
expression node.  Since <code class="docutils literal notranslate"><span class="pre">sum</span></code> only takes <code class="docutils literal notranslate"><span class="pre">self</span></code> and the
expression node instance <code class="docutils literal notranslate"><span class="pre">o</span></code> as arguments, its children are not
visited automatically, and <code class="docutils literal notranslate"><span class="pre">sum</span></code> explicitly calls <code class="docutils literal notranslate"><span class="pre">self.visit</span></code>
to do this.</p>
</section>
</section>
<section id="automatic-differentiation-implementation">
<h2>Automatic differentiation implementation<a class="headerlink" href="#automatic-differentiation-implementation" title="Permalink to this heading">¶</a></h2>
<p>This subsection is mostly for form compiler developers and technically
interested users.</p>
<p>First of all, we give a brief explanation of the algorithm.
Recall that a <code class="docutils literal notranslate"><span class="pre">Coefficient</span></code> represents a
sum of unknown coefficients multiplied with unknown
basis functions in some finite element space.</p>
<div class="math notranslate nohighlight">
\[w(x) = \sum_k w_k \phi_k(x)\]</div>
<p>Also recall that an <code class="docutils literal notranslate"><span class="pre">Argument</span></code> represents any (unknown) basis
function in some finite element space.</p>
<div class="math notranslate nohighlight">
\[v(x) = \phi_k(x), \qquad \phi_k \in V_h .\]</div>
<p>A form <span class="math notranslate nohighlight">\(L(v; w)\)</span> implemented in UFL is intended for discretization
like</p>
<div class="math notranslate nohighlight">
\[b_i = L(\phi_i; \sum_k w_k \phi_k), \qquad \forall \phi_i \in V_h .\]</div>
<p>The Jacobi matrix <span class="math notranslate nohighlight">\(A_{ij}\)</span> of this vector can be obtained by
differentiation of <span class="math notranslate nohighlight">\(b_i\)</span> w.r.t. <span class="math notranslate nohighlight">\(w_j\)</span>, which can be written</p>
<div class="math notranslate nohighlight">
\[A_{ij} = \frac{d b_i}{d w_j} = a(\phi_i, \phi_j; \sum_k w_k \phi_k), \qquad \forall \phi_i \in V_h, \quad \forall \phi_j \in V_h ,\]</div>
<p>for some form <cite>a</cite>. In UFL, the form <cite>a</cite> can be obtained by
differentiating <cite>L</cite>.  To manage this, we note that as long as the domain
<span class="math notranslate nohighlight">\(\Omega\)</span> is independent of <span class="math notranslate nohighlight">\(w_j\)</span>, <span class="math notranslate nohighlight">\(\int_\Omega\)</span> commutes with <span class="math notranslate nohighlight">\(\frac{d}{d
w_j}\)</span>, and we can differentiate the integrand expression instead, e.g.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}L(v; w) = \int_\Omega I_c(v; w) \, dx + \int_{\partial\Omega} I_e(v; w) \, ds, \\
   \frac{d}{d w_j} L(v; w) = \int_\Omega \frac{d I_c}{d w_j} \, dx + \int_{\partial\Omega} \frac{d I_e}{d w_j} \, ds.\end{split}\]</div>
<p>In addition, we need that</p>
<div class="math notranslate nohighlight">
\[\frac{d w}{d w_j} = \phi_j, \qquad \forall \phi_j \in V_h ,\]</div>
<p>which in UFL can be represented as</p>
<div class="math notranslate nohighlight">
\[\begin{split}w &amp;= \mathtt{Coefficient(element)}, \\
v &amp;= \mathtt{Argument(element)}, \\
\frac{dw}{d w_j} &amp;= v,\end{split}\]</div>
<p>since <span class="math notranslate nohighlight">\(w\)</span> represents the sum and <span class="math notranslate nohighlight">\(v\)</span> represents any and all
basis functions in <span class="math notranslate nohighlight">\(V_h\)</span>.</p>
<p>Other operators have well defined derivatives, and by repeatedly applying
the chain rule we can differentiate the integrand automatically.</p>
</section>
<section id="computational-graphs">
<h2>Computational graphs<a class="headerlink" href="#computational-graphs" title="Permalink to this heading">¶</a></h2>
<p>This section is for form compiler developers and is probably of no
interest to end-users.</p>
<p>An expression tree can be seen as a directed acyclic graph (DAG).
To aid in the implementation of form compilers, UFL includes tools to
build a linearized <a class="footnote-reference brackets" href="#id2" id="id1">1</a> computational graph from the abstract expression tree.</p>
<p>A graph can be partitioned into subgraphs based on dependencies of
subexpressions, such that a quadrature based compiler can easily place
subexpressions inside the right sets of loops.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Linearized as in a linear datastructure,
do not confuse this with automatic differentiation.</p>
</dd>
</dl>
<section id="the-computational-graph">
<h3>The computational graph<a class="headerlink" href="#the-computational-graph" title="Permalink to this heading">¶</a></h3>
<p>Consider the expression</p>
<div class="math notranslate nohighlight">
\[f = (a + b) * (c + d)\]</div>
<p>where a, b, c, d are arbitrary scalar expressions.
The <em>expression tree</em> for f looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>   <span class="n">b</span>   <span class="n">c</span>   <span class="n">d</span>
\   <span class="o">/</span>   \   <span class="o">/</span>
  <span class="o">+</span>       <span class="o">+</span>
   \     <span class="o">/</span>
      <span class="o">*</span>
</pre></div>
</div>
<p>In UFL f is represented like this expression tree.  If a, b, c, d are all
distinct Coefficient instances, the UFL representation will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Coefficient</span> <span class="n">Coefficient</span> <span class="n">Coefficient</span> <span class="n">Coefficient</span>
          \     <span class="o">/</span>             \     <span class="o">/</span>
            <span class="n">Sum</span>                 <span class="n">Sum</span>
               \               <span class="o">/</span>
                <span class="o">---</span> <span class="n">Product</span> <span class="o">---</span>
</pre></div>
</div>
<p>If we instead have the expression</p>
<div class="math notranslate nohighlight">
\[f = (a + b) * (a - b)\]</div>
<p>the tree will in fact look like this, with the functions a and b only
represented once:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Coefficient</span>     <span class="n">Coefficient</span>
   <span class="o">|</span>       \   <span class="o">/</span>       <span class="o">|</span>
   <span class="o">|</span>        <span class="n">Sum</span>      <span class="n">Product</span> <span class="o">--</span> <span class="n">IntValue</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
   <span class="o">|</span>       <span class="n">Product</span>     <span class="o">|</span>
   <span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
   <span class="o">|-------</span> <span class="n">Sum</span> <span class="o">-------|</span>
</pre></div>
</div>
<p>The expression tree is a directed acyclic graph (DAG) where the vertices
are Expr instances and each edge represents a direct dependency between
two vertices, i.e. that one vertex is among the operands of another.
A graph can also be represented in a linearized data structure, consisting
of an array of vertices and an array of edges. This representation is
convenient for many algorithms. An example to illustrate this graph
representation follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">V</span><span class="p">,</span> <span class="n">E</span>
<span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">)]</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>In the following, this representation of an expression will be called
the <em>computational graph</em>.  To construct this graph from a UFL
expression, simply do</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">G</span>
</pre></div>
</div>
<p>The Graph class can build some useful data structures for use in
algorithms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Vin</span>  <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">Vin</span><span class="p">()</span>  <span class="c1"># Vin[i]  = list of vertex indices j such that there is an edge from V[j] to V[i]</span>
<span class="n">Vout</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">Vout</span><span class="p">()</span> <span class="c1"># Vout[i] = list of vertex indices j such that there is an edge from V[i] to V[j]</span>
<span class="n">Ein</span>  <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">Ein</span><span class="p">()</span>  <span class="c1"># Ein[i]  = list of edge indices j such that E[j] is an edge to V[i], e.g. E[j][1] == i</span>
<span class="n">Eout</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">Eout</span><span class="p">()</span> <span class="c1"># Eout[i] = list of edge indices j such that E[j] is an edge from V[i], e.g. E[j][0] == i</span>
</pre></div>
</div>
<p>The ordering of the vertices in the graph can in principle be arbitrary,
but here they are ordered such that</p>
<div class="math notranslate nohighlight">
\[v_i \prec v_j, \quad \forall j &gt; i,\]</div>
<p>where <span class="math notranslate nohighlight">\(a \prec b\)</span> means that <span class="math notranslate nohighlight">\(a\)</span> does not depend on <span class="math notranslate nohighlight">\(b\)</span>
directly or indirectly.</p>
<p>Another property of the computational graph built by UFL is that no
identical expression is assigned to more than one vertex. This is
achieved efficiently by inserting expressions in a dict (a hash map)
during graph building.</p>
<p>In principle, correct code can be generated for an expression from its
computational graph simply by iterating over the vertices and generating
code for each one separately. However, we can do better than that.</p>
</section>
<section id="partitioning-the-graph">
<h3>Partitioning the graph<a class="headerlink" href="#partitioning-the-graph" title="Permalink to this heading">¶</a></h3>
<p>To help generate better code efficiently, we can partition vertices by
their dependencies, which allows us to, e.g., place expressions outside
the quadrature loop if they don’t depend (directly or indirectly) on
the spatial coordinates. This is done simply by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Unified Form Language (UFL)</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-doc/ufl.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Release notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../manual.html">User manual</a><ul>
      <li>Previous: <a href="internal_representation.html" title="previous chapter">Internal representation details</a></li>
      <li>Next: <a href="../api-doc/ufl.html" title="next chapter">ufl package</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, FEniCS Project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/manual/algorithms.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
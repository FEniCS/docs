
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dolfinx.fem &#8212; DOLFINX  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dolfinx.function" href="dolfinx.function.html" />
    <link rel="prev" title="dolfinx.common" href="dolfinx.common.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dolfinx.function.html" title="dolfinx.function"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dolfinx.common.html" title="dolfinx.common"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DOLFINX  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dolfinx.fem</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dolfinx.fem">
<span id="dolfinx-fem"></span><h1>dolfinx.fem<a class="headerlink" href="#module-dolfinx.fem" title="Permalink to this headline">¶</a></h1>
<p>Tools for assembling and manipulating finite element forms</p>
<dl class="py class">
<dt id="dolfinx.fem.DirichletBC">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">DirichletBC</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>ufl.coefficient.Coefficient<span class="p">, </span><a class="reference internal" href="dolfinx.function.html#dolfinx.function.Function" title="dolfinx.function.Function">dolfinx.function.Function</a><span class="p">, </span><a class="reference internal" href="dolfinx.cpp.function.html#dolfinx.cpp.function.Function" title="dolfinx.cpp.function.Function">dolfinx.cpp.function.Function</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">dofs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#DirichletBC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DirichletBC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.DirichletBC" title="dolfinx.cpp.fem.DirichletBC"><code class="xref py py-class docutils literal notranslate"><span class="pre">dolfinx.cpp.fem.DirichletBC</span></code></a></p>
<p>Representation of Dirichlet boundary condition which is imposed on
a linear system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – Lifted boundary values function.</p></li>
<li><p><strong>dofs</strong> – Local indices of degrees of freedom in function space to which
boundary condition applies.
Expects array of size (number of dofs, 2) if function space of the
problem, <code class="docutils literal notranslate"><span class="pre">V</span></code>, is passed. Otherwise assumes function space of the
problem is the same of function space of boundary values function.</p></li>
<li><p><strong>V</strong> (<em>optional</em>) – Function space of a problem to which boundary conditions are applied.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.DofMap">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">DofMap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dofmap</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.DofMap" title="dolfinx.cpp.fem.DofMap">dolfinx.cpp.fem.DofMap</a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dofmap.html#DofMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DofMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Degree-of-freedom map</p>
<p>This class handles the mapping of degrees of freedom. It builds
a dof map based on a ufc_dofmap on a specific mesh.</p>
<dl class="py method">
<dt id="dolfinx.fem.DofMap.bs">
<em class="property">property </em><code class="sig-name descname">bs</code><a class="headerlink" href="#dolfinx.fem.DofMap.bs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.cell_dofs">
<code class="sig-name descname">cell_dofs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell_index</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dofmap.html#DofMap.cell_dofs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DofMap.cell_dofs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.dof_layout">
<em class="property">property </em><code class="sig-name descname">dof_layout</code><a class="headerlink" href="#dolfinx.fem.DofMap.dof_layout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.index_map">
<em class="property">property </em><code class="sig-name descname">index_map</code><a class="headerlink" href="#dolfinx.fem.DofMap.index_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.index_map_bs">
<em class="property">property </em><code class="sig-name descname">index_map_bs</code><a class="headerlink" href="#dolfinx.fem.DofMap.index_map_bs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.list">
<em class="property">property </em><code class="sig-name descname">list</code><a class="headerlink" href="#dolfinx.fem.DofMap.list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.Form">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">Form</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">form_compiler_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">jit_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/form.html#Form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Form" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Create dolfinx Form</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>form</strong> – Pure UFL form</p></li>
<li><p><strong>form_compiler_parameters</strong> – See <a class="reference internal" href="dolfinx.jit.html#dolfinx.jit.ffcx_jit" title="dolfinx.jit.ffcx_jit"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffcx_jit</span></code></a></p></li>
<li><p><strong>jit_parameters</strong> – See <a class="reference internal" href="dolfinx.jit.html#dolfinx.jit.ffcx_jit" title="dolfinx.jit.ffcx_jit"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffcx_jit</span></code></a></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This wrapper for UFL form is responsible for the actual FFCX compilation
and attaching coefficients and domains specific data to the underlying
C++ Form.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.IntegralType">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">IntegralType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.IntegralType" title="dolfinx.cpp.fem.IntegralType">dolfinx.cpp.fem.IntegralType</a></span></em>, <em class="sig-param"><span class="n">arg0</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#dolfinx.fem.IntegralType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>cell</p>
<p>exterior_facet</p>
<p>interior_facet</p>
<p>vertex</p>
<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.cell">
<code class="sig-name descname">cell</code><em class="property"> = &lt;IntegralType.cell: 0&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.cell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.exterior_facet">
<code class="sig-name descname">exterior_facet</code><em class="property"> = &lt;IntegralType.exterior_facet: 1&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.exterior_facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.interior_facet">
<code class="sig-name descname">interior_facet</code><em class="property"> = &lt;IntegralType.interior_facet: 2&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.interior_facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.IntegralType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#dolfinx.fem.IntegralType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.vertex">
<code class="sig-name descname">vertex</code><em class="property"> = &lt;IntegralType.vertex: 3&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.vertex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.adjoint">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">reordered_arguments</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; ufl.form.Form<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute adjoint of a bilinear form by changing the ordering (count)
of the test and trial functions.</p>
<p>The functions wraps <code class="docutils literal notranslate"><span class="pre">ufl.adjoint</span></code>, and by default UFL will create new
<code class="docutils literal notranslate"><span class="pre">Argument</span></code> s. To specify the <code class="docutils literal notranslate"><span class="pre">Argument</span></code> s rather than creating new ones,
pass a tuple of <code class="docutils literal notranslate"><span class="pre">Argument</span></code> s as <code class="docutils literal notranslate"><span class="pre">reordered_arguments</span></code>.
See the documentation for <code class="docutils literal notranslate"><span class="pre">ufl.adjoint</span></code> for more details.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.apply_lifting">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">apply_lifting</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>List<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#apply_lifting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.apply_lifting" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify RHS vector b for lifting of Dirichlet boundary conditions.
It modifies b such that:</p>
<blockquote>
<div><p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
</div></blockquote>
<p>where j is a block (nest) index. For a non-blocked problem j = 0.
The boundary conditions bcs are on the trial spaces V_j. The forms
in [a] must have the same test space as L (from which b was built),
but the trial space may differ. If x0 is not supplied, then it is
treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller
is responsible for calling VecGhostUpdateBegin/End.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.apply_lifting_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">apply_lifting_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#apply_lifting_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.apply_lifting_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify nested vector for lifting of Dirichlet boundary conditions.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear form into a matrix. The returned matrix is not
finalised, i.e. ghost values are not accumulated.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix_block" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear forms into matrix</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">mat_types</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix_nest" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear forms into matrix</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_scalar">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; numpy.float64<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble functional. The returned value is local and not accumulated
across processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear form into a new PETSc vector. The returned vector is
not finalised, i.e. ghost values are not accumulated on the owning
processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector_block" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear forms into a monolithic vector. The vector is not
finalised, i.e. ghost values are not accumulated.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector_nest" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear forms into a new nested PETSc (VecNest) vector. The
returned vector is not finalised, i.e. ghost values are not accumulated
on the owning processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_coordinate_map">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_coordinate_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">comm</span></em>, <em class="sig-param"><span class="n">o</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/coordinatemapping.html#create_coordinate_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_coordinate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a compiled UFC coordinate_mapping object</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">mat_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix_nest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector_nest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.derivative">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">du</span></em>, <em class="sig-param"><span class="n">coefficient_derivatives</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; ufl.form.Form<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#derivative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute derivative of from about u (coefficient) in the direction
of du (Argument)</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.increase_order">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">increase_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a><a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#increase_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.increase_order" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given function space, return the same space, but with
polynomial degree increase by 1.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.locate_dofs_geometrical">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">locate_dofs_geometrical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span><a class="reference internal" href="dolfinx.cpp.function.html#dolfinx.cpp.function.FunctionSpace" title="dolfinx.cpp.function.FunctionSpace">dolfinx.cpp.function.FunctionSpace</a><span class="p">, </span><a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">marker</span><span class="p">:</span> <span class="n">function</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#locate_dofs_geometrical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.locate_dofs_geometrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate degrees-of-freedom geometrically using a marker function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> – Function space(s) in which to search for degree-of-freedom indices.</p></li>
<li><p><strong>marker</strong> – A function that takes an array of points <code class="docutils literal notranslate"><span class="pre">x</span></code> with shape
<code class="docutils literal notranslate"><span class="pre">(gdim,</span> <span class="pre">num_points)</span></code> and returns an array of booleans of length
<code class="docutils literal notranslate"><span class="pre">num_points</span></code>, evaluating to <code class="docutils literal notranslate"><span class="pre">True</span></code> for entities whose
degree-of-freedom should be returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>An array of degree-of-freedom indices (local to the process)
for degrees-of-freedom whose coordinate evaluates to True for the
marker function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is a list of two function spaces, then a 2-D array of
shape (number of dofs, 2) is returned.</p>
<p>Returned degree-of-freedom indices are unique and ordered by the
first column.</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.locate_dofs_topological">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">locate_dofs_topological</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span><a class="reference internal" href="dolfinx.cpp.function.html#dolfinx.cpp.function.FunctionSpace" title="dolfinx.cpp.function.FunctionSpace">dolfinx.cpp.function.FunctionSpace</a><span class="p">, </span><a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">entity_dim</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">entities</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">remote</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#locate_dofs_topological"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.locate_dofs_topological" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate degrees-of-freedom belonging to mesh entities topologically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> – Function space(s) in which to search for degree-of-freedom indices.</p></li>
<li><p><strong>entity_dim</strong> – Topological dimension of entities where degrees-of-freedom are located.</p></li>
<li><p><strong>entities</strong> – Indices of mesh entities of dimension <code class="docutils literal notranslate"><span class="pre">entity_dim</span></code> where
degrees-of-freedom are located.</p></li>
<li><p><strong>remote</strong> (<em>True</em>) – True to return also “remotely located” degree-of-freedom indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>An array of degree-of-freedom indices (local to the process) for
degrees-of-freedom topologically belonging to mesh entities.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is a list of two function spaces, then a 2-D array of
shape (number of dofs, 2) is returned.</p>
<p>Returned degree-of-freedom indices are unique and ordered by the
first column.</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.set_bc">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">set_bc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#set_bc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.set_bc" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert boundary condition values into vector. Only local (owned)
entries are set, hence communication after calling this function is
not required unless ghost entries need to be updated to the boundary
condition value.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.set_bc_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">set_bc_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#set_bc_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.set_bc_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert boundary condition values into nested vector. Only local (owned)
entries are set, hence communication after calling this function is
not required unless the ghost entries need to be updated to the
boundary condition value.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.solve">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/solving.html#solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve variational problem a == L or F == 0.</p>
<p>The following list explains the
various ways in which the solve() function can be used.</p>
<p><em>1. Solving linear variational problems</em></p>
<p>A linear variational problem a(u, v) = L(v) for all v may be
solved by calling solve(a == L, u, …), where a is a bilinear
form, L is a linear form, u is a Function (the solution). Optional
arguments may be supplied to specify boundary conditions or solver
parameters. Some examples are given below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">])</span>

<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">},</span>
      <span class="n">form_compiler_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;optimize&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>For available choices for the ‘solver_parameters’ kwarg, look at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">LinearVariationalSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><em>2. Solving nonlinear variational problems</em></p>
<p>A nonlinear variational problem F(u; v) = 0 for all v may be
solved by calling solve(F == 0, u, …), where the residual F is a
linear form (linear in the test function v but possibly nonlinear
in the unknown u) and u is a Function (the solution). Optional
arguments may be supplied to specify boundary conditions, the
Jacobian form or solver parameters. If the Jacobian is not
supplied, it will be computed by automatic differentiation of the
residual form. Some examples are given below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">])</span>

<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span>
      <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">},</span>
      <span class="n">form_compiler_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;optimize&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>For available choices for the ‘solver_parameters’ kwarg, look at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">NonlinearVariationalSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><em>4. Solving linear/nonlinear variational problems adaptively</em></p>
<p>Linear and nonlinear variational problems maybe solved adaptively,
with automated goal-oriented error control. The automated error
control algorithm is based on adaptive mesh refinement in
combination with automated generation of dual-weighted
residual-based error estimates and error indicators.</p>
<p>An adaptive solve may be invoked by giving two additional
arguments to the solve call, a numerical error tolerance and a
goal functional (a Form).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">()</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-6</span>

<span class="c1"># Linear variational problem</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>

<span class="c1"># Nonlinear problem:</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.tear">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">tear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="dolfinx.function.html#dolfinx.function.FunctionSpace" title="dolfinx.function.FunctionSpace">dolfinx.function.FunctionSpace</a><a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#tear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.tear" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given function space, return the corresponding discontinuous
space</p>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="dolfinx.common.html"
                        title="previous chapter">dolfinx.common</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dolfinx.function.html"
                        title="next chapter">dolfinx.function</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/generated/dolfinx.fem.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dolfinx.function.html" title="dolfinx.function"
             >next</a> |</li>
        <li class="right" >
          <a href="dolfinx.common.html" title="dolfinx.common"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DOLFINX  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" >API reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dolfinx.fem</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, FEniCS Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>
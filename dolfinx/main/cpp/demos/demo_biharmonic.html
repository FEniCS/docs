

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Biharmonic equation &mdash; DOLFINx 0.3.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=4621528c"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Hyperelasticity" href="demo_hyperelasticity.html" />
    <link rel="prev" title="Poisson equation" href="demo_poisson.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DOLFINx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../demo.html">Demos</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../demo.html#introductory">Introductory</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Biharmonic equation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equation-and-problem-definition">Equation and problem definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../demo.html#intermediate">Intermediate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demo.html#advanced">Advanced</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DOLFINx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../demo.html">Demos</a></li>
      <li class="breadcrumb-item active">Biharmonic equation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demos/demo_biharmonic.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="biharmonic-equation">
<h1>Biharmonic equation<a class="headerlink" href="#biharmonic-equation" title="Link to this heading"></a></h1>
<p>This demo illustrates how to:</p>
<ul class="simple">
<li><p>Solve a linear partial differential equation</p></li>
<li><p>Use a discontinuous Galerkin method</p></li>
<li><p>Solve a fourth-order differential equation</p></li>
</ul>
<section id="equation-and-problem-definition">
<h2>Equation and problem definition<a class="headerlink" href="#equation-and-problem-definition" title="Link to this heading"></a></h2>
<section id="strong-formulation">
<h3>Strong formulation<a class="headerlink" href="#strong-formulation" title="Link to this heading"></a></h3>
<p>The biharmonic equation is a fourth-order elliptic equation. On the
domain <span class="math notranslate nohighlight">\(\Omega \subset \mathbb{R}^{d}\)</span>, <span class="math notranslate nohighlight">\(1 \le d \le 3\)</span>, it reads</p>
<div class="math notranslate nohighlight">
\[
\nabla^{4} u = f \quad {\rm in} \ \Omega,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\nabla^{4} \equiv \nabla^{2} \nabla^{2}\)</span> is the biharmonic
operator and <span class="math notranslate nohighlight">\(f\)</span> is a prescribed source term. To formulate a complete
boundary value problem, the biharmonic equation must be complemented
by suitable boundary conditions.</p>
</section>
<section id="weak-formulation">
<h3>Weak formulation<a class="headerlink" href="#weak-formulation" title="Link to this heading"></a></h3>
<p>Multiplying the biharmonic equation by a test function and integrating
by parts twice leads to a problem of second-order derivatives, which would
require <span class="math notranslate nohighlight">\(H^{2}\)</span> conforming (roughly <span class="math notranslate nohighlight">\(C^{1}\)</span> continuous) basis functions.
To solve the biharmonic equation using Lagrange finite element basis
functions, the biharmonic equation can be split into two second-order
equations (see the Mixed Poisson demo for a mixed method for the Poisson
equation), or a variational formulation can be constructed that imposes
weak continuity of normal derivatives between finite element cells.
This demo uses a discontinuous Galerkin approach to impose continuity
of the normal derivative weakly.</p>
<p>Consider a triangulation <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> of the domain <span class="math notranslate nohighlight">\(\Omega\)</span>, where
the set of interior facets is denoted by <span class="math notranslate nohighlight">\(\mathcal{E}_h^{\rm int}\)</span>.
Functions evaluated on opposite sides of a facet are indicated by the
subscripts <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(-\)</span>.
Using the standard continuous Lagrange finite element space</p>
<div class="math notranslate nohighlight">
\[
V = \left\{v \in H^{1}_{0}(\Omega)\,:\, v \in P_{k}(K) \
\forall \ K \in \mathcal{T} \right\}
\]</div>
<p>and considering the boundary conditions</p>
<div class="amsmath math notranslate nohighlight" id="equation-d8b2e82c-2070-44a5-a89f-508ca141b254">
<span class="eqno">(1)<a class="headerlink" href="#equation-d8b2e82c-2070-44a5-a89f-508ca141b254" title="Permalink to this equation"></a></span>\[\begin{align}
u &amp;= 0 \quad {\rm on} \ \partial\Omega, \\
\nabla^{2} u &amp;= 0 \quad {\rm on} \ \partial\Omega,
\end{align}\]</div>
<p>a weak formulation of the biharmonic problem reads: find <span class="math notranslate nohighlight">\(u \in V\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
a(u,v)=L(v) \quad \forall \ v \in V,
\]</div>
<p>where the bilinear form is</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
a(u, v) &amp;=
\sum_{K \in \mathcal{T}} \int_{K} \nabla^{2} u \nabla^{2} v \, {\rm d}x \\
&amp;\qquad+\sum_{E \in \mathcal{E}_h^{\rm int}}\left(\int_{E} \frac{\alpha}{h_E}
[\!\![ \nabla u ]\!\!] [\!\![ \nabla v ]\!\!] \, {\rm d}s
- \int_{E} \left&lt;\nabla^{2} u \right&gt;[\!\![ \nabla v ]\!\!]  \, {\rm d}s
- \int_{E} [\!\![ \nabla u ]\!\!] \left&lt;\nabla^{2} v \right&gt; \,
{\rm d}s\right)
\end{align*}\]</div>
<p>and the linear form is</p>
<div class="math notranslate nohighlight">
\[
L(v) = \int_{\Omega} fv \, {\rm d}x.
\]</div>
<p>Furthermore, <span class="math notranslate nohighlight">\(\left&lt; u \right&gt; = \frac{1}{2} (u_{+} + u_{-})\)</span>,
<span class="math notranslate nohighlight">\([\!\![ w ]\!\!]  = w_{+} \cdot n_{+} + w_{-} \cdot n_{-}\)</span>,
<span class="math notranslate nohighlight">\(\alpha \ge 0\)</span> is a penalty parameter and
<span class="math notranslate nohighlight">\(h_E\)</span> is a measure of the cell size.</p>
<p>The input parameters for this demo are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Omega = [0,1] \times [0,1]\)</span> (a unit square)</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha = 8.0\)</span> (penalty parameter)</p></li>
<li><p><span class="math notranslate nohighlight">\(f = 4.0 \pi^4\sin(\pi x)\sin(\pi y)\)</span> (source term)</p></li>
</ul>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h2>
<p>The implementation is in two files: a form file containing the
definition of the variational forms expressed in UFL and a C++ file
containing the actual solver.</p>
<p>Running this demo requires the files: <a class="reference download internal" download="" href="../_downloads/b693a008315e8318489984dd5f11b4d3/main.cpp"><code class="xref download docutils literal notranslate"><span class="pre">demo_biharmonic/main.cpp</span></code></a>,
<a class="reference download internal" download="" href="../_downloads/5e54fef01c95be7378b602dc333b83cd/biharmonic.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_biharmonic/biharmonic.py</span></code></a> and
<a class="reference download internal" download="" href="../_downloads/e69357cb60102e23cc59ec3ba487d123/CMakeLists.txt"><code class="xref download docutils literal notranslate"><span class="pre">demo_biharmonic/CMakeLists.txt</span></code></a>.</p>
<section id="ufl-form-file">
<h3>UFL form file<a class="headerlink" href="#ufl-form-file" title="Link to this heading"></a></h3>
<p>The UFL file is implemented in <a class="reference download internal" download="" href="../_downloads/5e54fef01c95be7378b602dc333b83cd/biharmonic.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_biharmonic/biharmonic.py</span></code></a>.</p>
<div class="dropdown admonition">
<p class="admonition-title">UFL form implemented in python</p>
<p>The first step is to define the variational problem at hand. We define
the variational problem in UFL terms in a separate form file. We begin
by defining the finite element:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">basix.ufl</span><span class="w"> </span><span class="kn">import</span> <span class="n">element</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CellDiameter</span><span class="p">,</span>
    <span class="n">Coefficient</span><span class="p">,</span>
    <span class="n">Constant</span><span class="p">,</span>
    <span class="n">FacetNormal</span><span class="p">,</span>
    <span class="n">FunctionSpace</span><span class="p">,</span>
    <span class="n">Mesh</span><span class="p">,</span>
    <span class="n">TestFunction</span><span class="p">,</span>
    <span class="n">TrialFunction</span><span class="p">,</span>
    <span class="n">avg</span><span class="p">,</span>
    <span class="n">div</span><span class="p">,</span>
    <span class="n">dS</span><span class="p">,</span>
    <span class="n">dx</span><span class="p">,</span>
    <span class="n">grad</span><span class="p">,</span>
    <span class="n">inner</span><span class="p">,</span>
    <span class="n">jump</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument to :py:class:<code class="docutils literal notranslate"><span class="pre">FiniteElement</span></code> is the finite element
family, the second argument specifies the domain, while the third
argument specifies the polynomial degree. Thus, in this case, our
element <code class="docutils literal notranslate"><span class="pre">element</span></code> consists of second-order, continuous Lagrange basis
functions on triangles (or in order words, continuous piecewise linear
polynomials on triangles).</p>
<p>Next, we use this element to initialize the trial and test functions
(<span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>) and the coefficient function <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coord_element</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">coord_element</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Coefficient</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, the outward unit normal to cell boundaries and a measure of the
cell size are defined. The average size of cells sharing a facet will
be used (<code class="docutils literal notranslate"><span class="pre">h_avg</span></code>).  The UFL syntax <code class="docutils literal notranslate"><span class="pre">('+')</span></code> and <code class="docutils literal notranslate"><span class="pre">('-')</span></code> restricts a
function to the <code class="docutils literal notranslate"><span class="pre">('+')</span></code> and <code class="docutils literal notranslate"><span class="pre">('-')</span></code> sides of a facet, respectively.
The penalty parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code> is made a :cpp:class:<code class="docutils literal notranslate"><span class="pre">Constant</span></code> so
that it can be changed in the program without regenerating the code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Normal component, mesh size and right-hand side</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">CellDiameter</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">h_avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we define the bilinear and linear forms according to the
variational formulation of the equations. Integrals over
internal facets are indicated by <code class="docutils literal notranslate"><span class="pre">*dS</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bilinear form</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">inner</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)),</span> <span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">avg</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))),</span> <span class="n">jump</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">dS</span>
    <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">avg</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))))</span> <span class="o">*</span> <span class="n">dS</span>
    <span class="o">+</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">h_avg</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">jump</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">jump</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">dS</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Linear form</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO: explanation on how to run cmake and/or shell commands for <code class="docutils literal notranslate"><span class="pre">ffcx</span></code>.
To compile biharmonic.py using FFCx with an option
for PETSc scalar type <code class="docutils literal notranslate"><span class="pre">float64</span></code> one would execute the command</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ffcx<span class="w"> </span>biharmonic.py<span class="w"> </span>--scalar_type<span class="o">=</span>float64
</pre></div>
</div>
</div>
</section>
<section id="c-program">
<h3>C++ program<a class="headerlink" href="#c-program" title="Link to this heading"></a></h3>
<p>The main solver is implemented in the <a class="reference download internal" download="" href="../_downloads/b693a008315e8318489984dd5f11b4d3/main.cpp"><code class="xref download docutils literal notranslate"><span class="pre">demo_biharmonic/main.cpp</span></code></a>
file.</p>
<p>At the top we include the DOLFINx header file and the generated
header file “biharmonic.h” containing the variational forms for the
Biharmonic equation, which are defined in the UFL form file. For
convenience we also include the DOLFINx namespace.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;biharmonic.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;basix/finite-element.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dolfinx.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dolfinx/common/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dolfinx/fem/Constant.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dolfinx/fem/petsc.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numbers&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">dolfinx</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PetscScalar</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">dolfinx</span><span class="o">::</span><span class="n">scalar_value_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Inside the <code class="docutils literal notranslate"><span class="pre">main</span></code> function, we begin by defining a mesh of the
domain. As the unit square is a very standard domain, we can use a
built-in mesh provided by the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UnitSquareMesh</span></code> factory. In
order to create a mesh consisting of 32 x 32 squares with each square
divided into two triangles, and the finite element space (specified
in the form file) defined relative to this mesh, we do as follows</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">dolfinx</span><span class="o">::</span><span class="n">init_logging</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="n">PetscInitialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//  Create mesh</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="o">::</span><span class="n">create_cell_partitioner</span><span class="p">(</span><span class="n">mesh</span><span class="o">::</span><span class="n">GhostMode</span><span class="o">::</span><span class="n">shared_facet</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">mesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">mesh</span><span class="o">::</span><span class="n">Mesh</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">mesh</span><span class="o">::</span><span class="n">create_rectangle</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="p">{{{</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">}}},</span>
<span class="w">                                  </span><span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">},</span><span class="w"> </span><span class="n">mesh</span><span class="o">::</span><span class="n">CellType</span><span class="o">::</span><span class="n">triangle</span><span class="p">,</span><span class="w"> </span><span class="n">part</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//    A function space object, which is defined in the generated code,</span>
<span class="w">    </span><span class="c1">//    is created:</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">create_element</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">family</span><span class="o">::</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">basix</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">triangle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">lagrange_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span>
<span class="w">        </span><span class="n">basix</span><span class="o">::</span><span class="n">element</span><span class="o">::</span><span class="n">dpc_variant</span><span class="o">::</span><span class="n">unset</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//  Create function space</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">V</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">fem</span><span class="o">::</span><span class="n">FunctionSpace</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">fem</span><span class="o">::</span><span class="n">create_functionspace</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">fem</span><span class="o">::</span><span class="n">FiniteElement</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">element</span><span class="p">)));</span>

<span class="w">    </span><span class="c1">// The source function $f$ and the penalty term $\alpha$ are</span>
<span class="w">    </span><span class="c1">// declared:</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">fem</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
<span class="w">    </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">interpolate</span><span class="p">(</span>
<span class="w">        </span><span class="p">[](</span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">extent</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">p</span><span class="p">)</span>
<span class="w">          </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
<span class="w">            </span><span class="n">f</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">4.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">))</span>
<span class="w">                        </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)));</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">f</span><span class="p">.</span><span class="n">size</span><span class="p">()}};</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">fem</span><span class="o">::</span><span class="n">Constant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mf">8.0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//  Define variational forms</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">Form</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fem</span><span class="o">::</span><span class="n">create_form</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">form_biharmonic_a</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">},</span><span class="w"> </span><span class="p">{},</span>
<span class="w">                                         </span><span class="p">{{</span><span class="s">&quot;alpha&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">}},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{});</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">Form</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">fem</span><span class="o">::</span><span class="n">create_form</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">form_biharmonic_L</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">V</span><span class="p">},</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">}},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{});</span>

<span class="w">    </span><span class="c1">//  Now, the Dirichlet boundary condition ($u = 0$) can be</span>
<span class="w">    </span><span class="c1">//  created using the class {cpp:class}`DirichletBC`. A</span>
<span class="w">    </span><span class="c1">//  {cpp:class}`DirichletBC` takes two arguments: the value of the</span>
<span class="w">    </span><span class="c1">//  boundary condition, and the part of the boundary on which the</span>
<span class="w">    </span><span class="c1">//  condition applies. In our example, the value of the boundary</span>
<span class="w">    </span><span class="c1">//  condition (0.0) can represented using a {cpp:class}`Function`,</span>
<span class="w">    </span><span class="c1">//  and the Dirichlet boundary is defined by the indices of degrees</span>
<span class="w">    </span><span class="c1">//  of freedom to which the boundary condition applies. The</span>
<span class="w">    </span><span class="c1">//  definition of the Dirichlet boundary condition then looks as</span>
<span class="w">    </span><span class="c1">//  follows:</span>

<span class="w">    </span><span class="c1">//  Define boundary condition</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">facets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="o">::</span><span class="n">exterior_facet_indices</span><span class="p">(</span><span class="o">*</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">topology</span><span class="p">());</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">bdofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fem</span><span class="o">::</span><span class="n">locate_dofs_topological</span><span class="p">(</span>
<span class="w">        </span><span class="o">*</span><span class="n">V</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">topology_mutable</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">V</span><span class="o">-&gt;</span><span class="n">dofmap</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">facets</span><span class="p">);</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">DirichletBC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bc</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">bdofs</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//  Now, we have specified the variational forms and can consider</span>
<span class="w">    </span><span class="c1">//  the solution of the variational problem. First, we need to</span>
<span class="w">    </span><span class="c1">//  define a {cpp:class}`Function` `u` to store the solution. (Upon</span>
<span class="w">    </span><span class="c1">//  initialization, it is simply set to the zero function.) Next, we</span>
<span class="w">    </span><span class="c1">//  can call the `solve` function with the arguments `a == L`, `u`</span>
<span class="w">    </span><span class="c1">//  and `bc` as follows:</span>

<span class="w">    </span><span class="c1">//  Compute solution</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">Matrix</span><span class="p">(</span><span class="n">fem</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">create_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">function_spaces</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dofmap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">index_map</span><span class="p">,</span>
<span class="w">                    </span><span class="n">L</span><span class="p">.</span><span class="n">function_spaces</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dofmap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">index_map_bs</span><span class="p">());</span>

<span class="w">    </span><span class="n">MatZeroEntries</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">());</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">Matrix</span><span class="o">::</span><span class="n">set_block_fn</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">ADD_VALUES</span><span class="p">),</span>
<span class="w">                         </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">bc</span><span class="p">});</span>
<span class="w">    </span><span class="n">MatAssemblyBegin</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">MAT_FLUSH_ASSEMBLY</span><span class="p">);</span>
<span class="w">    </span><span class="n">MatAssemblyEnd</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">MAT_FLUSH_ASSEMBLY</span><span class="p">);</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">set_diagonal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">Matrix</span><span class="o">::</span><span class="n">set_fn</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">INSERT_VALUES</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="w">                         </span><span class="p">{</span><span class="n">bc</span><span class="p">});</span>
<span class="w">    </span><span class="n">MatAssemblyBegin</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">MAT_FINAL_ASSEMBLY</span><span class="p">);</span>
<span class="w">    </span><span class="n">MatAssemblyEnd</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">(),</span><span class="w"> </span><span class="n">MAT_FINAL_ASSEMBLY</span><span class="p">);</span>

<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">assemble_vector</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mutable_array</span><span class="p">(),</span><span class="w"> </span><span class="n">L</span><span class="p">);</span>
<span class="w">    </span><span class="n">fem</span><span class="o">::</span><span class="n">apply_lifting</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mutable_array</span><span class="p">(),</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">},</span><span class="w"> </span><span class="p">{{</span><span class="n">bc</span><span class="p">}},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">scatter_rev</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="n">bc</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mutable_array</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>

<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">KrylovSolver</span><span class="w"> </span><span class="n">lu</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;ksp_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;preonly&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;pc_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lu&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">lu</span><span class="p">.</span><span class="n">set_from_options</span><span class="p">();</span>

<span class="w">    </span><span class="n">lu</span><span class="p">.</span><span class="n">set_operator</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">mat</span><span class="p">());</span>
<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">Vector</span><span class="w"> </span><span class="n">_u</span><span class="p">(</span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">create_vector_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">()),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">Vector</span><span class="w"> </span><span class="n">_b</span><span class="p">(</span><span class="n">la</span><span class="o">::</span><span class="n">petsc</span><span class="o">::</span><span class="n">create_vector_wrap</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">lu</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">_u</span><span class="p">.</span><span class="n">vec</span><span class="p">(),</span><span class="w"> </span><span class="n">_b</span><span class="p">.</span><span class="n">vec</span><span class="p">());</span>

<span class="w">    </span><span class="c1">//  Update ghost values before output</span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">scatter_fwd</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// The function `u` will be modified during the call to solve. A</span>
<span class="w">    </span><span class="c1">// {cpp:class}`Function` can be saved to a file. Here, we output the</span>
<span class="w">    </span><span class="c1">// solution to a `VTK` file (specified using the suffix `.pvd`) for</span>
<span class="w">    </span><span class="c1">// visualisation in an external program such as Paraview.</span>

<span class="w">    </span><span class="c1">//  Save solution in VTK format</span>
<span class="w">    </span><span class="n">io</span><span class="o">::</span><span class="n">VTKFile</span><span class="w"> </span><span class="n">file</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;u.pvd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;w&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">write</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">({</span><span class="n">u</span><span class="p">},</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">PetscFinalize</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="demo_poisson.html" class="btn btn-neutral float-left" title="Poisson equation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demo_hyperelasticity.html" class="btn btn-neutral float-right" title="Hyperelasticity" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, FEniCS Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
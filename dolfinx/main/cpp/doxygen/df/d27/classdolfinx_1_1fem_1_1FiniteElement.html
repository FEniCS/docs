<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: FiniteElement&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.11.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li><li class="navelem"><a href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../da/d34/classdolfinx_1_1fem_1_1FiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FiniteElement&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Model of a finite element.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d83/FiniteElement_8h_source.html">FiniteElement.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aabcaf5af5c0b791f0d4826adb9b38607" id="r_aabcaf5af5c0b791f0d4826adb9b38607"><td class="memItemLeft" align="right" valign="top"><a id="aabcaf5af5c0b791f0d4826adb9b38607" name="aabcaf5af5c0b791f0d4826adb9b38607"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>geometry_type</b> = T</td></tr>
<tr class="memdesc:aabcaf5af5c0b791f0d4826adb9b38607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry type of the Mesh that the <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> is defined on. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01b0b7e407f22cf7ef943d0eb6eea23f" id="r_a01b0b7e407f22cf7ef943d0eb6eea23f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b0b7e407f22cf7ef943d0eb6eea23f">FiniteElement</a> (const <a class="el" href="../../d0/de0/classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &amp;element, const std::optional&lt; std::vector&lt; std::size_t &gt; &gt; &amp;<a class="el" href="#a1b889a645fc12e661a150711914fb46a">value_shape</a>=std::nullopt, bool <a class="el" href="#a054885c66384c7bbfc59b9916d5be00f">symmetric</a>=false)</td></tr>
<tr class="memdesc:a01b0b7e407f22cf7ef943d0eb6eea23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a finite element from a Basix finite element.  <br /></td></tr>
<tr class="memitem:abc24e0a4a9f80f9973a4dd0bff6d04e0" id="r_abc24e0a4a9f80f9973a4dd0bff6d04e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc24e0a4a9f80f9973a4dd0bff6d04e0">FiniteElement</a> (std::vector&lt; <a class="el" href="../../db/da6/structdolfinx_1_1fem_1_1BasixElementData.html">BasixElementData</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt; elements)</td></tr>
<tr class="memdesc:abc24e0a4a9f80f9973a4dd0bff6d04e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mixed finite element from Basix finite elements.  <br /></td></tr>
<tr class="memitem:ad4ad1e8de503b85319ba1dc63eb566f3" id="r_ad4ad1e8de503b85319ba1dc63eb566f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4ad1e8de503b85319ba1dc63eb566f3">FiniteElement</a> (const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt; &gt; &amp;elements)</td></tr>
<tr class="memdesc:ad4ad1e8de503b85319ba1dc63eb566f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mixed finite element from a list of finite elements.  <br /></td></tr>
<tr class="memitem:a9c1ea61faead81d403281f4ba9e3779a" id="r_a9c1ea61faead81d403281f4ba9e3779a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c1ea61faead81d403281f4ba9e3779a">FiniteElement</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a> <a class="el" href="#ae764f3c89a15da5f05a413ceec934014">cell_type</a>, std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; points, std::array&lt; std::size_t, 2 &gt; pshape, std::vector&lt; std::size_t &gt; <a class="el" href="#a1b889a645fc12e661a150711914fb46a">value_shape</a>={}, bool <a class="el" href="#a054885c66384c7bbfc59b9916d5be00f">symmetric</a>=false)</td></tr>
<tr class="memdesc:a9c1ea61faead81d403281f4ba9e3779a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quadrature element.  <br /></td></tr>
<tr class="memitem:a43bdd28e8ff53d4bc27a9719d037b7bb" id="r_a43bdd28e8ff53d4bc27a9719d037b7bb"><td class="memItemLeft" align="right" valign="top"><a id="a43bdd28e8ff53d4bc27a9719d037b7bb" name="a43bdd28e8ff53d4bc27a9719d037b7bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FiniteElement</b> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;element)=delete</td></tr>
<tr class="memdesc:a43bdd28e8ff53d4bc27a9719d037b7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="memitem:abdf2fed83b951b0c90933fae07307496" id="r_abdf2fed83b951b0c90933fae07307496"><td class="memItemLeft" align="right" valign="top"><a id="abdf2fed83b951b0c90933fae07307496" name="abdf2fed83b951b0c90933fae07307496"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FiniteElement</b> (<a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:abdf2fed83b951b0c90933fae07307496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="memitem:aa48e4e647076e0d77fbfcb653e5d8f2f" id="r_aa48e4e647076e0d77fbfcb653e5d8f2f"><td class="memItemLeft" align="right" valign="top"><a id="aa48e4e647076e0d77fbfcb653e5d8f2f" name="aa48e4e647076e0d77fbfcb653e5d8f2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~FiniteElement</b> ()=default</td></tr>
<tr class="memdesc:aa48e4e647076e0d77fbfcb653e5d8f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="memitem:a0dbaefa0c4e0589f4d4ba4e85ccb4651" id="r_a0dbaefa0c4e0589f4d4ba4e85ccb4651"><td class="memItemLeft" align="right" valign="top"><a id="a0dbaefa0c4e0589f4d4ba4e85ccb4651" name="a0dbaefa0c4e0589f4d4ba4e85ccb4651"></a>
<a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;element)=delete</td></tr>
<tr class="memdesc:a0dbaefa0c4e0589f4d4ba4e85ccb4651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="memitem:a4109a2c5144a3f20632ad5a14c07509c" id="r_a4109a2c5144a3f20632ad5a14c07509c"><td class="memItemLeft" align="right" valign="top"><a id="a4109a2c5144a3f20632ad5a14c07509c" name="a4109a2c5144a3f20632ad5a14c07509c"></a>
<a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&amp;element)=default</td></tr>
<tr class="memdesc:a4109a2c5144a3f20632ad5a14c07509c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="memitem:afa62c95fee8cd0b22a4a272ba67bddbf" id="r_afa62c95fee8cd0b22a4a272ba67bddbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa62c95fee8cd0b22a4a272ba67bddbf">operator==</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;e) const</td></tr>
<tr class="memdesc:afa62c95fee8cd0b22a4a272ba67bddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are equivalent.  <br /></td></tr>
<tr class="memitem:a9382c35cf56595f89617732cb1b0eba3" id="r_a9382c35cf56595f89617732cb1b0eba3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9382c35cf56595f89617732cb1b0eba3">operator!=</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;e) const</td></tr>
<tr class="memdesc:a9382c35cf56595f89617732cb1b0eba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are not equivalent.  <br /></td></tr>
<tr class="memitem:ae764f3c89a15da5f05a413ceec934014" id="r_ae764f3c89a15da5f05a413ceec934014"><td class="memItemLeft" align="right" valign="top"><a id="ae764f3c89a15da5f05a413ceec934014" name="ae764f3c89a15da5f05a413ceec934014"></a>
<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_type</b> () const noexcept</td></tr>
<tr class="memdesc:ae764f3c89a15da5f05a413ceec934014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell shape that the element is defined on. <br /></td></tr>
<tr class="memitem:a508f93d3a34146afe1d2ed248b0ed225" id="r_a508f93d3a34146afe1d2ed248b0ed225"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508f93d3a34146afe1d2ed248b0ed225">signature</a> () const noexcept</td></tr>
<tr class="memdesc:a508f93d3a34146afe1d2ed248b0ed225"><td class="mdescLeft">&#160;</td><td class="mdescRight">String identifying the finite element.  <br /></td></tr>
<tr class="memitem:a2585c6e4d6d6133186cdc237e0ce9cfc" id="r_a2585c6e4d6d6133186cdc237e0ce9cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2585c6e4d6d6133186cdc237e0ce9cfc">space_dimension</a> () const noexcept</td></tr>
<tr class="memdesc:a2585c6e4d6d6133186cdc237e0ce9cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the finite element function space (the number of degrees-of-freedom for the element).  <br /></td></tr>
<tr class="memitem:acd3f76c0eb872b28ffb94a427332686f" id="r_acd3f76c0eb872b28ffb94a427332686f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd3f76c0eb872b28ffb94a427332686f">block_size</a> () const noexcept</td></tr>
<tr class="memdesc:acd3f76c0eb872b28ffb94a427332686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size of the finite element function space.  <br /></td></tr>
<tr class="memitem:a7d326295a6362a9b6f112e0efa5a7de7" id="r_a7d326295a6362a9b6f112e0efa5a7de7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d326295a6362a9b6f112e0efa5a7de7">value_size</a> () const</td></tr>
<tr class="memdesc:a7d326295a6362a9b6f112e0efa5a7de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value size of the finite element field.  <br /></td></tr>
<tr class="memitem:a1b889a645fc12e661a150711914fb46a" id="r_a1b889a645fc12e661a150711914fb46a"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b889a645fc12e661a150711914fb46a">value_shape</a> () const</td></tr>
<tr class="memdesc:a1b889a645fc12e661a150711914fb46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value shape of the finite element field.  <br /></td></tr>
<tr class="memitem:a78737d3c0a9c143fa24c503cac16d519" id="r_a78737d3c0a9c143fa24c503cac16d519"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78737d3c0a9c143fa24c503cac16d519">reference_value_size</a> () const</td></tr>
<tr class="memdesc:a78737d3c0a9c143fa24c503cac16d519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value size of the base (non-blocked) finite element field.  <br /></td></tr>
<tr class="memitem:aceb716e9df8e32218f50a9c8e7b178f7" id="r_aceb716e9df8e32218f50a9c8e7b178f7"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceb716e9df8e32218f50a9c8e7b178f7">reference_value_shape</a> () const</td></tr>
<tr class="memdesc:aceb716e9df8e32218f50a9c8e7b178f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value shape of the base (non-blocked) finite element field.  <br /></td></tr>
<tr class="memitem:a6816dfa619d78e118e4377f90bb671d1" id="r_a6816dfa619d78e118e4377f90bb671d1"><td class="memItemLeft" align="right" valign="top"><a id="a6816dfa619d78e118e4377f90bb671d1" name="a6816dfa619d78e118e4377f90bb671d1"></a>
const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>entity_dofs</b> () const noexcept</td></tr>
<tr class="memdesc:a6816dfa619d78e118e4377f90bb671d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local DOFs associated with each sub-entity of the cell. <br /></td></tr>
<tr class="memitem:ac49eef13a0da84f3eb735da2b9e58a73" id="r_ac49eef13a0da84f3eb735da2b9e58a73"><td class="memItemLeft" align="right" valign="top"><a id="ac49eef13a0da84f3eb735da2b9e58a73" name="ac49eef13a0da84f3eb735da2b9e58a73"></a>
const std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>entity_closure_dofs</b> () const noexcept</td></tr>
<tr class="memdesc:ac49eef13a0da84f3eb735da2b9e58a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local DOFs associated with the closure of each sub-entity of the cell. <br /></td></tr>
<tr class="memitem:a054885c66384c7bbfc59b9916d5be00f" id="r_a054885c66384c7bbfc59b9916d5be00f"><td class="memItemLeft" align="right" valign="top"><a id="a054885c66384c7bbfc59b9916d5be00f" name="a054885c66384c7bbfc59b9916d5be00f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>symmetric</b> () const</td></tr>
<tr class="memdesc:a054885c66384c7bbfc59b9916d5be00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the element represent a symmetric 2-tensor? <br /></td></tr>
<tr class="memitem:a34f72d0a2e110e2f3a3aab698136141f" id="r_a34f72d0a2e110e2f3a3aab698136141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f72d0a2e110e2f3a3aab698136141f">tabulate</a> (std::span&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; values, std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; X, std::array&lt; std::size_t, 2 &gt; shape, int order) const</td></tr>
<tr class="memdesc:a34f72d0a2e110e2f3a3aab698136141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate derivatives of the basis functions up to given order at points in the reference cell.  <br /></td></tr>
<tr class="memitem:a0ffa0a06971a6be314a82693c3d24bbb" id="r_a0ffa0a06971a6be314a82693c3d24bbb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;, std::array&lt; std::size_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ffa0a06971a6be314a82693c3d24bbb">tabulate</a> (std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; X, std::array&lt; std::size_t, 2 &gt; shape, int order) const</td></tr>
<tr class="memdesc:a0ffa0a06971a6be314a82693c3d24bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate all derivatives of the basis functions up to given order at given points in reference cell.  <br /></td></tr>
<tr class="memitem:abf6d258f77b4060f5d259fe7e877709b" id="r_abf6d258f77b4060f5d259fe7e877709b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf6d258f77b4060f5d259fe7e877709b">num_sub_elements</a> () const noexcept</td></tr>
<tr class="memdesc:abf6d258f77b4060f5d259fe7e877709b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of sub elements (for a mixed or blocked element).  <br /></td></tr>
<tr class="memitem:a6f152d3559b409b233e7d64b13978e9a" id="r_a6f152d3559b409b233e7d64b13978e9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f152d3559b409b233e7d64b13978e9a">is_mixed</a> () const noexcept</td></tr>
<tr class="memdesc:a6f152d3559b409b233e7d64b13978e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if element is a mixed element.  <br /></td></tr>
<tr class="memitem:a1748329b8783fbecb5641df06761445b" id="r_a1748329b8783fbecb5641df06761445b"><td class="memItemLeft" align="right" valign="top"><a id="a1748329b8783fbecb5641df06761445b" name="a1748329b8783fbecb5641df06761445b"></a>
const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sub_elements</b> () const noexcept</td></tr>
<tr class="memdesc:a1748329b8783fbecb5641df06761445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get subelements (if any) <br /></td></tr>
<tr class="memitem:a4cbfdcabcaf4ba9f8083ad84cba82717" id="r_a4cbfdcabcaf4ba9f8083ad84cba82717"><td class="memItemLeft" align="right" valign="top"><a id="a4cbfdcabcaf4ba9f8083ad84cba82717" name="a4cbfdcabcaf4ba9f8083ad84cba82717"></a>
std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>extract_sub_element</b> (const std::vector&lt; int &gt; &amp;component) const</td></tr>
<tr class="memdesc:a4cbfdcabcaf4ba9f8083ad84cba82717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract sub finite element for component. <br /></td></tr>
<tr class="memitem:ab65e0ed248053420d4fe672743526e29" id="r_ab65e0ed248053420d4fe672743526e29"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/de0/classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab65e0ed248053420d4fe672743526e29">basix_element</a> () const</td></tr>
<tr class="memdesc:ab65e0ed248053420d4fe672743526e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return underlying Basix element (if it exists).  <br /></td></tr>
<tr class="memitem:a1ea0e3c46b6922df927b7a7f9e282543" id="r_a1ea0e3c46b6922df927b7a7f9e282543"><td class="memItemLeft" align="right" valign="top"><a id="a1ea0e3c46b6922df927b7a7f9e282543" name="a1ea0e3c46b6922df927b7a7f9e282543"></a>
basix::maps::type&#160;</td><td class="memItemRight" valign="bottom"><b>map_type</b> () const</td></tr>
<tr class="memdesc:a1ea0e3c46b6922df927b7a7f9e282543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the map type used by the element. <br /></td></tr>
<tr class="memitem:ae813cd4de1512a7c830fa06928e54a5c" id="r_ae813cd4de1512a7c830fa06928e54a5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae813cd4de1512a7c830fa06928e54a5c">interpolation_ident</a> () const noexcept</td></tr>
<tr class="memitem:affcae09c2dd151ee8690bbaf72c9501d" id="r_affcae09c2dd151ee8690bbaf72c9501d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcae09c2dd151ee8690bbaf72c9501d">map_ident</a> () const noexcept</td></tr>
<tr class="memitem:a4795328c7dfe5bacf6c0880f0e121c49" id="r_a4795328c7dfe5bacf6c0880f0e121c49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;, std::array&lt; std::size_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4795328c7dfe5bacf6c0880f0e121c49">interpolation_points</a> () const</td></tr>
<tr class="memdesc:a4795328c7dfe5bacf6c0880f0e121c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points on the reference cell at which an expression needs to be evaluated in order to interpolate the expression in the finite element space.  <br /></td></tr>
<tr class="memitem:acc6d79ccffff00858387e970cb72005f" id="r_acc6d79ccffff00858387e970cb72005f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;, std::array&lt; std::size_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc6d79ccffff00858387e970cb72005f">interpolation_operator</a> () const</td></tr>
<tr class="memitem:a1bc0dd776fa1f15b66ef9a54ff2b34d1" id="r_a1bc0dd776fa1f15b66ef9a54ff2b34d1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;, std::array&lt; std::size_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bc0dd776fa1f15b66ef9a54ff2b34d1">create_interpolation_operator</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;from) const</td></tr>
<tr class="memdesc:a1bc0dd776fa1f15b66ef9a54ff2b34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix that maps degrees of freedom from one element to this element (interpolation).  <br /></td></tr>
<tr class="memitem:a42dab99126ab3dbc778779339f0dee55" id="r_a42dab99126ab3dbc778779339f0dee55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42dab99126ab3dbc778779339f0dee55">needs_dof_transformations</a> () const noexcept</td></tr>
<tr class="memdesc:a42dab99126ab3dbc778779339f0dee55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if DOF transformations are needed for this element.  <br /></td></tr>
<tr class="memitem:a537fdd7e0f98c10bd48ef5a6c2996ce9" id="r_a537fdd7e0f98c10bd48ef5a6c2996ce9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a537fdd7e0f98c10bd48ef5a6c2996ce9">needs_dof_permutations</a> () const noexcept</td></tr>
<tr class="memdesc:a537fdd7e0f98c10bd48ef5a6c2996ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if DOF permutations are needed for this element.  <br /></td></tr>
<tr class="memitem:a8132205a4a5f59b93457378c8a6b0e3e" id="r_a8132205a4a5f59b93457378c8a6b0e3e"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a8132205a4a5f59b93457378c8a6b0e3e template"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(std::span&lt; U &gt;, std::span&lt; const std::uint32_t &gt;, std::int32_t, int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8132205a4a5f59b93457378c8a6b0e3e">dof_transformation_fn</a> (<a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eb">doftransform</a> ttype, bool scalar_element=false) const</td></tr>
<tr class="memdesc:a8132205a4a5f59b93457378c8a6b0e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function that applies a DOF transformation operator to some data (see <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>).  <br /></td></tr>
<tr class="memitem:adb4090c80d1f30bd5cd70ee567d73702" id="r_adb4090c80d1f30bd5cd70ee567d73702"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:adb4090c80d1f30bd5cd70ee567d73702 template"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(std::span&lt; U &gt;, std::span&lt; const std::uint32_t &gt;, std::int32_t, int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb4090c80d1f30bd5cd70ee567d73702">dof_transformation_right_fn</a> (<a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eb">doftransform</a> ttype, bool scalar_element=false) const</td></tr>
<tr class="memdesc:adb4090c80d1f30bd5cd70ee567d73702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function that applies DOF transformation to some transposed data (see <a class="el" href="#a4d27b2f1d7150c2ce6b4722ab4317448" title="Right(post)-apply the operator applied by T_apply().">T_apply_right()</a>).  <br /></td></tr>
<tr class="memitem:a1c53714027d374410eceb256ae129632" id="r_a1c53714027d374410eceb256ae129632"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a1c53714027d374410eceb256ae129632 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c53714027d374410eceb256ae129632">T_apply</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:a1c53714027d374410eceb256ae129632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basis functions from the reference element ordering and orientation to the globally consistent physical element ordering and orientation.  <br /></td></tr>
<tr class="memitem:a4583796c0195c7ee0eb8e3dbdc270522" id="r_a4583796c0195c7ee0eb8e3dbdc270522"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a4583796c0195c7ee0eb8e3dbdc270522 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4583796c0195c7ee0eb8e3dbdc270522">Tt_inv_apply</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:a4583796c0195c7ee0eb8e3dbdc270522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:ac2c4ae2b7844245eaca60bfad5644609" id="r_ac2c4ae2b7844245eaca60bfad5644609"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ac2c4ae2b7844245eaca60bfad5644609 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c4ae2b7844245eaca60bfad5644609">Tt_apply</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:ac2c4ae2b7844245eaca60bfad5644609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:a19ca3a56d5409c5b22206ff3f04e08ee" id="r_a19ca3a56d5409c5b22206ff3f04e08ee"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a19ca3a56d5409c5b22206ff3f04e08ee template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19ca3a56d5409c5b22206ff3f04e08ee">Tinv_apply</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:a19ca3a56d5409c5b22206ff3f04e08ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:a4d27b2f1d7150c2ce6b4722ab4317448" id="r_a4d27b2f1d7150c2ce6b4722ab4317448"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a4d27b2f1d7150c2ce6b4722ab4317448 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d27b2f1d7150c2ce6b4722ab4317448">T_apply_right</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:a4d27b2f1d7150c2ce6b4722ab4317448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:af75f91a8f13b66b1ed9d245e790388c3" id="r_af75f91a8f13b66b1ed9d245e790388c3"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:af75f91a8f13b66b1ed9d245e790388c3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af75f91a8f13b66b1ed9d245e790388c3">Tinv_apply_right</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:af75f91a8f13b66b1ed9d245e790388c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:acff5768975f264f0eeaa521af586ea9c" id="r_acff5768975f264f0eeaa521af586ea9c"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:acff5768975f264f0eeaa521af586ea9c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff5768975f264f0eeaa521af586ea9c">Tt_apply_right</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:acff5768975f264f0eeaa521af586ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:a39ace9c41b11d8a3293ab4b8c28a02b2" id="r_a39ace9c41b11d8a3293ab4b8c28a02b2"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a39ace9c41b11d8a3293ab4b8c28a02b2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ace9c41b11d8a3293ab4b8c28a02b2">Tt_inv_apply_right</a> (std::span&lt; U &gt; data, std::uint32_t cell_permutation, int n) const</td></tr>
<tr class="memdesc:a39ace9c41b11d8a3293ab4b8c28a02b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right(post)-apply the transpose inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>.  <br /></td></tr>
<tr class="memitem:ae34c915742f462093322bb19661dbb54" id="r_ae34c915742f462093322bb19661dbb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34c915742f462093322bb19661dbb54">permute</a> (std::span&lt; std::int32_t &gt; doflist, std::uint32_t cell_permutation) const</td></tr>
<tr class="memdesc:ae34c915742f462093322bb19661dbb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute indices associated with degree-of-freedoms on the reference element ordering to the globally consistent physical element degree-of-freedom ordering.  <br /></td></tr>
<tr class="memitem:a4985b37878a81d18f5dc5feba22d786b" id="r_a4985b37878a81d18f5dc5feba22d786b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4985b37878a81d18f5dc5feba22d786b">permute_inv</a> (std::span&lt; std::int32_t &gt; doflist, std::uint32_t cell_permutation) const</td></tr>
<tr class="memdesc:a4985b37878a81d18f5dc5feba22d786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse of the operation applied by <a class="el" href="#ae34c915742f462093322bb19661dbb54" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a>.  <br /></td></tr>
<tr class="memitem:abd5c76ec672257a91d09bc1fe4d7018f" id="r_abd5c76ec672257a91d09bc1fe4d7018f"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd5c76ec672257a91d09bc1fe4d7018f">dof_permutation_fn</a> (bool <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5ebaa91c78e040f7b9d158f381e197f8beb4">inverse</a>=false, bool scalar_element=false) const</td></tr>
<tr class="memdesc:abd5c76ec672257a91d09bc1fe4d7018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function that applies a degree-of-freedom permutation to some data.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::floating_point T&gt;<br />
class dolfinx::fem::FiniteElement&lt; T &gt;</div><p>Model of a finite element. </p>
<p>Provides the dof layout on a reference element, and various methods for evaluating and transforming the basis. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01b0b7e407f22cf7ef943d0eb6eea23f" name="a01b0b7e407f22cf7ef943d0eb6eea23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b0b7e407f22cf7ef943d0eb6eea23f">&#9670;&#160;</a></span>FiniteElement() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de0/classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::vector&lt; std::size_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value_shape</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>symmetric</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a finite element from a Basix finite element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Basix finite element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td>Value shape for blocked element, e.g. <span class="tt">{3}</span> for a vector in 3D or <span class="tt">{2, 2}</span> for a rank-2 tensor in 2D. Can only be set for blocked scalar <span class="tt">element</span>. For other elements and scalar elements it should be <span class="tt">std::nullopt</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetric</td><td>Is the element a symmetric tensor? Should only set for 2nd-order tensor blocked elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc24e0a4a9f80f9973a4dd0bff6d04e0" name="abc24e0a4a9f80f9973a4dd0bff6d04e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc24e0a4a9f80f9973a4dd0bff6d04e0">&#9670;&#160;</a></span>FiniteElement() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../db/da6/structdolfinx_1_1fem_1_1BasixElementData.html">BasixElementData</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mixed finite element from Basix finite elements. </p>
<p>See <a class="el" href="#ad4ad1e8de503b85319ba1dc63eb566f3" title="Create a mixed finite element from a list of finite elements.">FiniteElement(const std::vector&lt;std::shared_ptr&lt;const
FiniteElement&lt;geometry_type&gt;&gt;&gt;&amp;)</a> for a discussion of mixed elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>List of (Basix finite element, block size, symmetric) tuples, one for each element in the mixed element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ad1e8de503b85319ba1dc63eb566f3" name="ad4ad1e8de503b85319ba1dc63eb566f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ad1e8de503b85319ba1dc63eb566f3">&#9670;&#160;</a></span>FiniteElement() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mixed finite element from a list of finite elements. </p>
<p>This constructs a mixed element  \(E_0 \times E_1 \times \ldots
\times E_{n-1}\). The *i*th sub-element \(E_i\) can be accessed by <a class="el" href="#a4cbfdcabcaf4ba9f8083ad84cba82717" title="Extract sub finite element for component.">extract_sub_element</a>. Functions defined on mixed element spaces cannot be interpolated into directly. It is necessary to first extract a sub-Function (view), which can then be interpolated into.</p>
<p>A mixed element can be constructed from one element. In this case the <span class="tt"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html" title="Model of a finite element.">FiniteElement</a></span> behaves like a mixed element and cannot be interpolated into. The underlying element can be accessed using <a class="el" href="#a4cbfdcabcaf4ba9f8083ad84cba82717" title="Extract sub finite element for component.">extract_sub_element</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Finite elements to compose the mixed element from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c1ea61faead81d403281f4ba9e3779a" name="a9c1ea61faead81d403281f4ba9e3779a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1ea61faead81d403281f4ba9e3779a">&#9670;&#160;</a></span>FiniteElement() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>pshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>value_shape</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>symmetric</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a quadrature element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>Cell type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Quadrature points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pshape</td><td>Shape of <span class="tt">points</span> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_shape</td><td>Value shape for the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetric</td><td>Is the element a symmetric tensor? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ab65e0ed248053420d4fe672743526e29" name="ab65e0ed248053420d4fe672743526e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65e0ed248053420d4fe672743526e29">&#9670;&#160;</a></span>basix_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/de0/classbasix_1_1FiniteElement.html">basix::FiniteElement</a>&lt; T &gt; &amp; basix_element </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return underlying Basix element (if it exists). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>a std::runtime_error is there no Basix element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd3f76c0eb872b28ffb94a427332686f" name="acd3f76c0eb872b28ffb94a427332686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3f76c0eb872b28ffb94a427332686f">&#9670;&#160;</a></span>block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int block_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block size of the finite element function space. </p>
<p>For non-blocked elements, this is always 1. For blocked elements, this is the number of DOFs collocated at each DOF point. For blocked elements the block size is equal to the value size, except for symmetric rank-2 tensor blocked elements. For a symmetric rank-2 tensor blocked element the block size is 3 in 2D and 6 in 3D.</p>
<dl class="section return"><dt>Returns</dt><dd>Block size of the finite element space. </dd></dl>

</div>
</div>
<a id="a1bc0dd776fa1f15b66ef9a54ff2b34d1" name="a1bc0dd776fa1f15b66ef9a54ff2b34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0dd776fa1f15b66ef9a54ff2b34d1">&#9670;&#160;</a></span>create_interpolation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, std::array&lt; std::size_t, 2 &gt; &gt; create_interpolation_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matrix that maps degrees of freedom from one element to this element (interpolation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The element to interpolate from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix operator that maps the <span class="tt">from</span> degrees-of-freedom to the degrees-of-freedom of this element. The (0) matrix data (row-major storage) and (1) the shape (num_dofs of <span class="tt">this</span> element, num_dofs of <span class="tt">from</span>) are returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The two elements must use the same mapping between the reference and physical cells. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not support mixed elements. </dd></dl>

</div>
</div>
<a id="abd5c76ec672257a91d09bc1fe4d7018f" name="abd5c76ec672257a91d09bc1fe4d7018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c76ec672257a91d09bc1fe4d7018f">&#9670;&#160;</a></span>dof_permutation_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt; dof_permutation_fn </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inverse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar_element</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a function that applies a degree-of-freedom permutation to some data. </p>
<p>The returned function can apply <a class="el" href="#ae34c915742f462093322bb19661dbb54" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a> to mixed-elements.</p>
<p>The signature of the returned function has three arguments:</p><ul>
<li>[in,out] doflist The numbers of the DOFs, a span of length num_dofs</li>
<li>[in] cell_permutation Permutation data for the cell</li>
<li>[in] block_size The block_size of the input data</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inverse</td><td>Indicates if the inverse transformation should be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_element</td><td>Indicates is the scalar transformations should be returned for a vector element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8132205a4a5f59b93457378c8a6b0e3e" name="a8132205a4a5f59b93457378c8a6b0e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8132205a4a5f59b93457378c8a6b0e3e">&#9670;&#160;</a></span>dof_transformation_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(std::span&lt; U &gt;, std::span&lt; const std::uint32_t &gt;, std::int32_t, int)&gt; dof_transformation_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eb">doftransform</a></td>          <td class="paramname"><span class="paramname"><em>ttype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar_element</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a function that applies a DOF transformation operator to some data (see <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>). </p>
<p>The transformation is applied from the left-hand side, i.e. </p><p class="formulaDsp">
\[ u \leftarrow T u. \]
</p>
<p>If the transformation for the (sub)element is a permutation only, the returned function will do change the ordering for the (sub)element as it is assumed that permutations are incorporated into the degree-of-freedom map.</p>
<p>See the documentation for <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a> for a description of the transformation for a single element type. This function generates a function that can apply the transformation to a mixed element.</p>
<p>The signature of the returned function has four arguments:</p><ul>
<li>[in,out] data The data to be transformed. This data is flattened with row-major layout, shape=(num_dofs, block_size)</li>
<li>[in] cell_info Permutation data for the cell. The size of this is num_cells. For elements where no transformations are required, an empty span can be passed in.</li>
<li>[in] cell The cell number.</li>
<li>[in] n The block_size of the input data.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ttype</td><td>The transformation type. Typical usage is:<ul>
<li><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5ebac00f0c4675b91fb8b918e4079a0b1bac" title="Standard.">doftransform::standard</a> Transforms <em>basis function data</em> from the reference element to the conforming 'physical' element, e.g. \(\phi = T \tilde{\phi}\).</li>
<li><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eba382eb179a7d78f25d89c085988b37e95" title="Transpose.">doftransform::transpose</a> Transforms <em>degree-of-freedom data</em> from the conforming (physical) ordering to the reference ordering, e.g. \(\tilde{u} = T^{T} u\).</li>
<li><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5ebaa91c78e040f7b9d158f381e197f8beb4" title="Inverse.">doftransform::inverse</a>: Transforms <em>basis function data</em> from the the conforming (physical) ordering to the reference ordering, e.g. \(\tilde{\phi} = T^{-1} \phi\).</li>
<li><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eba4cceecb0ec73b0cd387faae5e5301f40" title="Transpose inverse.">doftransform::inverse_transpose</a>: Transforms <em>degree-of-freedom data</em> from the reference element to the conforming (physical) ordering, e.g. \(u = T^{-t} \tilde{u}\). </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_element</td><td>Indicates whether the scalar transformations should be returned for a vector element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb4090c80d1f30bd5cd70ee567d73702" name="adb4090c80d1f30bd5cd70ee567d73702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4090c80d1f30bd5cd70ee567d73702">&#9670;&#160;</a></span>dof_transformation_right_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(std::span&lt; U &gt;, std::span&lt; const std::uint32_t &gt;, std::int32_t, int)&gt; dof_transformation_right_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a86418c4371281a95280155a7e717c5eb">doftransform</a></td>          <td class="paramname"><span class="paramname"><em>ttype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar_element</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a function that applies DOF transformation to some transposed data (see <a class="el" href="#a4d27b2f1d7150c2ce6b4722ab4317448" title="Right(post)-apply the operator applied by T_apply().">T_apply_right()</a>). </p>
<p>The transformation is applied from the right-hand side, i.e. </p><p class="formulaDsp">
\[ u^{t} \leftarrow u^{t} T. \]
</p>
<p>If the transformation for the (sub)element is a permutation only, the returned function will do change the ordering for the (sub)element as it is assumed that permutations are incorporated into the degree-of-freedom map.</p>
<p>The signature of the returned function has four arguments:</p><ul>
<li>[in,out] data The data to be transformed. This data is flattened with row-major layout, shape=(num_dofs, block_size)</li>
<li>[in] cell_info Permutation data for the cell. The size of this is num_cells. For elements where no transformations are required, an empty span can be passed in.</li>
<li>[in] cell The cell number</li>
<li>[in] block_size The block_size of the input data</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ttype</td><td>Transformation type. See <a class="el" href="#a8132205a4a5f59b93457378c8a6b0e3e" title="Return a function that applies a DOF transformation operator to some data (see T_apply()).">dof_transformation_fn()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_element</td><td>Indicate if the scalar transformations should be returned for a vector element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae813cd4de1512a7c830fa06928e54a5c" name="ae813cd4de1512a7c830fa06928e54a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae813cd4de1512a7c830fa06928e54a5c">&#9670;&#160;</a></span>interpolation_ident()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool interpolation_ident </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if interpolation into the finite element space is an identity operation given the evaluation on an expression at specific points, i.e. the degree-of-freedom are equal to point evaluations. The function will return <span class="tt">true</span> for Lagrange elements. </p><dl class="section return"><dt>Returns</dt><dd>True if interpolation is an identity operation </dd></dl>

</div>
</div>
<a id="acc6d79ccffff00858387e970cb72005f" name="acc6d79ccffff00858387e970cb72005f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6d79ccffff00858387e970cb72005f">&#9670;&#160;</a></span>interpolation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, std::array&lt; std::size_t, 2 &gt; &gt; interpolation_operator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolation operator (matrix) <span class="tt">Pi</span> that maps a function evaluated at the points provided by <a class="el" href="#a4795328c7dfe5bacf6c0880f0e121c49" title="Points on the reference cell at which an expression needs to be evaluated in order to interpolate the...">FiniteElement::interpolation_points</a> to the element degrees of freedom, i.e. dofs = Pi f_x. See the Basix documentation for basix::FiniteElement::interpolation_matrix for how the data in <span class="tt">f_x</span> should be ordered. </p><dl class="section return"><dt>Returns</dt><dd>The interpolation operator <span class="tt">Pi</span>, returning the data for <span class="tt">Pi</span> (row-major storage) and the shape <span class="tt">(num_dofs, num_points *
/ value_size)</span> </dd></dl>

</div>
</div>
<a id="a4795328c7dfe5bacf6c0880f0e121c49" name="a4795328c7dfe5bacf6c0880f0e121c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4795328c7dfe5bacf6c0880f0e121c49">&#9670;&#160;</a></span>interpolation_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, std::array&lt; std::size_t, 2 &gt; &gt; interpolation_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Points on the reference cell at which an expression needs to be evaluated in order to interpolate the expression in the finite element space. </p>
<p>For Lagrange elements the points will just be the nodal positions. For other elements the points will typically be the quadrature points used to evaluate moment degrees of freedom. </p><dl class="section return"><dt>Returns</dt><dd>Interpolation point coordinates on the reference cell, returning the (0) coordinates data (row-major) storage and (1) the shape <span class="tt">(num_points, tdim)</span>. </dd></dl>

</div>
</div>
<a id="a6f152d3559b409b233e7d64b13978e9a" name="a6f152d3559b409b233e7d64b13978e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f152d3559b409b233e7d64b13978e9a">&#9670;&#160;</a></span>is_mixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_mixed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if element is a mixed element. </p>
<p>A mixed element is composed of two or more elements of different types. A blocked element, e.g. a Lagrange element with block size &gt;= 1 is not considered mixed.</p>
<dl class="section return"><dt>Returns</dt><dd>True if element is mixed. </dd></dl>

</div>
</div>
<a id="affcae09c2dd151ee8690bbaf72c9501d" name="affcae09c2dd151ee8690bbaf72c9501d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcae09c2dd151ee8690bbaf72c9501d">&#9670;&#160;</a></span>map_ident()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool map_ident </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the push forward/pull back map from the values on reference to the values on a physical cell for this element is the identity map. </p><dl class="section return"><dt>Returns</dt><dd>True if the map is the identity </dd></dl>

</div>
</div>
<a id="a537fdd7e0f98c10bd48ef5a6c2996ce9" name="a537fdd7e0f98c10bd48ef5a6c2996ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537fdd7e0f98c10bd48ef5a6c2996ce9">&#9670;&#160;</a></span>needs_dof_permutations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool needs_dof_permutations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if DOF permutations are needed for this element. </p>
<p>DOF permutations will be needed for elements which might not be continuous when two neighbouring cells disagree on the orientation of a shared subentity, and when this can be corrected for by permuting the DOF numbering in the dofmap.</p>
<p>For example, higher order Lagrange elements will need DOF permutations, as the arrangement of DOFs on a shared sub-entity may be different from the point of view of neighbouring cells, and this can be corrected for by permuting the DOF numbers on each cell.</p>
<dl class="section return"><dt>Returns</dt><dd>True if DOF transformations are required. </dd></dl>

</div>
</div>
<a id="a42dab99126ab3dbc778779339f0dee55" name="a42dab99126ab3dbc778779339f0dee55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42dab99126ab3dbc778779339f0dee55">&#9670;&#160;</a></span>needs_dof_transformations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool needs_dof_transformations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if DOF transformations are needed for this element. </p>
<p>DOF transformations will be needed for elements which might not be continuous when two neighbouring cells disagree on the orientation of a shared sub-entity, and when this cannot be corrected for by permuting the DOF numbering in the dofmap.</p>
<p>For example, Raviart-Thomas elements will need DOF transformations, as the neighbouring cells may disagree on the orientation of a basis function, and this orientation cannot be corrected for by permuting the DOF numbers on each cell.</p>
<dl class="section return"><dt>Returns</dt><dd>True if DOF transformations are required. </dd></dl>

</div>
</div>
<a id="abf6d258f77b4060f5d259fe7e877709b" name="abf6d258f77b4060f5d259fe7e877709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6d258f77b4060f5d259fe7e877709b">&#9670;&#160;</a></span>num_sub_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int num_sub_elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of sub elements (for a mixed or blocked element). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of sub elements. </dd></dl>

</div>
</div>
<a id="a9382c35cf56595f89617732cb1b0eba3" name="a9382c35cf56595f89617732cb1b0eba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9382c35cf56595f89617732cb1b0eba3">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two elements are not equivalent. </p>
<dl class="section return"><dt>Returns</dt><dd>True is the two elements are not the same. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equality can be checked only for non-mixed elements. For a mixed element, this function will raise an exception. </dd></dl>

</div>
</div>
<a id="afa62c95fee8cd0b22a4a272ba67bddbf" name="afa62c95fee8cd0b22a4a272ba67bddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa62c95fee8cd0b22a4a272ba67bddbf">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two elements are equivalent. </p>
<dl class="section return"><dt>Returns</dt><dd>True is the two elements are the same. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equality can be checked only for non-mixed elements. For a mixed element, this function will throw an exception. </dd></dl>

</div>
</div>
<a id="ae34c915742f462093322bb19661dbb54" name="ae34c915742f462093322bb19661dbb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c915742f462093322bb19661dbb54">&#9670;&#160;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void permute </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>doflist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute indices associated with degree-of-freedoms on the reference element ordering to the globally consistent physical element degree-of-freedom ordering. </p>
<p>Given an array \(\tilde{d}\) that holds an integer associated with each degree-of-freedom and following the reference element degree-of-freedom ordering, this function computes </p><p class="formulaDsp">
\[ d = P \tilde{d},\]
</p>
<p> where \(P\) is a permutation matrix and \(d\) holds the integers in \(\tilde{d}\) but permuted to follow the globally consistent physical element degree-of-freedom ordering. The permutation is computed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">doflist</td><td>Indices associated with the degrees-of-freedom. Size=<span class="tt">num_dofs</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4985b37878a81d18f5dc5feba22d786b" name="a4985b37878a81d18f5dc5feba22d786b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4985b37878a81d18f5dc5feba22d786b">&#9670;&#160;</a></span>permute_inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void permute_inv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>doflist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the inverse of the operation applied by <a class="el" href="#ae34c915742f462093322bb19661dbb54" title="Permute indices associated with degree-of-freedoms on the reference element ordering to the globally ...">permute()</a>. </p>
<p>Given an array \(d\) that holds an integer associated with each degree-of-freedom and following the globally consistent physical element degree-of-freedom ordering, this function computes   </p><p class="formulaDsp">
\[ \tilde{d} = P^{T} d,
\]
</p>
<p> where \(P^{T}\) is a permutation matrix and \(\tilde{d}\) holds the integers in \(d\) but permuted to follow the reference element degree-of-freedom ordering. The permutation is computed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">doflist</td><td>Indices associated with the degrees-of-freedom. Size=<span class="tt">num_dofs</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceb716e9df8e32218f50a9c8e7b178f7" name="aceb716e9df8e32218f50a9c8e7b178f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb716e9df8e32218f50a9c8e7b178f7">&#9670;&#160;</a></span>reference_value_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::size_t &gt; reference_value_shape </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value shape of the base (non-blocked) finite element field. </p>
<p>For non-blocked elements, this function returns the same as <a class="el" href="#a1b889a645fc12e661a150711914fb46a" title="Value shape of the finite element field.">FiniteElement::value_shape</a>. For blocked and quadrature elements the returned shape will be <span class="tt">{}</span>.</p>
<p>Mixed elements do not have a reference value shape.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>is thrown for a mixed element as mixed elements do not have a value shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value shape. </dd></dl>

</div>
</div>
<a id="a78737d3c0a9c143fa24c503cac16d519" name="a78737d3c0a9c143fa24c503cac16d519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78737d3c0a9c143fa24c503cac16d519">&#9670;&#160;</a></span>reference_value_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int reference_value_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value size of the base (non-blocked) finite element field. </p>
<p>The reference value size is the product of the reference value shape, e.g. it is 1 for a scalar element, 2 for a 2D (non-blocked) vector, 9 for a (non-blocked) second-order tensor in 3D, etc.</p>
<p>For blocked elements, this function returns the value shape for the 'base' element from which the blocked element is composed. For other elements, the return value is the same as <a class="el" href="#a1b889a645fc12e661a150711914fb46a" title="Value shape of the finite element field.">FiniteElement::value_shape</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>is thrown for a mixed element as mixed elements do not have a value shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value size. </dd></dl>

</div>
</div>
<a id="a508f93d3a34146afe1d2ed248b0ed225" name="a508f93d3a34146afe1d2ed248b0ed225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508f93d3a34146afe1d2ed248b0ed225">&#9670;&#160;</a></span>signature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string signature </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String identifying the finite element. </p>
<dl class="section return"><dt>Returns</dt><dd>Element signature </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function is provided for convenience, but it should not be relied upon for determining the element type. Use other functions, commonly returning enums, to determine element properties. </dd></dl>

</div>
</div>
<a id="a2585c6e4d6d6133186cdc237e0ce9cfc" name="a2585c6e4d6d6133186cdc237e0ce9cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2585c6e4d6d6133186cdc237e0ce9cfc">&#9670;&#160;</a></span>space_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int space_dimension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of the finite element function space (the number of degrees-of-freedom for the element). </p>
<p>For 'blocked' elements, this function returns the dimension of the full element rather than the dimension of the base element.</p>
<dl class="section return"><dt>Returns</dt><dd>Dimension of the finite element space. </dd></dl>

</div>
</div>
<a id="a1c53714027d374410eceb256ae129632" name="a1c53714027d374410eceb256ae129632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c53714027d374410eceb256ae129632">&#9670;&#160;</a></span>T_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void T_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform basis functions from the reference element ordering and orientation to the globally consistent physical element ordering and orientation. </p>
<p>Consider that the value of a finite element function \(f_{h}\) at a point is given by   </p><p class="formulaDsp">
\[ f_{h} = \phi^{T} c,
\]
</p>
<p> where \(f_{h}\) has shape \(r \times 1\), \(\phi\) has shape \(d \times r\) and holds the finite element basis functions, and \(c\) has shape \(d \times 1\) and holds the degrees-of-freedom. The basis functions and degree-of-freedom are with respect to the physical element orientation. If the degrees-of-freedom on the physical element orientation are given by   </p><p class="formulaDsp">
\[\phi = T \tilde{\phi},
\]
</p>
<p> where \(T\) is a \(d \times d\) matrix, it follows from \(f_{h} = \phi^{T} c = \tilde{\phi}^{T} T^{T} c\) that   </p><p class="formulaDsp">
\[ \tilde{c} = T^{T} c.
\]
</p>
<p>This function applies \(T\) to data. The transformation is performed in-place. The operator \(T\) is orthogonal for many elements, but not all.</p>
<p>This function calls the corresponding Basix function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to transform. The shape is <span class="tt">(m, n)</span>, where <span class="tt">m</span> is the number of dgerees-of-freedom and the storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns in <span class="tt">data</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d27b2f1d7150c2ce6b4722ab4317448" name="a4d27b2f1d7150c2ce6b4722ab4317448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27b2f1d7150c2ce6b4722ab4317448">&#9670;&#160;</a></span>T_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void T_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right(post)-apply the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ v^{T} = u^{T} T \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block size of the input data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ffa0a06971a6be314a82693c3d24bbb" name="a0ffa0a06971a6be314a82693c3d24bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa0a06971a6be314a82693c3d24bbb">&#9670;&#160;</a></span>tabulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, std::array&lt; std::size_t, 4 &gt; &gt; tabulate </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate all derivatives of the basis functions up to given order at given points in reference cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The reference coordinates at which to evaluate the basis functions. Shape is <span class="tt">(num_points, topological dimension)</span> (row-major storage). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Shape of <span class="tt">X</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Number of derivatives (up to and including this order) to tabulate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Basis function values and array shape (row-major storage). </dd></dl>

</div>
</div>
<a id="a34f72d0a2e110e2f3a3aab698136141f" name="a34f72d0a2e110e2f3a3aab698136141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f72d0a2e110e2f3a3aab698136141f">&#9670;&#160;</a></span>tabulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tabulate </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#aabcaf5af5c0b791f0d4826adb9b38607">geometry_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate derivatives of the basis functions up to given order at points in the reference cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Array that will be filled with the tabulated basis values. Must have shape <span class="tt">(num_derivatives, num_points,
/ num_dofs, reference_value_size)</span> (row-major storage) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The reference coordinates at which to evaluate the basis functions. Shape is <span class="tt">(num_points, topological dimension)</span> (row-major storage). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Shape of <span class="tt">X</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Number of derivatives (up to and including this order) to tabulate for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19ca3a56d5409c5b22206ff3f04e08ee" name="a19ca3a56d5409c5b22206ff3f04e08ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ca3a56d5409c5b22206ff3f04e08ee">&#9670;&#160;</a></span>Tinv_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tinv_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ v = T^{-1} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block size of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af75f91a8f13b66b1ed9d245e790388c3" name="af75f91a8f13b66b1ed9d245e790388c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75f91a8f13b66b1ed9d245e790388c3">&#9670;&#160;</a></span>Tinv_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tinv_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right(post)-apply the inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ v^{T} = u^{T} T^{-1} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block size of the input data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2c4ae2b7844245eaca60bfad5644609" name="ac2c4ae2b7844245eaca60bfad5644609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4ae2b7844245eaca60bfad5644609">&#9670;&#160;</a></span>Tt_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tt_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ u \leftarrow  T^{T} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The block size of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acff5768975f264f0eeaa521af586ea9c" name="acff5768975f264f0eeaa521af586ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff5768975f264f0eeaa521af586ea9c">&#9670;&#160;</a></span>Tt_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tt_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right(post)-apply the transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ v^{T} = u^{T} T^{T} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to be transformed. The data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block size of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4583796c0195c7ee0eb8e3dbdc270522" name="a4583796c0195c7ee0eb8e3dbdc270522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4583796c0195c7ee0eb8e3dbdc270522">&#9670;&#160;</a></span>Tt_inv_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tt_inv_apply </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the inverse transpose of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>The transformation </p><p class="formulaDsp">
\[ v = T^{-T} u \]
</p>
<p> is performed in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block_size of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39ace9c41b11d8a3293ab4b8c28a02b2" name="a39ace9c41b11d8a3293ab4b8c28a02b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ace9c41b11d8a3293ab4b8c28a02b2">&#9670;&#160;</a></span>Tt_inv_apply_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tt_inv_apply_right </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>cell_permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right(post)-apply the transpose inverse of the operator applied by <a class="el" href="#a1c53714027d374410eceb256ae129632" title="Transform basis functions from the reference element ordering and orientation to the globally consist...">T_apply()</a>. </p>
<p>Computes </p><p class="formulaDsp">
\[ v^{T} = u^{T} T^{-T} \]
</p>
<p> in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data to be transformed. This data is flattened with row-major layout, <span class="tt">shape=(num_dofs, block_size)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_permutation</td><td>Permutation data for the cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Block size of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b889a645fc12e661a150711914fb46a" name="a1b889a645fc12e661a150711914fb46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b889a645fc12e661a150711914fb46a">&#9670;&#160;</a></span>value_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::size_t &gt; value_shape </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value shape of the finite element field. </p>
<p>The value shape describes the shape of the finite element field, e.g. <span class="tt">{}</span> for a scalar, <span class="tt">{2}</span> for a vector in 2D, <span class="tt">{3, 3}</span> for a rank-2 tensor in 3D, etc.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>is thrown for a mixed element as mixed elements do not have a value shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value shape. </dd></dl>

</div>
</div>
<a id="a7d326295a6362a9b6f112e0efa5a7de7" name="a7d326295a6362a9b6f112e0efa5a7de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d326295a6362a9b6f112e0efa5a7de7">&#9670;&#160;</a></span>value_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int value_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value size of the finite element field. </p>
<p>The value size is the number of components in the finite element field. It is the product of the value shape, e.g. is is 1 for a scalar function, 2 for a 2D vector, 9 for a second-order tensor in 3D, etc. For blocked elements, this function returns the value size for the full 'blocked' element.</p>
<dl class="section note"><dt>Note</dt><dd>The return value of this function is inconsistent with <a class="el" href="#a1b889a645fc12e661a150711914fb46a" title="Value shape of the finite element field.">value_shape()</a> for rank-2 'symmetric' elements. Due to issues elsewhere in the code base, rank-2 symmetric fields have value shape <span class="tt">{3}</span> (2D) or <span class="tt">{6}</span> rather than <span class="tt">{2, 2}</span> and <span class="tt">{3, 3}</span>, respectively. For symmetric rank-2 tensors this function returns 4 for 2D cases and 9 for 3D cases. This inconsistency will be fixed in the future.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>is thrown for a mixed element as mixed elements do not have a value shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value size. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/fem/<a class="el" href="../../de/d83/FiniteElement_8h_source.html">FiniteElement.h</a></li>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/fem/<b>FiniteElement.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

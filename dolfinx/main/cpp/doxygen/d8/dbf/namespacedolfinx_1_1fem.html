<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::fem Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.10.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::fem Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Finite element method functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html">sparsitybuild</a></td></tr>
<tr class="memdesc:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for building sparsity patterns from degree-of-freedom maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da6/structdolfinx_1_1fem_1_1BasixElementData.html">BasixElementData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basix element holder.  <a href="../../db/da6/structdolfinx_1_1fem_1_1BasixElementData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html" title="Constant (in space) value which can be attached to a Form.">Constant</a> (in space) value which can be attached to a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <a href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">CoordinateElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree-of-freedom map.  <a href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> represents a mathematical expression evaluated at a pre-defined points on a reference cell.  <a href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model of a finite element.  <a href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A representation of finite element variational forms.  <a href="../../df/d02/classdolfinx_1_1fem_1_1Form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a finite element function space defined by a mesh, a finite element, and a local-to-global map of the degrees-of-freedom.  <a href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d73/structdolfinx_1_1fem_1_1integral__data.html">integral_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents integral data, containing the kernel, and a list of entities to integrate over and the indicies of the coefficient functions (relative to the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>) active for this integral.  <a href="../../dc/d73/structdolfinx_1_1fem_1_1integral__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dcb/conceptdolfinx_1_1fem_1_1MDSpan.html">MDSpan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd9/conceptdolfinx_1_1fem_1_1DofTransformKernel.html">DofTransformKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOF transform kernel concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da9/conceptdolfinx_1_1fem_1_1FEkernel.html">FEkernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite element cell kernel concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d25/conceptdolfinx_1_1fem_1_1MDSpan2.html">MDSpan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for mdspan of rank 1 or 2. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a86418c4371281a95280155a7e717c5eb" id="r_a86418c4371281a95280155a7e717c5eb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86418c4371281a95280155a7e717c5eb">doftransform</a> : std::uint8_t { <a class="el" href="#a86418c4371281a95280155a7e717c5ebac00f0c4675b91fb8b918e4079a0b1bac">standard</a> = 0
, <a class="el" href="#a86418c4371281a95280155a7e717c5eba382eb179a7d78f25d89c085988b37e95">transpose</a> = 1
, <a class="el" href="#a86418c4371281a95280155a7e717c5ebaa91c78e040f7b9d158f381e197f8beb4">inverse</a> = 2
, <a class="el" href="#a86418c4371281a95280155a7e717c5eba4cceecb0ec73b0cd387faae5e5301f40">inverse_transpose</a> = 3
 }</td></tr>
<tr class="memdesc:a86418c4371281a95280155a7e717c5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOF transformation type.  <a href="#a86418c4371281a95280155a7e717c5eb">More...</a><br /></td></tr>
<tr class="separator:a86418c4371281a95280155a7e717c5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00c421a0f3a4e925538ebc7a05f2962" id="r_ac00c421a0f3a4e925538ebc7a05f2962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> : std::int8_t { <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c">cell</a> = 0
, <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213">exterior_facet</a> = 1
, <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf">interior_facet</a> = 2
, <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a">vertex</a> = 3
 }</td></tr>
<tr class="memdesc:ac00c421a0f3a4e925538ebc7a05f2962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of integral.  <a href="#ac00c421a0f3a4e925538ebc7a05f2962">More...</a><br /></td></tr>
<tr class="separator:ac00c421a0f3a4e925538ebc7a05f2962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41aed9721a8d6bd3bd46a1da477ba093" id="r_a41aed9721a8d6bd3bd46a1da477ba093"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a41aed9721a8d6bd3bd46a1da477ba093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41aed9721a8d6bd3bd46a1da477ba093">tabulate_expression</a> (std::span&lt; T &gt; values, const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T, U &gt; &amp;e, md::mdspan&lt; const T, md::dextents&lt; std::size_t, 2 &gt; &gt; coeffs, std::span&lt; const T &gt; constants, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &amp;mesh, fem::MDSpan2 auto entities, std::optional&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::size_t &gt; &gt; element)</td></tr>
<tr class="memdesc:a41aed9721a8d6bd3bd46a1da477ba093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> on cells or facets.  <br /></td></tr>
<tr class="separator:a41aed9721a8d6bd3bd46a1da477ba093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508b91434bcce5ef52f48e390869b3c5" id="r_a508b91434bcce5ef52f48e390869b3c5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a508b91434bcce5ef52f48e390869b3c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a508b91434bcce5ef52f48e390869b3c5">tabulate_expression</a> (std::span&lt; T &gt; values, const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T, U &gt; &amp;e, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &amp;mesh, fem::MDSpan2 auto entities)</td></tr>
<tr class="memdesc:a508b91434bcce5ef52f48e390869b3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> on cells or facets.  <br /></td></tr>
<tr class="separator:a508b91434bcce5ef52f48e390869b3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d25266cbd72792f519fc92c9b9d3989" id="r_a6d25266cbd72792f519fc92c9b9d3989"><td class="memTemplParams" colspan="2"><a id="a6d25266cbd72792f519fc92c9b9d3989" name="a6d25266cbd72792f519fc92c9b9d3989"></a>
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T&gt; </td></tr>
<tr class="memitem:a6d25266cbd72792f519fc92c9b9d3989"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_coefficients_span</b> (const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a6d25266cbd72792f519fc92c9b9d3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a map of <code>std::span</code>s from a map of <code>std::vector</code>s. <br /></td></tr>
<tr class="separator:a6d25266cbd72792f519fc92c9b9d3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f314895ce73b6f0667dc7556cb1b3ab" id="r_a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f314895ce73b6f0667dc7556cb1b3ab">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;M, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients)</td></tr>
<tr class="memdesc:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar.  <br /></td></tr>
<tr class="separator:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac167a0c039f5a52846fb32ff121fd8ba" id="r_ac167a0c039f5a52846fb32ff121fd8ba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:ac167a0c039f5a52846fb32ff121fd8ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac167a0c039f5a52846fb32ff121fd8ba">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;M)</td></tr>
<tr class="memdesc:ac167a0c039f5a52846fb32ff121fd8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar.  <br /></td></tr>
<tr class="separator:ac167a0c039f5a52846fb32ff121fd8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb32526016191d2737c974d4bcfd5a" id="r_a2ccb32526016191d2737c974d4bcfd5a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a2ccb32526016191d2737c974d4bcfd5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ccb32526016191d2737c974d4bcfd5a">assemble_vector</a> (std::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;L, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients)</td></tr>
<tr class="memdesc:a2ccb32526016191d2737c974d4bcfd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector.  <br /></td></tr>
<tr class="separator:a2ccb32526016191d2737c974d4bcfd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13e0e8a617dbb55d18198e5de2211f9" id="r_ac13e0e8a617dbb55d18198e5de2211f9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:ac13e0e8a617dbb55d18198e5de2211f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac13e0e8a617dbb55d18198e5de2211f9">assemble_vector</a> (std::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;L)</td></tr>
<tr class="memdesc:ac13e0e8a617dbb55d18198e5de2211f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector.  <br /></td></tr>
<tr class="separator:ac13e0e8a617dbb55d18198e5de2211f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bec02da3849e6d552d5e10dcc4dca9" id="r_ae9bec02da3849e6d552d5e10dcc4dca9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:ae9bec02da3849e6d552d5e10dcc4dca9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9">apply_lifting</a> (std::span&lt; T &gt; b, std::vector&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &gt; a, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;constants, const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &gt; &amp;coeffs, const std::vector&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;bcs1, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;x0, T alpha)</td></tr>
<tr class="memdesc:ae9bec02da3849e6d552d5e10dcc4dca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraints). This modification is known as 'lifting'.  <br /></td></tr>
<tr class="separator:ae9bec02da3849e6d552d5e10dcc4dca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ed4d31c70d6bc3c9362d76a72bb42c" id="r_a26ed4d31c70d6bc3c9362d76a72bb42c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a26ed4d31c70d6bc3c9362d76a72bb42c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26ed4d31c70d6bc3c9362d76a72bb42c">apply_lifting</a> (std::span&lt; T &gt; b, std::vector&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &gt; a, const std::vector&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;bcs1, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;x0, T alpha)</td></tr>
<tr class="memdesc:a26ed4d31c70d6bc3c9362d76a72bb42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the right-hand side vector to account for constraints (Dirichlet boundary conditions constraints). This modification is known as 'lifting'.  <br /></td></tr>
<tr class="separator:a26ed4d31c70d6bc3c9362d76a72bb42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a03f1a72e1ccc0db29e1c78cba755" id="r_a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b0a03f1a72e1ccc0db29e1c78cba755">assemble_matrix</a> (la::MatSet&lt; T &gt; auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients, std::span&lt; const std::int8_t &gt; dof_marker0, std::span&lt; const std::int8_t &gt; dof_marker1)</td></tr>
<tr class="memdesc:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <br /></td></tr>
<tr class="separator:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b66f7d91c0c3bc935222ffbb97d9849" id="r_a8b66f7d91c0c3bc935222ffbb97d9849"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a8b66f7d91c0c3bc935222ffbb97d9849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b66f7d91c0c3bc935222ffbb97d9849">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs)</td></tr>
<tr class="memdesc:a8b66f7d91c0c3bc935222ffbb97d9849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <br /></td></tr>
<tr class="separator:a8b66f7d91c0c3bc935222ffbb97d9849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7d16fb5385e3dd2d94db2e5277f96" id="r_abff7d16fb5385e3dd2d94db2e5277f96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:abff7d16fb5385e3dd2d94db2e5277f96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abff7d16fb5385e3dd2d94db2e5277f96">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs)</td></tr>
<tr class="memdesc:abff7d16fb5385e3dd2d94db2e5277f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <br /></td></tr>
<tr class="separator:abff7d16fb5385e3dd2d94db2e5277f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd42eee23160562035e655ecb00c125d" id="r_acd42eee23160562035e655ecb00c125d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:acd42eee23160562035e655ecb00c125d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd42eee23160562035e655ecb00c125d">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const std::int8_t &gt; dof_marker0, std::span&lt; const std::int8_t &gt; dof_marker1)</td></tr>
<tr class="memdesc:acd42eee23160562035e655ecb00c125d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <br /></td></tr>
<tr class="separator:acd42eee23160562035e655ecb00c125d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2482e48a77b23eb1b433c81552a70467" id="r_a2482e48a77b23eb1b433c81552a70467"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T&gt; </td></tr>
<tr class="memitem:a2482e48a77b23eb1b433c81552a70467"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2482e48a77b23eb1b433c81552a70467">set_diagonal</a> (auto set_fn, std::span&lt; const std::int32_t &gt; rows, T diagonal=1.0)</td></tr>
<tr class="memdesc:a2482e48a77b23eb1b433c81552a70467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of a matrix for specified rows.  <br /></td></tr>
<tr class="separator:a2482e48a77b23eb1b433c81552a70467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f64bc74c372b5ebc33527c83121e7cd" id="r_a7f64bc74c372b5ebc33527c83121e7cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a7f64bc74c372b5ebc33527c83121e7cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f64bc74c372b5ebc33527c83121e7cd">set_diagonal</a> (auto set_fn, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs, T diagonal=1.0)</td></tr>
<tr class="memdesc:a7f64bc74c372b5ebc33527c83121e7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied.  <br /></td></tr>
<tr class="separator:a7f64bc74c372b5ebc33527c83121e7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cd6568b465fbe013715ad3d70190cb" id="r_a84cd6568b465fbe013715ad3d70190cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84cd6568b465fbe013715ad3d70190cb">locate_dofs_topological</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &amp;dofmap, int dim, std::span&lt; const std::int32_t &gt; entities, bool remote=true)</td></tr>
<tr class="memdesc:a84cd6568b465fbe013715ad3d70190cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological).  <br /></td></tr>
<tr class="separator:a84cd6568b465fbe013715ad3d70190cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3900051aa0e3357e04060065bf868149" id="r_a3900051aa0e3357e04060065bf868149"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3900051aa0e3357e04060065bf868149">locate_dofs_topological</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt;, 2 &gt; dofmaps, int dim, std::span&lt; const std::int32_t &gt; entities, bool remote=true)</td></tr>
<tr class="memdesc:a3900051aa0e3357e04060065bf868149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological).  <br /></td></tr>
<tr class="separator:a3900051aa0e3357e04060065bf868149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d39b240c84457b5d10674737d31c5" id="r_a7a0d39b240c84457b5d10674737d31c5"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, typename U&gt; </td></tr>
<tr class="memitem:a7a0d39b240c84457b5d10674737d31c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a0d39b240c84457b5d10674737d31c5">locate_dofs_geometrical</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;V, U marker_fn)</td></tr>
<tr class="memdesc:a7a0d39b240c84457b5d10674737d31c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees of freedom whose geometric coordinate is true for the provided marking function.  <br /></td></tr>
<tr class="separator:a7a0d39b240c84457b5d10674737d31c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b37280bf45c2ef336bd9cd054590be1" id="r_a5b37280bf45c2ef336bd9cd054590be1"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, typename U&gt; </td></tr>
<tr class="memitem:a5b37280bf45c2ef336bd9cd054590be1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b37280bf45c2ef336bd9cd054590be1">locate_dofs_geometrical</a> (std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; V, U marker_fn)</td></tr>
<tr class="separator:a5b37280bf45c2ef336bd9cd054590be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d8adc0d37028032b1ce8991062df2" id="r_a0e8d8adc0d37028032b1ce8991062df2"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, <a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> U = T&gt; </td></tr>
<tr class="memitem:a0e8d8adc0d37028032b1ce8991062df2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e8d8adc0d37028032b1ce8991062df2">discrete_curl</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;V0, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;V1, la::MatSet&lt; U &gt; auto &amp;&amp;mat_set)</td></tr>
<tr class="memdesc:a0e8d8adc0d37028032b1ce8991062df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a discrete curl operator.  <br /></td></tr>
<tr class="separator:a0e8d8adc0d37028032b1ce8991062df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e261c1fdfd61a1e629b82b2d0125e4b" id="r_a4e261c1fdfd61a1e629b82b2d0125e4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4e261c1fdfd61a1e629b82b2d0125e4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e261c1fdfd61a1e629b82b2d0125e4b">discrete_gradient</a> (<a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt; V0, std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt; V1, auto &amp;&amp;mat_set)</td></tr>
<tr class="memdesc:a4e261c1fdfd61a1e629b82b2d0125e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a discrete gradient operator.  <br /></td></tr>
<tr class="separator:a4e261c1fdfd61a1e629b82b2d0125e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c61a5c9cc2c1964a261c3a868cb4f" id="r_ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad46c61a5c9cc2c1964a261c3a868cb4f">interpolation_matrix</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V0, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V1, auto &amp;&amp;mat_set)</td></tr>
<tr class="memdesc:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble an interpolation operator matrix.  <br /></td></tr>
<tr class="separator:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24db86d7fd4cf42ce3bd41f9c6585618" id="r_a24db86d7fd4cf42ce3bd41f9c6585618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24db86d7fd4cf42ce3bd41f9c6585618">transpose_dofmap</a> (md::mdspan&lt; const std::int32_t, md::dextents&lt; std::size_t, 2 &gt; &gt; dofmap, std::int32_t num_cells)</td></tr>
<tr class="memdesc:a24db86d7fd4cf42ce3bd41f9c6585618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions.  <br /></td></tr>
<tr class="separator:a24db86d7fd4cf42ce3bd41f9c6585618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae243b5f1e53ad867535767929d8847be" id="r_ae243b5f1e53ad867535767929d8847be"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, std::vector&lt; std::vector&lt; std::int32_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae243b5f1e53ad867535767929d8847be">build_dofmap_data</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;element_dof_layouts, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn)</td></tr>
<tr class="separator:ae243b5f1e53ad867535767929d8847be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b987be652e3b4ad1f6c9a5f7c7ab25" id="r_a56b987be652e3b4ad1f6c9a5f7c7ab25"><td class="memTemplParams" colspan="2"><a id="a56b987be652e3b4ad1f6c9a5f7c7ab25" name="a56b987be652e3b4ad1f6c9a5f7c7ab25"></a>
template&lt;typename U, typename V, typename W&gt; </td></tr>
<tr class="memitem:a56b987be652e3b4ad1f6c9a5f7c7ab25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BasixElementData</b> (U element, V bs, W symmetry) -&gt; BasixElementData&lt; typename std::remove_cvref&lt; U &gt;::type::scalar_type &gt;</td></tr>
<tr class="memdesc:a56b987be652e3b4ad1f6c9a5f7c7ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type deduction helper. <br /></td></tr>
<tr class="separator:a56b987be652e3b4ad1f6c9a5f7c7ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68fed2204e6da434435b5b526923bd4" id="r_ae68fed2204e6da434435b5b526923bd4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T&gt; </td></tr>
<tr class="memitem:ae68fed2204e6da434435b5b526923bd4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt; &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae68fed2204e6da434435b5b526923bd4">common_function_spaces</a> (const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &gt; &gt; &amp;V)</td></tr>
<tr class="memdesc:ae68fed2204e6da434435b5b526923bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs.  <br /></td></tr>
<tr class="separator:ae68fed2204e6da434435b5b526923bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc75d761461ccee9de059fca268d90c6" id="r_afc75d761461ccee9de059fca268d90c6"><td class="memTemplParams" colspan="2"><a id="afc75d761461ccee9de059fca268d90c6" name="afc75d761461ccee9de059fca268d90c6"></a>
template&lt;typename U, typename V, typename W&gt; </td></tr>
<tr class="memitem:afc75d761461ccee9de059fca268d90c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FunctionSpace</b> (U mesh, V element, W dofmap) -&gt; FunctionSpace&lt; typename std::remove_cvref&lt; typename U::element_type &gt;::type::geometry_type::value_type &gt;</td></tr>
<tr class="memdesc:afc75d761461ccee9de059fca268d90c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type deduction. <br /></td></tr>
<tr class="separator:afc75d761461ccee9de059fca268d90c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f2326fdc33ea6c03797126e3fb0e3d" id="r_ae2f2326fdc33ea6c03797126e3fb0e3d"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ae2f2326fdc33ea6c03797126e3fb0e3d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2f2326fdc33ea6c03797126e3fb0e3d">interpolation_coords</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a>&lt; T &gt; &amp;element, const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;geometry, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:ae2f2326fdc33ea6c03797126e3fb0e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite element space.  <br /></td></tr>
<tr class="separator:ae2f2326fdc33ea6c03797126e3fb0e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e94bc10b18fa604c007524a859f8d7" id="r_a75e94bc10b18fa604c007524a859f8d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a75e94bc10b18fa604c007524a859f8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75e94bc10b18fa604c007524a859f8d7">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u, std::span&lt; const T &gt; f, std::array&lt; std::size_t, 2 &gt; fshape, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:a75e94bc10b18fa604c007524a859f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an evaluated expression f(x) in a finite element space.  <br /></td></tr>
<tr class="separator:a75e94bc10b18fa604c007524a859f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1767f94cb5cb5a06169d2d02acc101" id="r_a3c1767f94cb5cb5a06169d2d02acc101"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a3c1767f94cb5cb5a06169d2d02acc101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dd/da5/structdolfinx_1_1geometry_1_1PointOwnershipData.html">geometry::PointOwnershipData</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c1767f94cb5cb5a06169d2d02acc101">create_interpolation_data</a> (const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;geometry0, const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; T &gt; &amp;element0, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh1, std::span&lt; const std::int32_t &gt; cells, T padding)</td></tr>
<tr class="memdesc:a3c1767f94cb5cb5a06169d2d02acc101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data needed to interpolate finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>'s across different meshes.  <br /></td></tr>
<tr class="separator:a3c1767f94cb5cb5a06169d2d02acc101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bd6cb4e9b789ac77ab7dcfe9ad6240" id="r_af5bd6cb4e9b789ac77ab7dcfe9ad6240"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:af5bd6cb4e9b789ac77ab7dcfe9ad6240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5bd6cb4e9b789ac77ab7dcfe9ad6240">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u, const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;v, std::span&lt; const std::int32_t &gt; cells, const <a class="el" href="../../dd/da5/structdolfinx_1_1geometry_1_1PointOwnershipData.html">geometry::PointOwnershipData</a>&lt; U &gt; &amp;interpolation_data)</td></tr>
<tr class="memdesc:af5bd6cb4e9b789ac77ab7dcfe9ad6240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> defined on a mesh to a finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> defined on different (non-matching) mesh.  <br /></td></tr>
<tr class="separator:af5bd6cb4e9b789ac77ab7dcfe9ad6240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497916172c4db5b8f2de4e08fa2200bb" id="r_a497916172c4db5b8f2de4e08fa2200bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a497916172c4db5b8f2de4e08fa2200bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a497916172c4db5b8f2de4e08fa2200bb">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u1, std::span&lt; const std::int32_t &gt; cells1, const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u0, std::span&lt; const std::int32_t &gt; cells0)</td></tr>
<tr class="memdesc:a497916172c4db5b8f2de4e08fa2200bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to another <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> on the same (sub)mesh.  <br /></td></tr>
<tr class="separator:a497916172c4db5b8f2de4e08fa2200bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bb77b3d643db27d9e65e08a1c4b7b9" id="r_a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; T &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08bb77b3d643db27d9e65e08a1c4b7b9">allocate_coefficient_storage</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form, <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> integral_type, int id)</td></tr>
<tr class="memdesc:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for coefficients of a pair <code>(integral_type, / id)</code> from a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34293fe58acda313cb52fa5bf6af5c19" id="r_a34293fe58acda313cb52fa5bf6af5c19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a34293fe58acda313cb52fa5bf6af5c19"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34293fe58acda313cb52fa5bf6af5c19">allocate_coefficient_storage</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form)</td></tr>
<tr class="memdesc:a34293fe58acda313cb52fa5bf6af5c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for packed coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a34293fe58acda313cb52fa5bf6af5c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8db5346f987c894fa348b1b1af67bd" id="r_a8b8db5346f987c894fa348b1b1af67bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a8b8db5346f987c894fa348b1b1af67bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b8db5346f987c894fa348b1b1af67bd">pack_coefficients</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form, std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a8b8db5346f987c894fa348b1b1af67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a8b8db5346f987c894fa348b1b1af67bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb052f918ee0a5b9d3cb2b5057ad4107" id="r_acb052f918ee0a5b9d3cb2b5057ad4107"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:acb052f918ee0a5b9d3cb2b5057ad4107"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb052f918ee0a5b9d3cb2b5057ad4107">pack_coefficients</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; coeffs, std::span&lt; const int &gt; offsets, fem::MDSpan2 auto entities, std::span&lt; T &gt; c)</td></tr>
<tr class="memdesc:acb052f918ee0a5b9d3cb2b5057ad4107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficient data over a list of cells or facets.  <br /></td></tr>
<tr class="separator:acb052f918ee0a5b9d3cb2b5057ad4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7841d3655f0367d281ae38802e98e8" id="r_abc7841d3655f0367d281ae38802e98e8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:abc7841d3655f0367d281ae38802e98e8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc7841d3655f0367d281ae38802e98e8">pack_constants</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt; &gt; &gt; c)</td></tr>
<tr class="memdesc:abc7841d3655f0367d281ae38802e98e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack constants of an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> or <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> into a single array ready for assembly.  <br /></td></tr>
<tr class="separator:abc7841d3655f0367d281ae38802e98e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100ff6dbaf334a8588050b6d75ae70dc" id="r_a100ff6dbaf334a8588050b6d75ae70dc"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; <br />
requires std::convertible_to&lt; U, <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt;typename std::decay_t&lt;U&gt;::scalar_type, typename std::decay_t&lt;U&gt;::geometry_type&gt;&gt; or std::convertible_to&lt; U, <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt;typename std::decay_t&lt;U&gt;::scalar_type, typename std::decay_t&lt;U&gt;::geometry_type&gt;&gt;</td></tr>
<tr class="memitem:a100ff6dbaf334a8588050b6d75ae70dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename U::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a100ff6dbaf334a8588050b6d75ae70dc">pack_constants</a> (const U &amp;u)</td></tr>
<tr class="memdesc:a100ff6dbaf334a8588050b6d75ae70dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack constants of an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> or <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> into a single array ready for assembly.  <br /></td></tr>
<tr class="separator:a100ff6dbaf334a8588050b6d75ae70dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab852a47972daf9ace1f3443044f609" id="r_a6ab852a47972daf9ace1f3443044f609"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab852a47972daf9ace1f3443044f609">compute_integration_domains</a> (<a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> integral_type, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a6ab852a47972daf9ace1f3443044f609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integral type and a set of entities, computes and return data for the entities that should be integrated over.  <br /></td></tr>
<tr class="separator:a6ab852a47972daf9ace1f3443044f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0589b9e21481958b76c8862dd29903" id="r_a5c0589b9e21481958b76c8862dd29903"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:a5c0589b9e21481958b76c8862dd29903"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c0589b9e21481958b76c8862dd29903">extract_function_spaces</a> (const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; * &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:a5c0589b9e21481958b76c8862dd29903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms.  <br /></td></tr>
<tr class="separator:a5c0589b9e21481958b76c8862dd29903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaad0b646d98814dc913c53fd44d7e97" id="r_adaad0b646d98814dc913c53fd44d7e97"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:adaad0b646d98814dc913c53fd44d7e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adaad0b646d98814dc913c53fd44d7e97">create_sparsity_pattern</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a)</td></tr>
<tr class="memdesc:adaad0b646d98814dc913c53fd44d7e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form.  <br /></td></tr>
<tr class="separator:adaad0b646d98814dc913c53fd44d7e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda0b4f9c1933fc5221e659290ed0700" id="r_afda0b4f9c1933fc5221e659290ed0700"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </td></tr>
<tr class="memitem:afda0b4f9c1933fc5221e659290ed0700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afda0b4f9c1933fc5221e659290ed0700">build_sparsity_pattern</a> (<a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> &amp;pattern, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a)</td></tr>
<tr class="memdesc:afda0b4f9c1933fc5221e659290ed0700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a sparsity pattern for a given form.  <br /></td></tr>
<tr class="separator:afda0b4f9c1933fc5221e659290ed0700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae07c0ea815dc222c6aa24b55e2bbab7" id="r_aae07c0ea815dc222c6aa24b55e2bbab7"><td class="memTemplParams" colspan="2"><a id="aae07c0ea815dc222c6aa24b55e2bbab7" name="aae07c0ea815dc222c6aa24b55e2bbab7"></a>
template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:aae07c0ea815dc222c6aa24b55e2bbab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_element_dof_layout</b> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a>&lt; T &gt; &amp;element, const std::vector&lt; int &gt; &amp;parent_map={})</td></tr>
<tr class="memdesc:aae07c0ea815dc222c6aa24b55e2bbab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> from a <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html" title="Model of a finite element.">FiniteElement</a>. <br /></td></tr>
<tr class="separator:aae07c0ea815dc222c6aa24b55e2bbab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0e12e1b0047bd22ae8f6b013aa03f7" id="r_afb0e12e1b0047bd22ae8f6b013aa03f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb0e12e1b0047bd22ae8f6b013aa03f7">create_dofmap</a> (MPI_Comm comm, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;layout, <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt; &amp;permute_inv, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn)</td></tr>
<tr class="memdesc:afb0e12e1b0047bd22ae8f6b013aa03f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dof map on mesh.  <br /></td></tr>
<tr class="separator:afb0e12e1b0047bd22ae8f6b013aa03f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4afb4c470a1eb51a817ee06366fcef" id="r_afc4afb4c470a1eb51a817ee06366fcef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc4afb4c470a1eb51a817ee06366fcef">create_dofmaps</a> (MPI_Comm comm, const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;layouts, <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt; &amp;permute_inv, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn)</td></tr>
<tr class="memdesc:afc4afb4c470a1eb51a817ee06366fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a set of dofmaps on a given topology.  <br /></td></tr>
<tr class="separator:afc4afb4c470a1eb51a817ee06366fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cc717205d7ac69d5eb101dbc335d0e" id="r_a59cc717205d7ac69d5eb101dbc335d0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59cc717205d7ac69d5eb101dbc335d0e">get_coefficient_names</a> (const ufcx_form &amp;ufcx_form)</td></tr>
<tr class="separator:a59cc717205d7ac69d5eb101dbc335d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00024efad1ca78d948796fb27e268648" id="r_a00024efad1ca78d948796fb27e268648"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00024efad1ca78d948796fb27e268648">get_constant_names</a> (const ufcx_form &amp;ufcx_form)</td></tr>
<tr class="memdesc:a00024efad1ca78d948796fb27e268648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each constant in a UFC form.  <br /></td></tr>
<tr class="separator:a00024efad1ca78d948796fb27e268648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4fb78eef24376b4c00c922f92e868d" id="r_a4b4fb78eef24376b4c00c922f92e868d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4b4fb78eef24376b4c00c922f92e868d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b4fb78eef24376b4c00c922f92e868d">create_form_factory</a> (const std::vector&lt; std::reference_wrapper&lt; const ufcx_form &gt; &gt; &amp;ufcx_forms, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;entity_maps, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:a4b4fb78eef24376b4c00c922f92e868d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFCx input with coefficients and constants passed in the required order.  <br /></td></tr>
<tr class="separator:a4b4fb78eef24376b4c00c922f92e868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791d3f3b0aef6ea0907bdef267d1f75f" id="r_a791d3f3b0aef6ea0907bdef267d1f75f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a791d3f3b0aef6ea0907bdef267d1f75f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a791d3f3b0aef6ea0907bdef267d1f75f">create_form</a> (const ufcx_form &amp;ufcx_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;entity_maps, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:a791d3f3b0aef6ea0907bdef267d1f75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input with coefficients and constants resolved by name.  <br /></td></tr>
<tr class="separator:a791d3f3b0aef6ea0907bdef267d1f75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9385bd58f45a41bae5d80a91277eacdf" id="r_a9385bd58f45a41bae5d80a91277eacdf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a9385bd58f45a41bae5d80a91277eacdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9385bd58f45a41bae5d80a91277eacdf">create_form</a> (ufcx_form *(*fptr)(), const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;entity_maps, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:a9385bd58f45a41bae5d80a91277eacdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> using a factory function that returns a pointer to a <code>ufcx_form</code>.  <br /></td></tr>
<tr class="separator:a9385bd58f45a41bae5d80a91277eacdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911b1d61a2cc917df11cca88e038b6d" id="r_a1911b1d61a2cc917df11cca88e038b6d"><td class="memTemplParams" colspan="2"><a id="a1911b1d61a2cc917df11cca88e038b6d" name="a1911b1d61a2cc917df11cca88e038b6d"></a>
template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a1911b1d61a2cc917df11cca88e038b6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_functionspace</b> (std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &gt; mesh, std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a>&lt; T &gt; &gt; e, std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a1911b1d61a2cc917df11cca88e038b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">NEW Create a function space from a <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html" title="Model of a finite element.">fem::FiniteElement</a>. <br /></td></tr>
<tr class="separator:a1911b1d61a2cc917df11cca88e038b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6078066840093540dc1049235af665ee" id="r_a6078066840093540dc1049235af665ee"><td class="memTemplParams" colspan="2"><a id="a6078066840093540dc1049235af665ee" name="a6078066840093540dc1049235af665ee"></a>
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6078066840093540dc1049235af665ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_expression</b> (const ufcx_expression &amp;e, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; argument_space=nullptr)</td></tr>
<tr class="memdesc:a6078066840093540dc1049235af665ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> from UFC. <br /></td></tr>
<tr class="separator:a6078066840093540dc1049235af665ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5d72473c466b66a3d000405cf4cce3" id="r_abf5d72473c466b66a3d000405cf4cce3"><td class="memTemplParams" colspan="2"><a id="abf5d72473c466b66a3d000405cf4cce3" name="abf5d72473c466b66a3d000405cf4cce3"></a>
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:abf5d72473c466b66a3d000405cf4cce3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_expression</b> (const ufcx_expression &amp;e, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; argument_space=nullptr)</td></tr>
<tr class="memdesc:abf5d72473c466b66a3d000405cf4cce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> from UFC input (with named coefficients and constants). <br /></td></tr>
<tr class="separator:abf5d72473c466b66a3d000405cf4cce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite element method functionality. </p>
<p>Classes and algorithms for finite element method spaces and operations. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a86418c4371281a95280155a7e717c5eb" name="a86418c4371281a95280155a7e717c5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86418c4371281a95280155a7e717c5eb">&#9670;&#160;</a></span>doftransform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a86418c4371281a95280155a7e717c5eb">doftransform</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DOF transformation type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a86418c4371281a95280155a7e717c5ebac00f0c4675b91fb8b918e4079a0b1bac" name="a86418c4371281a95280155a7e717c5ebac00f0c4675b91fb8b918e4079a0b1bac"></a>standard&#160;</td><td class="fielddoc"><p>Standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86418c4371281a95280155a7e717c5eba382eb179a7d78f25d89c085988b37e95" name="a86418c4371281a95280155a7e717c5eba382eb179a7d78f25d89c085988b37e95"></a>transpose&#160;</td><td class="fielddoc"><p>Transpose. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86418c4371281a95280155a7e717c5ebaa91c78e040f7b9d158f381e197f8beb4" name="a86418c4371281a95280155a7e717c5ebaa91c78e040f7b9d158f381e197f8beb4"></a>inverse&#160;</td><td class="fielddoc"><p>Inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86418c4371281a95280155a7e717c5eba4cceecb0ec73b0cd387faae5e5301f40" name="a86418c4371281a95280155a7e717c5eba4cceecb0ec73b0cd387faae5e5301f40"></a>inverse_transpose&#160;</td><td class="fielddoc"><p>Transpose inverse. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac00c421a0f3a4e925538ebc7a05f2962" name="ac00c421a0f3a4e925538ebc7a05f2962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00c421a0f3a4e925538ebc7a05f2962">&#9670;&#160;</a></span>IntegralType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> : std::int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of integral. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c" name="ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c"></a>cell&#160;</td><td class="fielddoc"><p>Cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213" name="ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213"></a>exterior_facet&#160;</td><td class="fielddoc"><p>Exterior facet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf" name="ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf"></a>interior_facet&#160;</td><td class="fielddoc"><p>Interior facet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a" name="ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a"></a>vertex&#160;</td><td class="fielddoc"><p>Vertex. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a34293fe58acda313cb52fa5bf6af5c19" name="a34293fe58acda313cb52fa5bf6af5c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34293fe58acda313cb52fa5bf6af5c19">&#9670;&#160;</a></span>allocate_coefficient_storage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; allocate_coefficient_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>form</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for packed coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from a form <code>(integral_type, domain_id)</code> pair to a <code>(coeffs, cstride)</code> pair </dd></dl>

</div>
</div>
<a id="a08bb77b3d643db27d9e65e08a1c4b7b9" name="a08bb77b3d643db27d9e65e08a1c4b7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bb77b3d643db27d9e65e08a1c4b7b9">&#9670;&#160;</a></span>allocate_coefficient_storage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, int &gt; allocate_coefficient_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>form</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a></td>          <td class="paramname"><span class="paramname"><em>integral_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage for coefficients of a pair <code>(integral_type, / id)</code> from a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Type of integral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id of the integration domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A storage container and the column stride </dd></dl>

</div>
</div>
<a id="ae9bec02da3849e6d552d5e10dcc4dca9" name="ae9bec02da3849e6d552d5e10dcc4dca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bec02da3849e6d552d5e10dcc4dca9">&#9670;&#160;</a></span>apply_lifting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apply_lifting </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bcs1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraints). This modification is known as 'lifting'. </p>
<p>Consider the discrete algebraic system         </p><p class="formulaDsp">
\[\begin{bmatrix}
A_{0} &amp; A_{1}
\end{bmatrix}
\begin{bmatrix}
u_{0} \\ u_{1}
\end{bmatrix}
= b,
\]
</p>
<p> where \(A_{i}\) is a matrix. Partitioning each vector \(u_{i}\) into 'unknown' ( \(u_{i}^{(0)}\)) and prescribed ( \(u_{i}^{(1)}\)) groups,         </p><p class="formulaDsp">
\[\begin{bmatrix}
A_{0}^{(0)} &amp; A_{0}^{(1)} &amp; A_{1}^{(0)} &amp; A_{1}^{(1)}
\end{bmatrix}
\begin{bmatrix}
u_{0}^{(0)} \\ u_{0}^{(1)} \\ u_{1}^{(0)} \\ u_{1}^{(1)}
\end{bmatrix}
= b.
\]
</p>
<p> If \(u_{i}^{(1)} = \alpha(g_{i} - x_{i})\), where \(g_{i}\) is the Dirichlet boundary condition value, \(x_{i}\) is provided and \(\alpha\) is a constant, then         </p><p class="formulaDsp">
\[\begin{bmatrix}
A_{0}^{(0)} &amp; A_{0}^{(1)} &amp; A_{1}^{(0)} &amp; A_{1}^{(1)}
\end{bmatrix}
\begin{bmatrix}
u_{0}^{(0)} \\ \alpha(g_{0} - x_{0}) \\ u_{1}^{(0)} \\ \alpha(g_{1} - x_{1})
\end{bmatrix}
= b.
\]
</p>
<p> Rearranging,          </p><p class="formulaDsp">
\[\begin{bmatrix}
A_{0}^{(0)} &amp; A_{1}^{(0)}
\end{bmatrix}
\begin{bmatrix}
u_{0}^{(0)} \\ u_{1}^{(0)}
\end{bmatrix}
= b - \alpha A_{0}^{(1)} (g_{0} - x_{0}) - \alpha A_{1}^{(1)} (g_{1} -
x_{1}).
\]
</p>
<p>The modified \(b\) vector is    </p><p class="formulaDsp">
\[ b \leftarrow b - \alpha A_{0}^{(1)} (g_{0} - x_{0}) - \alpha A_{1}^{(1)}
 (g_{1} - x_{1})
\]
</p>
<p> More generally,   </p><p class="formulaDsp">
\[ b \leftarrow b - \alpha A_{i}^{(1)} (g_{i} - x_{i}).
\]
</p>
<dl class="section note"><dt>Note</dt><dd>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for reverse-scatter to update the ghosts.</dd>
<dd>
Boundary condition values are <em>not</em> set in <code>b</code> by this function. Use <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a72820c53f3b0be73303fc29fbafa5b30" title="Set entries in an array that are constrained by Dirichlet boundary conditions.">DirichletBC::set</a> to set values in <code>b</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to modify inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>List of bilinear forms, where <code>a[i]</code> is the form that generates the matrix \(A_{i}\). All forms in <code>a</code> must share the same test function space. The trial function spaces can differ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html" title="Constant (in space) value which can be attached to a Form.">Constant</a> data appearing in the forms <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>Coefficient data appearing in the forms <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>The vector \(x_{i}\) above. If empty it is set to zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs1</td><td>Boundary conditions that provide the \(g_{i}\) values. <code>bcs1[i]</code> is the list of boundary conditions on \(u_{i}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar used in the modification of <code>b</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26ed4d31c70d6bc3c9362d76a72bb42c" name="a26ed4d31c70d6bc3c9362d76a72bb42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ed4d31c70d6bc3c9362d76a72bb42c">&#9670;&#160;</a></span>apply_lifting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apply_lifting </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::optional&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bcs1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the right-hand side vector to account for constraints (Dirichlet boundary conditions constraints). This modification is known as 'lifting'. </p>
<p>See <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a> for a detailed explanation of the lifting. The difference between this function and <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a> is that <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a> requires packed form constant and coefficient data to be passed to the function, whereas this function packs the constant and coefficient form data and then calls <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for reverse-scatter to update the ghosts.</dd>
<dd>
Boundary condition values are <em>not</em> set in <code>b</code> by this function. Use <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a72820c53f3b0be73303fc29fbafa5b30" title="Set entries in an array that are constrained by Dirichlet boundary conditions.">DirichletBC::set</a> to set values in <code>b</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to modify inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>List of bilinear forms, where <code>a[i]</code> is the form that generates the matrix \(A_{i}\) (see <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a>). All forms in <code>a</code> must share the same test function space. The trial function spaces can differ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>The vector \(x_{i}\) described in <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a>. If empty it is set to zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs1</td><td>Boundary conditions that provide the \(g_{i}\) values described in <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a>. <code>bcs1[i]</code> is the list of boundary conditions on \(u_{i}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Scalar used in the modification of <code>b</code> (see described in <a class="el" href="#ae9bec02da3849e6d552d5e10dcc4dca9" title="Modify the right-hand side vector to account for constraints (Dirichlet boundary condition constraint...">apply_lifting()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff7d16fb5385e3dd2d94db2e5277f96" name="abff7d16fb5385e3dd2d94db2e5277f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff7d16fb5385e3dd2d94db2e5277f96">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>mat_add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd42eee23160562035e655ecb00c125d" name="acd42eee23160562035e655ecb00c125d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd42eee23160562035e655ecb00c125d">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>mat_add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>dof_marker0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>dof_marker1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If <code>bc[i]</code> is <code>true</code> then rows <code>i</code> in Awill be zeroed. The index <code>i</code> is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If <code>bc[i]</code> is <code>true</code> then rows <code>i</code> in <code>A</code> will be zeroed. The index <code>i</code> is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b66f7d91c0c3bc935222ffbb97d9849" name="a8b66f7d91c0c3bc935222ffbb97d9849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b66f7d91c0c3bc935222ffbb97d9849">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>mat_add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0a03f1a72e1ccc0db29e1c78cba755" name="a0b0a03f1a72e1ccc0db29e1c78cba755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0a03f1a72e1ccc0db29e1c78cba755">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">la::MatSet&lt; T &gt; auto</td>          <td class="paramname"><span class="paramname"><em>mat_add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>dof_marker0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>dof_marker1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac167a0c039f5a52846fb32ff121fd8ba" name="ac167a0c039f5a52846fb32ff121fd8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac167a0c039f5a52846fb32ff121fd8ba">&#9670;&#160;</a></span>assemble_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. </p>
<dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process. </dd></dl>

</div>
</div>
<a id="a0f314895ce73b6f0667dc7556cb1b3ab" name="a0f314895ce73b6f0667dc7556cb1b3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f314895ce73b6f0667dc7556cb1b3ab">&#9670;&#160;</a></span>assemble_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. </p>
<p>The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p><dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>M</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>M</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="ac13e0e8a617dbb55d18198e5de2211f9" name="ac13e0e8a617dbb55d18198e5de2211f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13e0e8a617dbb55d18198e5de2211f9">&#9670;&#160;</a></span>assemble_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_vector </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Linear forms to assemble into b. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ccb32526016191d2737c974d4bcfd5a" name="a2ccb32526016191d2737c974d4bcfd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb32526016191d2737c974d4bcfd5a">&#9670;&#160;</a></span>assemble_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_vector </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector. </p>
<p>The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>L</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>L</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae243b5f1e53ad867535767929d8847be" name="ae243b5f1e53ad867535767929d8847be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae243b5f1e53ad867535767929d8847be">&#9670;&#160;</a></span>build_dofmap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, std::vector&lt; std::vector&lt; std::int32_t &gt; &gt; &gt; build_dofmap_data </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element_dof_layouts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build dofmap data for elements on a mesh topology </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_dof_layouts</td><td>The element dof layouts for each cell type in <code>topology</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function that is applied to the dofmaps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index map, block size, and dofmaps for each element type </dd></dl>

</div>
</div>
<a id="afda0b4f9c1933fc5221e659290ed0700" name="afda0b4f9c1933fc5221e659290ed0700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda0b4f9c1933fc5221e659290ed0700">&#9670;&#160;</a></span>build_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void build_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a sparsity pattern for a given form. </p>
<dl class="section note"><dt>Note</dt><dd>The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The sparsity pattern to add to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae68fed2204e6da434435b5b526923bd4" name="ae68fed2204e6da434435b5b526923bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68fed2204e6da434435b5b526923bd4">&#9670;&#160;</a></span>common_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt; &gt;, 2 &gt; common_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. </p>
<p>The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>Vector function spaces for (0) each row block and (1) each column block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ab852a47972daf9ace1f3443044f609" name="a6ab852a47972daf9ace1f3443044f609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab852a47972daf9ace1f3443044f609">&#9670;&#160;</a></span>compute_integration_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_integration_domains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">fem::IntegralType</a></td>          <td class="paramname"><span class="paramname"><em>integral_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an integral type and a set of entities, computes and return data for the entities that should be integrated over. </p>
<p>This function returns a list data, for each entity in <code>entities</code>, that is used in assembly. For cell integrals it is simply the cell cell indices. For exterior facet integrals, a list of <code>(cell_index, / local_facet_index)</code> pairs is returned. For interior facet integrals, a list of <code>(cell_index0, local_facet_index0, cell_index1, / local_facet_index1)</code> tuples is returned. The data computed by this function is typically used as input to <a class="el" href="#a791d3f3b0aef6ea0907bdef267d1f75f" title="Create a Form from UFC input with coefficients and constants resolved by name.">fem::create_form</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Owned mesh entities only are returned. Ghost entities are not included.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For facet integrals, the topology facet-to-cell and cell-to-facet connectivity must be computed before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Integral type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of mesh entities. For <code>integral_type==<a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c" title="Cell.">IntegralType::cell</a></code>, <code>entities</code> should be cell indices. For other <code><a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962" title="Type of integral.">IntegralType</a></code>, <code>entities</code> should be facet indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of integration entity data. </dd></dl>

</div>
</div>
<a id="afb0e12e1b0047bd22ae8f6b013aa03f7" name="afb0e12e1b0047bd22ae8f6b013aa03f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0e12e1b0047bd22ae8f6b013aa03f7">&#9670;&#160;</a></span>create_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> create_dofmap </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>permute_inv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dof map on mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Dof layout on an element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permute_inv</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to un-permute dofs. <code>nullptr</code> when transformation is not required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function called on the dofmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new dof map </dd></dl>

</div>
</div>
<a id="afc4afb4c470a1eb51a817ee06366fcef" name="afc4afb4c470a1eb51a817ee06366fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4afb4c470a1eb51a817ee06366fcef">&#9670;&#160;</a></span>create_dofmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> &gt; create_dofmaps </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layouts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(std::span&lt; std::int32_t &gt;, std::uint32_t)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>permute_inv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a set of dofmaps on a given topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layouts</td><td>Dof layout on each element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permute_inv</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to un-permute dofs. <code>nullptr</code> when transformation is not required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function called on the dofmaps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of new dof maps </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of layouts must match the number of cell types in the topology </dd></dl>

</div>
</div>
<a id="a791d3f3b0aef6ea0907bdef267d1f75f" name="a791d3f3b0aef6ea0907bdef267d1f75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791d3f3b0aef6ea0907bdef267d1f75f">&#9670;&#160;</a></span>create_form() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;</td>          <td class="paramname"><span class="paramname"><em>ufcx_form</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>spaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subdomains</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>entity_maps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input with coefficients and constants resolved by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers. The data can be computed using <a class="el" href="#a6ab852a47972daf9ace1f3443044f609" title="Given an integral type and a set of entities, computes and return data for the entities that should b...">fem::compute_integration_domains</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_maps</td><td>The entity maps for the form. Empty for single domain problems. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a9385bd58f45a41bae5d80a91277eacdf" name="a9385bd58f45a41bae5d80a91277eacdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385bd58f45a41bae5d80a91277eacdf">&#9670;&#160;</a></span>create_form() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form </td>
          <td>(</td>
          <td class="paramtype">ufcx_form *(*</td>          <td class="paramname"><span class="paramname"><em>fptr&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>spaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subdomains</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>entity_maps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> using a factory function that returns a pointer to a <code>ufcx_form</code>. </p>
<p>Coefficients and constants are resolved by name/string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td>Pointer to a function returning a pointer to ufcx_form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name), </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name), </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers. The data can be computed using <a class="el" href="#a6ab852a47972daf9ace1f3443044f609" title="Given an integral type and a set of entities, computes and return data for the entities that should b...">fem::compute_integration_domains</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_maps</td><td>The entity maps for the form. Empty for single domain problems. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a4b4fb78eef24376b4c00c922f92e868d" name="a4b4fb78eef24376b4c00c922f92e868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4fb78eef24376b4c00c922f92e868d">&#9670;&#160;</a></span>create_form_factory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = scalar_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form_factory </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const ufcx_form &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ufcx_forms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>spaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::span&lt; const std::int32_t &gt; &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subdomains</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">mesh::EntityMap</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>entity_maps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFCx input with coefficients and constants passed in the required order. </p>
<p>Use <a class="el" href="#a791d3f3b0aef6ea0907bdef267d1f75f" title="Create a Form from UFC input with coefficients and constants resolved by name.">fem::create_form</a> to create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">fem::Form</a> with coefficients and constants associated with the name/string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_forms</td><td>A list of UFCx forms, one for each cell type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>Vector of function spaces. The number of spaces is equal to the rank of the form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers. The data can be computed using <a class="el" href="#a6ab852a47972daf9ace1f3443044f609" title="Given an integral type and a set of entities, computes and return data for the entities that should b...">fem::compute_integration_domains</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_maps</td><td>The entity maps for the form. Empty for single domain problems. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id. </dd></dl>

</div>
</div>
<a id="a3c1767f94cb5cb5a06169d2d02acc101" name="a3c1767f94cb5cb5a06169d2d02acc101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1767f94cb5cb5a06169d2d02acc101">&#9670;&#160;</a></span>create_interpolation_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/da5/structdolfinx_1_1geometry_1_1PointOwnershipData.html">geometry::PointOwnershipData</a>&lt; T &gt; create_interpolation_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>geometry0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate data needed to interpolate finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>'s across different meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry0</td><td>Mesh geometry of the space to interpolate into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element0</td><td>Element of the space to interpolate into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1</td><td>Mesh of the function to interpolate from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the destination mesh on which to interpolate. Should be the same as the list used when calling <code>interpolation_coords</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Absolute padding of bounding boxes of all entities on <code>mesh1</code>. This is used avoid floating point issues when an interpolation point from <code>mesh0</code> is on the surface of a cell in <code>mesh1</code>. This parameter can also be used for extrapolation, i.e. if cells in <code>mesh0</code> is not overlapped by <code>mesh1</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting the <code>padding</code> to a large value will increase the runtime of this function, as one has to determine what entity is closest if there is no intersection. </dd></dl>

</div>
</div>
<a id="adaad0b646d98814dc913c53fd44d7e97" name="adaad0b646d98814dc913c53fd44d7e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaad0b646d98814dc913c53fd44d7e97">&#9670;&#160;</a></span>create_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> create_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparsity pattern for a given form. </p>
<dl class="section note"><dt>Note</dt><dd>The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding sparsity pattern </dd></dl>

</div>
</div>
<a id="a0e8d8adc0d37028032b1ce8991062df2" name="a0e8d8adc0d37028032b1ce8991062df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d8adc0d37028032b1ce8991062df2">&#9670;&#160;</a></span>discrete_curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, <a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> U = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void discrete_curl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">la::MatSet&lt; U &gt; auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>mat_set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble a discrete curl operator. </p>
<p>For vector-valued finite functions \(u \in V_{0} \) and  \(v \in
V_{1}\), consider the interpolation of the curl of \(u\) in the space \(V_{1}\), i.e.  \(\Pi_{V_{1}}: \nabla \times u \rightarrow
v\), where \(\Pi_{V_{1}}\) is the interpolation operator associated with \(V_{1}\). This interpolation of  \(\nabla \times
u\) into \(V_{1}\) is properly posed and exact for specific choices of function spaces. If \(V_{0}\) is a Nédélec (  \(H({\rm
curl})\)) space of degree \(k &gt; 1\) and \(V_{1}\) is a Raviart-Thomas ( \(H({\rm div})\)) space of degree of at least  \(k
- 1\), then the interpolation is exact.</p>
<p>The implementation of this function exploits the result:</p>
<p class="formulaDsp">
\[  \hat{\nabla} \times \psi_{C}(\boldsymbol{u}) = \psi_{D}(\nabla \times
  \boldsymbol{u}),
\]
</p>
<p>where \(\psi_{C}\) is the covariant pull-back (to the reference cell) and \(\psi_{D}\) is the contravariant pull-back. See Ern and Guermond (2021), <em>Finite Elements I</em>, Springer Nature, <a href="https://doi.org/10.1007/978-3-030-56341-7">https://doi.org/10.1007/978-3-030-56341-7</a> [Corollary 9.9 (Commuting properties)]. Consequently, the spaces <code>V0</code> and <code>V1</code> must use covariant and contravariant maps, respectively.</p>
<p>This function builds a matrix \(C\) (the 'discrete curl'), which when applied to the degrees-of-freedom of \(u\) gives the degrees-of-freedom of \(v\) such that \(v = \nabla \times u\). If the finite element degree-of-freedom vectors associated with \(u\) and \(v\) are \(a\) and \(b\), respectively, then  \(b
= C a\), which yields \(v = \Pi_{V} \nabla \times u\). It essentially maps that curl of a function in a degree \(k &gt; 1\) Nédélec space into a degree \(k - 1\) Raviart-Thomas space.</p>
<p>The discerete curl is typically used in constructing algebraic multigrid preconditioners for \(H({\rm div})\) problems, e.g. when using the Hypre Auxiliary-space Divergence Solver (ADS) to solve a mixed Poisson in three-dimension.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>V0</code> and <code>V1</code> must be vector-valued, in three spatial dimensions, and use covariant and contravariant maps, respectively.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the mesh and elements. </td></tr>
    <tr><td class="paramname">U</td><td>Scalar type of the matrix being inserted into. This is usually the same as <code>T</code>, but may differ for matrix backends that support only a specific type, e.g. PETSc which supports only one scalar type for a build of PETSc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>Space that \(u\) is from. It must be a covariant Piola mapped element. It is normally an  \(H({\rm
curl})\)-conforming Nédélec space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>Space that \(v\) is from. It must be a contravariant Piola mapped element. It is normally an  \(H({\rm
div})\)-conforming Raviart-Thomas space of one degree lower than <code>V0</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>A functor that sets (not add) values in a matrix \(C\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e261c1fdfd61a1e629b82b2d0125e4b" name="a4e261c1fdfd61a1e629b82b2d0125e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e261c1fdfd61a1e629b82b2d0125e4b">&#9670;&#160;</a></span>discrete_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void discrete_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>V0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>mat_set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble a discrete gradient operator. </p>
<p>The discrete gradient operator \(A\) interpolates the gradient of a Lagrange finite element function in \(V_0 \subset H^1\) into a Nédélec (first kind) space \(V_1 \subset H({\rm curl})\), i.e. \(\nabla V_0 \rightarrow V_1\). If \(u_0\) is the degree-of-freedom vector associated with \(V_0\), then \(u_1=Au_0\) where \(u_1\) is the degrees-of-freedom vector for interpolating function in the \(H({\rm curl})\) space. An example of where discrete gradient operators are used is the creation of algebraic multigrid solvers for \(H({\rm curl})\) and  \(H({\rm
div})\) problems.</p>
<dl class="section note"><dt>Note</dt><dd>The sparsity pattern for a discrete operator can be initialised using <a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html#ae2f0ed66f6d1dc4a8689894c5d833007" title="Iterate over cells and insert entries into sparsity pattern.">sparsitybuild::cells</a>. The space <code>V1</code> should be used for the rows of the sparsity pattern, <code>V0</code> for the columns.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function relies on the user supplying appropriate input and output spaces. See parameter descriptions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>Lagrange element and dofmap for corresponding space to interpolate the gradient from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>Nédélec (first kind) element and dofmap for corresponding space to interpolate into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>A functor that sets values in a matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c0589b9e21481958b76c8862dd29903" name="a5c0589b9e21481958b76c8862dd29903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0589b9e21481958b76c8862dd29903">&#9670;&#160;</a></span>extract_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;, 2 &gt; &gt; &gt; extract_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A rectangular block on bilinear forms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular array of the same shape as <code>a</code> with a pair of function spaces in each array entry. If a form is null, then the returned function space pair is (null, null). </dd></dl>

</div>
</div>
<a id="a59cc717205d7ac69d5eb101dbc335d0e" name="a59cc717205d7ac69d5eb101dbc335d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cc717205d7ac69d5eb101dbc335d0e">&#9670;&#160;</a></span>get_coefficient_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; get_coefficient_names </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;</td>          <td class="paramname"><span class="paramname"><em>ufcx_form</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of each coefficient in a UFC form </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>The UFC form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of each coefficient </dd></dl>

</div>
</div>
<a id="a00024efad1ca78d948796fb27e268648" name="a00024efad1ca78d948796fb27e268648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00024efad1ca78d948796fb27e268648">&#9670;&#160;</a></span>get_constant_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; get_constant_names </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;</td>          <td class="paramname"><span class="paramname"><em>ufcx_form</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each constant in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>The UFC form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of each constant </dd></dl>

</div>
</div>
<a id="af5bd6cb4e9b789ac77ab7dcfe9ad6240" name="af5bd6cb4e9b789ac77ab7dcfe9ad6240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bd6cb4e9b789ac77ab7dcfe9ad6240">&#9670;&#160;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/da5/structdolfinx_1_1geometry_1_1PointOwnershipData.html">geometry::PointOwnershipData</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interpolation_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> defined on a mesh to a finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> defined on different (non-matching) mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> scalar type. </td></tr>
    <tr><td class="paramname">U</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> geometry scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to interpolate into. </td></tr>
    <tr><td class="paramname">v</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to interpolate from. </td></tr>
    <tr><td class="paramname">cells</td><td>Cells indices relative to the mesh associated with <code>u</code> that will be interpolated into. </td></tr>
    <tr><td class="paramname">interpolation_data</td><td>Data required for associating the interpolation points of <code>u</code> with cells in <code>v</code>. This is computed by <a class="el" href="#a3c1767f94cb5cb5a06169d2d02acc101" title="Generate data needed to interpolate finite element fem::Function&#39;s across different meshes.">fem::create_interpolation_data</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e94bc10b18fa604c007524a859f8d7" name="a75e94bc10b18fa604c007524a859f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e94bc10b18fa604c007524a859f8d7">&#9670;&#160;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>fshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an evaluated expression f(x) in a finite element space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">U</td><td>Mesh geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> object to interpolate into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Evaluation of the function <code>f(x)</code> at the physical points <code>x</code> given by <code>interpolation_coords</code>. The element used in <code>interpolation_coords</code> should be the same element as associated with <code>u</code>. The shape of <code>f</code> is <code>(value_size, num_points)</code>, with row-major storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fshape</td><td>Shape of <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh on which to interpolate. Should be the same as the list of cells used when calling <code>interpolation_coords</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a497916172c4db5b8f2de4e08fa2200bb" name="a497916172c4db5b8f2de4e08fa2200bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497916172c4db5b8f2de4e08fa2200bb">&#9670;&#160;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to another <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> on the same (sub)mesh. </p>
<p>Interpolation can be performed on a subset of mesh cells and Functions may be defined on 'sub-meshes'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u1</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to interpolate into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells1</td><td>Cell indices associated with the mesh of <code>u1</code> that will be interpolated onto. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u0</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> to b interpolated from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells0</td><td>Cell indices associated with the mesh of <code>u0</code> that will be interpolated from. If <code>cells1[i]</code> is the index of a cell in the mesh associated with <code>u1</code>, then <code>cells0[i]</code> is the index of the <em>same</em> cell but in the mesh associated with <code>u0</code>. <code>cells0</code> and <code>cells1</code> must be the same size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f2326fdc33ea6c03797126e3fb0e3d" name="ae2f2326fdc33ea6c03797126e3fb0e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f2326fdc33ea6c03797126e3fb0e3d">&#9670;&#160;</a></span>interpolation_coords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; interpolation_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>geometry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite element space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Element to be interpolated into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Mesh geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh to compute interpolation coordinates for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates in the physical space at which to evaluate an expression. The shape is <code>(3, num_points)</code> and storage is row-major. </dd></dl>

</div>
</div>
<a id="ad46c61a5c9cc2c1964a261c3a868cb4f" name="ad46c61a5c9cc2c1964a261c3a868cb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c61a5c9cc2c1964a261c3a868cb4f">&#9670;&#160;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>mat_set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble an interpolation operator matrix. </p>
<p>The interpolation operator \(A\) interpolates a function in the space \(V_0\) into a space \(V_1\). If \(u_0\) is the degree-of-freedom vector associated with \(V_0\), then the degree-of-freedom vector \(u_1\) for the interpolated function in \(V_1\) is given by \(u_1=Au_0\).</p>
<dl class="section note"><dt>Note</dt><dd>The sparsity pattern for a discrete operator can be initialised using <a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html#ae2f0ed66f6d1dc4a8689894c5d833007" title="Iterate over cells and insert entries into sparsity pattern.">sparsitybuild::cells</a>. The space <code>V1</code> should be used for the rows of the sparsity pattern, <code>V0</code> for the columns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>Space to interpolate from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>Space to interpolate to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>Functor that sets values in a matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a0d39b240c84457b5d10674737d31c5" name="a7a0d39b240c84457b5d10674737d31c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0d39b240c84457b5d10674737d31c5">&#9670;&#160;</a></span>locate_dofs_geometrical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees of freedom will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="a5b37280bf45c2ef336bd9cd054590be1" name="a5b37280bf45c2ef336bd9cd054590be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b37280bf45c2ef336bd9cd054590be1">&#9670;&#160;</a></span>locate_dofs_geometrical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space(s) on which degrees of freedom will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the corresponding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="a84cd6568b465fbe013715ad3d70190cb" name="a84cd6568b465fbe013715ad3d70190cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cd6568b465fbe013715ad3d70190cb">&#9670;&#160;</a></span>locate_dofs_topological() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dofmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). </p>
<dl class="section note"><dt>Note</dt><dd>Degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>Dofmap that associated DOFs with cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The topology cell-&gt;entity and entity-&gt;cell connectivity must have been computed before calling this function. </dd></dl>

</div>
</div>
<a id="a3900051aa0e3357e04060065bf868149" name="a3900051aa0e3357e04060065bf868149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3900051aa0e3357e04060065bf868149">&#9670;&#160;</a></span>locate_dofs_topological() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>dofmaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). </p>
<dl class="section note"><dt>Note</dt><dd>Degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmaps</td><td>The dofmaps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the corresponding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The topology cell-&gt;entity and entity-&gt;cell connectivity must have been computed before calling this function. </dd></dl>

</div>
</div>
<a id="a8b8db5346f987c894fa348b1b1af67bd" name="a8b8db5346f987c894fa348b1b1af67bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8db5346f987c894fa348b1b1af67bd">&#9670;&#160;</a></span>pack_coefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>form</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::pair&lt; <a class="el" href="#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> to pack the coefficients for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">coeffs</td><td>Map from a <code>(integral_type, domain_id)</code> pair to a <code>(coeffs, cstride)</code> pair.<ul>
<li><code>coeffs</code> is an array of shape <code>(num_int_entities, cstride)</code> into which coefficient data will be packed.</li>
<li><code>num_int_entities</code> is the number of entities over which coefficient data is packed.</li>
<li><code>cstride</code> is the number of coefficient data entries per entity.</li>
<li><code>coeffs</code> is flattened using row-major layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb052f918ee0a5b9d3cb2b5057ad4107" name="acb052f918ee0a5b9d3cb2b5057ad4107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb052f918ee0a5b9d3cb2b5057ad4107">&#9670;&#160;</a></span>pack_coefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fem::MDSpan2 auto</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficient data over a list of cells or facets. </p>
<p>Typically used to prepare coefficient data for an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">coeffs</td><td>Coefficients to pack </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offsets</td><td>Offsets </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entities</td><td>Entities to pack over </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Packed coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a100ff6dbaf334a8588050b6d75ae70dc" name="a100ff6dbaf334a8588050b6d75ae70dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100ff6dbaf334a8588050b6d75ae70dc">&#9670;&#160;</a></span>pack_constants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U&gt; <br />
requires std::convertible_to&lt; U, <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt;typename std::decay_t&lt;U&gt;::scalar_type, typename std::decay_t&lt;U&gt;::geometry_type&gt;&gt; or std::convertible_to&lt; U, <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt;typename std::decay_t&lt;U&gt;::scalar_type, typename std::decay_t&lt;U&gt;::geometry_type&gt;&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename U::scalar_type &gt; pack_constants </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack constants of an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> or <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> into a single array ready for assembly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> or <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> to pack constant data for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Packed constants </dd></dl>

</div>
</div>
<a id="abc7841d3655f0367d281ae38802e98e8" name="abc7841d3655f0367d281ae38802e98e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7841d3655f0367d281ae38802e98e8">&#9670;&#160;</a></span>pack_constants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; pack_constants </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack constants of an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> or <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> into a single array ready for assembly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Constants to pack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Packed constants </dd></dl>

</div>
</div>
<a id="a7f64bc74c372b5ebc33527c83121e7cd" name="a7f64bc74c372b5ebc33527c83121e7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f64bc74c372b5ebc33527c83121e7cd">&#9670;&#160;</a></span>set_diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_diagonal </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>set_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. </p>
<p>This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space for the rows and columns of the matrix. It is used to extract only the Dirichlet boundary conditions that are define on V or subspaces of V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>The Dirichlet boundary conditions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Value to add to the diagonal for rows with a boundary condition applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2482e48a77b23eb1b433c81552a70467" name="a2482e48a77b23eb1b433c81552a70467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2482e48a77b23eb1b433c81552a70467">&#9670;&#160;</a></span>set_diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_diagonal </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>set_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of a matrix for specified rows. </p>
<p>This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>Row blocks, in local indices, for which to add a value to the diagonal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Value to add to the diagonal for the specified rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a508b91434bcce5ef52f48e390869b3c5" name="a508b91434bcce5ef52f48e390869b3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508b91434bcce5ef52f48e390869b3c5">&#9670;&#160;</a></span>tabulate_expression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tabulate_expression </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fem::MDSpan2 auto</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> on cells or facets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">U</td><td>Geometry type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Array to fill with computed values. Row major storage. Sizing should be <code>(num_cells, num_points * value_size * / num_all_argument_dofs columns)</code>. facet index) tuples. Array is flattened per entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> to evaluate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh to compute <code>e</code> on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Mesh entities to evaluate the expression over. For expressions executed on cells, rank is 1 and size is the number of cells. For expressions executed on facets rank is 2, and shape is <code>(num_facets, 2)</code>, where <code>entities[i, 0]</code> is the cell index and <code>entities[i, 1]</code> is the local index of the facet relative to the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41aed9721a8d6bd3bd46a1da477ba093" name="a41aed9721a8d6bd3bd46a1da477ba093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aed9721a8d6bd3bd46a1da477ba093">&#9670;&#160;</a></span>tabulate_expression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tabulate_expression </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">md::mdspan&lt; const T, md::dextents&lt; std::size_t, 2 &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fem::MDSpan2 auto</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a>&lt; U &gt; &gt;, std::size_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> on cells or facets. </p>
<p>This function accepts packed coefficient data, which allows it be called without re-packing all coefficient data at each evaluation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">U</td><td>Geometry type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Array to fill with computed values. Shape is <code>(num_entities, num_points, value_size, num_argument_dofs)</code> and storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> to evaluate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>Packed coefficients for the Expressions. Typically computed using <a class="el" href="#a8b8db5346f987c894fa348b1b1af67bd" title="Pack coefficients of a Form.">fem::pack_coefficients</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Packed constant data. Typically computed using <a class="el" href="#abc7841d3655f0367d281ae38802e98e8" title="Pack constants of an Expression or Form into a single array ready for assembly.">fem::pack_constants</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Mesh entities to evaluate the expression over. For cells it is a list of cell indices. For facets is is a list of (cell index, local facet index) index pairs, i.e. <code>entities=[cell0, / facet_local0, cell1, facet_local1, ...]</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh that the <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="An Expression represents a mathematical expression evaluated at a pre-defined points on a reference c...">Expression</a> is evaluated on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Argument element and argument space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24db86d7fd4cf42ce3bd41f9c6585618" name="a24db86d7fd4cf42ce3bd41f9c6585618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24db86d7fd4cf42ce3bd41f9c6585618">&#9670;&#160;</a></span>transpose_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; transpose_dofmap </td>
          <td>(</td>
          <td class="paramtype">md::mdspan&lt; const std::int32_t, md::dextents&lt; std::size_t, 2 &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>dofmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>num_cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. </p>
<p>It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index. If the usual dof map is:</p>
<p><code>Cell: 0 1 2 3</code> <br  />
 <code>Global index: [ [0, 3, 5], [3, 2, 4], [4, 3, 2], [2, 1, 0]]</code></p>
<p>the 'transpose' dof map will be:</p>
<p><code>Global index: 0 1 2 3 4 5</code> <br  />
 <code>Unassembled index: [ [0, 11], [10], [4, 8, 9], [1, 3, 7], [5, 6], [2] ]</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The standard dof map that for each cell (node) gives the global (process-wise) index of each local (cell-wise) index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>The number of cells (nodes) in <code class="param">dofmap</code> to consider. The first <code class="param">num_cells</code> are used. This is argument is typically used to exclude ghost cell contributions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from global (process-wise) index to positions in an unaassembled array. The links for each node are sorted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>

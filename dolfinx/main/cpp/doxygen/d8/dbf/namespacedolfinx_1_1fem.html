<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::fem Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.7.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::fem Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Finite element method functionality.  
<a href="../../d8/dbf/namespacedolfinx_1_1fem.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d4/d44/namespacedolfinx_1_1fem_1_1petsc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d44/namespacedolfinx_1_1fem_1_1petsc.html">petsc</a></td></tr>
<tr class="memdesc:d4/d44/namespacedolfinx_1_1fem_1_1petsc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for assembly into PETSc data structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html">sparsitybuild</a></td></tr>
<tr class="memdesc:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for building sparsity patterns from degree-of-freedom maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html" title="Constant value which can be attached to a Form. Constants may be scalar (rank 0), vector (rank 1),...">Constant</a> value which can be attached to a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. Constants may be scalar (rank 0), vector (rank 1), or tensor-valued.  <a href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">CoordinateElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html" title="A CoordinateElement manages coordinate mappings for isoparametric cells.">CoordinateElement</a> manages coordinate mappings for isoparametric cells.  <a href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object for setting (strong) Dirichlet boundary conditions.  <a href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree-of-freedom map.  <a href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh entity. This class also handles sub-space dofs, which are views into the parent dofs.  <a href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.  <a href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite Element, containing the dof layout on a reference element, and various methods for evaluating and transforming the basis.  <a href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A representation of finite element variational forms.  <a href="../../df/d02/classdolfinx_1_1fem_1_1Form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a function \( u_h \) in a finite element function space \( V_h \), given by.  <a href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a finite element function space defined by a mesh, a finite element, and a local-to-global map of the degrees of freedom (dofmap).  <a href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da9/conceptdolfinx_1_1fem_1_1FEkernel.html">FEkernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite element cell kernel concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac00c421a0f3a4e925538ebc7a05f2962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> : std::int8_t { <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c">cell</a> = 0
, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213">exterior_facet</a> = 1
, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf">interior_facet</a> = 2
, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a">vertex</a> = 3
 }</td></tr>
<tr class="memdesc:ac00c421a0f3a4e925538ebc7a05f2962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of integral.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">More...</a><br /></td></tr>
<tr class="separator:ac00c421a0f3a4e925538ebc7a05f2962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d25266cbd72792f519fc92c9b9d3989"><td class="memTemplParams" colspan="2"><a id="a6d25266cbd72792f519fc92c9b9d3989" name="a6d25266cbd72792f519fc92c9b9d3989"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d25266cbd72792f519fc92c9b9d3989"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_coefficients_span</b> (const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a6d25266cbd72792f519fc92c9b9d3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a map of <code>std::span</code>s from a map of <code>std::vector</code>s. <br /></td></tr>
<tr class="separator:a6d25266cbd72792f519fc92c9b9d3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a0f314895ce73b6f0667dc7556cb1b3ab">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;M, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients)</td></tr>
<tr class="memdesc:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar.  <br /></td></tr>
<tr class="separator:a0f314895ce73b6f0667dc7556cb1b3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac167a0c039f5a52846fb32ff121fd8ba"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:ac167a0c039f5a52846fb32ff121fd8ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac167a0c039f5a52846fb32ff121fd8ba">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;M)</td></tr>
<tr class="memdesc:ac167a0c039f5a52846fb32ff121fd8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar.  <br /></td></tr>
<tr class="separator:ac167a0c039f5a52846fb32ff121fd8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb32526016191d2737c974d4bcfd5a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a2ccb32526016191d2737c974d4bcfd5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2ccb32526016191d2737c974d4bcfd5a">assemble_vector</a> (std::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;L, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients)</td></tr>
<tr class="memdesc:a2ccb32526016191d2737c974d4bcfd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector.  <br /></td></tr>
<tr class="separator:a2ccb32526016191d2737c974d4bcfd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13e0e8a617dbb55d18198e5de2211f9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:ac13e0e8a617dbb55d18198e5de2211f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac13e0e8a617dbb55d18198e5de2211f9">assemble_vector</a> (std::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;L)</td></tr>
<tr class="memdesc:ac13e0e8a617dbb55d18198e5de2211f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector.  <br /></td></tr>
<tr class="separator:ac13e0e8a617dbb55d18198e5de2211f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42abdb852de4ecd3bf98fc43f1eae817"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a42abdb852de4ecd3bf98fc43f1eae817"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a42abdb852de4ecd3bf98fc43f1eae817">apply_lifting</a> (std::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &amp;a, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;constants, const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &gt; &amp;coeffs, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;bcs1, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;x0, T scale)</td></tr>
<tr class="memdesc:a42abdb852de4ecd3bf98fc43f1eae817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <br /></td></tr>
<tr class="separator:a42abdb852de4ecd3bf98fc43f1eae817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecc7021dd7e760e5874e45c7f7cba99"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:acecc7021dd7e760e5874e45c7f7cba99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#acecc7021dd7e760e5874e45c7f7cba99">apply_lifting</a> (std::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &amp;a, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;bcs1, const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;x0, T scale)</td></tr>
<tr class="memdesc:acecc7021dd7e760e5874e45c7f7cba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <br /></td></tr>
<tr class="separator:acecc7021dd7e760e5874e45c7f7cba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a0b0a03f1a72e1ccc0db29e1c78cba755">assemble_matrix</a> (la::MatSet&lt; T &gt; auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients, std::span&lt; const std::int8_t &gt; dof_marker0, std::span&lt; const std::int8_t &gt; dof_marker1)</td></tr>
<tr class="memdesc:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <br /></td></tr>
<tr class="separator:a0b0a03f1a72e1ccc0db29e1c78cba755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7677555fb708d688acac92f1370b4c7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:af7677555fb708d688acac92f1370b4c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af7677555fb708d688acac92f1370b4c7">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const T &gt; constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs)</td></tr>
<tr class="memdesc:af7677555fb708d688acac92f1370b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <br /></td></tr>
<tr class="separator:af7677555fb708d688acac92f1370b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7374506cfbd6d7a4653eb8565c6d30bc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a7374506cfbd6d7a4653eb8565c6d30bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7374506cfbd6d7a4653eb8565c6d30bc">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs)</td></tr>
<tr class="memdesc:a7374506cfbd6d7a4653eb8565c6d30bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <br /></td></tr>
<tr class="separator:a7374506cfbd6d7a4653eb8565c6d30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd42eee23160562035e655ecb00c125d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:acd42eee23160562035e655ecb00c125d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#acd42eee23160562035e655ecb00c125d">assemble_matrix</a> (auto mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a, std::span&lt; const std::int8_t &gt; dof_marker0, std::span&lt; const std::int8_t &gt; dof_marker1)</td></tr>
<tr class="memdesc:acd42eee23160562035e655ecb00c125d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <br /></td></tr>
<tr class="separator:acd42eee23160562035e655ecb00c125d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2482e48a77b23eb1b433c81552a70467"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2482e48a77b23eb1b433c81552a70467"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2482e48a77b23eb1b433c81552a70467">set_diagonal</a> (auto set_fn, std::span&lt; const std::int32_t &gt; rows, T diagonal=1.0)</td></tr>
<tr class="memdesc:a2482e48a77b23eb1b433c81552a70467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of a matrix for specified rows.  <br /></td></tr>
<tr class="separator:a2482e48a77b23eb1b433c81552a70467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24359fabe9bd7b729e37d5ba37819f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:acc24359fabe9bd7b729e37d5ba37819f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#acc24359fabe9bd7b729e37d5ba37819f">set_diagonal</a> (auto set_fn, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs, T diagonal=1.0)</td></tr>
<tr class="memdesc:acc24359fabe9bd7b729e37d5ba37819f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied.  <br /></td></tr>
<tr class="separator:acc24359fabe9bd7b729e37d5ba37819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9604da85cf5cfab081562ec568031648"><td class="memTemplParams" colspan="2"><a id="a9604da85cf5cfab081562ec568031648" name="a9604da85cf5cfab081562ec568031648"></a>
template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a9604da85cf5cfab081562ec568031648"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_bc</b> (std::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs, std::span&lt; const T &gt; x0, T scale=1)</td></tr>
<tr class="memdesc:a9604da85cf5cfab081562ec568031648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the vector, multiplied by 'scale'. The vectors b and x0 must have the same local size. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a9604da85cf5cfab081562ec568031648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9f57c0a2e0907f3a1b364c0081f76e"><td class="memTemplParams" colspan="2"><a id="a0f9f57c0a2e0907f3a1b364c0081f76e" name="a0f9f57c0a2e0907f3a1b364c0081f76e"></a>
template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a0f9f57c0a2e0907f3a1b364c0081f76e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_bc</b> (std::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;bcs, T scale=1)</td></tr>
<tr class="memdesc:a0f9f57c0a2e0907f3a1b364c0081f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the vector, multiplied by 'scale'. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a0f9f57c0a2e0907f3a1b364c0081f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1ce27cbdde6bbde8683e7777bb91ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2b1ce27cbdde6bbde8683e7777bb91ff">locate_dofs_topological</a> (<a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &amp;dofmap, int dim, std::span&lt; const std::int32_t &gt; entities, bool remote=true)</td></tr>
<tr class="memdesc:a2b1ce27cbdde6bbde8683e7777bb91ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <br /></td></tr>
<tr class="separator:a2b1ce27cbdde6bbde8683e7777bb91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5128b1414b0974ba7024f0c936d92d1"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af5128b1414b0974ba7024f0c936d92d1">locate_dofs_topological</a> (<a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt;, 2 &gt; dofmaps, int dim, std::span&lt; const std::int32_t &gt; entities, bool remote=true)</td></tr>
<tr class="memdesc:af5128b1414b0974ba7024f0c936d92d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <br /></td></tr>
<tr class="separator:af5128b1414b0974ba7024f0c936d92d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d39b240c84457b5d10674737d31c5"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, typename U &gt; </td></tr>
<tr class="memitem:a7a0d39b240c84457b5d10674737d31c5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a0d39b240c84457b5d10674737d31c5">locate_dofs_geometrical</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;V, U marker_fn)</td></tr>
<tr class="memdesc:a7a0d39b240c84457b5d10674737d31c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees of freedom whose geometric coordinate is true for the provided marking function.  <br /></td></tr>
<tr class="separator:a7a0d39b240c84457b5d10674737d31c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6129e579cd57550d8dd008ef03e86ba0"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, typename U &gt; </td></tr>
<tr class="memitem:a6129e579cd57550d8dd008ef03e86ba0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6129e579cd57550d8dd008ef03e86ba0">locate_dofs_geometrical</a> (const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &amp;V, U marker_fn)</td></tr>
<tr class="memdesc:a6129e579cd57550d8dd008ef03e86ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds degrees of freedom whose geometric coordinate is true for the provided marking function.  <br /></td></tr>
<tr class="separator:a6129e579cd57550d8dd008ef03e86ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798d14fb443e82798d1e79170723aabd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a798d14fb443e82798d1e79170723aabd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a798d14fb443e82798d1e79170723aabd">discrete_gradient</a> (<a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt; V0, std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt; V1, auto &amp;&amp;mat_set)</td></tr>
<tr class="memdesc:a798d14fb443e82798d1e79170723aabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a discrete gradient operator.  <br /></td></tr>
<tr class="separator:a798d14fb443e82798d1e79170723aabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad46c61a5c9cc2c1964a261c3a868cb4f">interpolation_matrix</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V0, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;V1, auto &amp;&amp;mat_set)</td></tr>
<tr class="memdesc:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble an interpolation operator matrix.  <br /></td></tr>
<tr class="separator:ad46c61a5c9cc2c1964a261c3a868cb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80fbbb7d5da42a5be17e8f9b7ba90c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa80fbbb7d5da42a5be17e8f9b7ba90c2">transpose_dofmap</a> (const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;dofmap, std::int32_t num_cells)</td></tr>
<tr class="memdesc:aa80fbbb7d5da42a5be17e8f9b7ba90c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions.  <br /></td></tr>
<tr class="separator:aa80fbbb7d5da42a5be17e8f9b7ba90c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f8c979acd33aff3439507b9a89029"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab63f8c979acd33aff3439507b9a89029">build_dofmap_data</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;element_dof_layouts, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn)</td></tr>
<tr class="memdesc:ab63f8c979acd33aff3439507b9a89029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build dofmap data for an element on a mesh topology.  <br /></td></tr>
<tr class="separator:ab63f8c979acd33aff3439507b9a89029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68fed2204e6da434435b5b526923bd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae68fed2204e6da434435b5b526923bd4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt; &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ae68fed2204e6da434435b5b526923bd4">common_function_spaces</a> (const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &gt; &gt; &amp;V)</td></tr>
<tr class="memdesc:ae68fed2204e6da434435b5b526923bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised.  <br /></td></tr>
<tr class="separator:ae68fed2204e6da434435b5b526923bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc75d761461ccee9de059fca268d90c6"><td class="memTemplParams" colspan="2"><a id="afc75d761461ccee9de059fca268d90c6" name="afc75d761461ccee9de059fca268d90c6"></a>
template&lt;typename U , typename V , typename W &gt; </td></tr>
<tr class="memitem:afc75d761461ccee9de059fca268d90c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FunctionSpace</b> (U mesh, V element, W dofmap) -&gt; <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; typename std::remove_cvref&lt; typename U::element_type &gt;::type::geometry_type::value_type &gt;</td></tr>
<tr class="memdesc:afc75d761461ccee9de059fca268d90c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type deduction. <br /></td></tr>
<tr class="separator:afc75d761461ccee9de059fca268d90c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2293c302f0b86dba57605304d92266b0"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a2293c302f0b86dba57605304d92266b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2293c302f0b86dba57605304d92266b0">interpolation_coords</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a> &amp;element, const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;geometry, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:a2293c302f0b86dba57605304d92266b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite element space.  <br /></td></tr>
<tr class="separator:a2293c302f0b86dba57605304d92266b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e94bc10b18fa604c007524a859f8d7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a75e94bc10b18fa604c007524a859f8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a75e94bc10b18fa604c007524a859f8d7">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u, std::span&lt; const T &gt; f, std::array&lt; std::size_t, 2 &gt; fshape, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:a75e94bc10b18fa604c007524a859f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an expression f(x) in a finite element space.  <br /></td></tr>
<tr class="separator:a75e94bc10b18fa604c007524a859f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7a37e1b19b4671f43dec79118e3e18"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a2f7a37e1b19b4671f43dec79118e3e18"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2f7a37e1b19b4671f43dec79118e3e18">create_nonmatching_meshes_interpolation_data</a> (const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;geometry0, const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;element0, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh1, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:a2f7a37e1b19b4671f43dec79118e3e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data needed to interpolate discrete functions across different meshes.  <br /></td></tr>
<tr class="separator:a2f7a37e1b19b4671f43dec79118e3e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99300f6d583f9919dd0e1ec6622462ea"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a99300f6d583f9919dd0e1ec6622462ea"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a99300f6d583f9919dd0e1ec6622462ea">create_nonmatching_meshes_interpolation_data</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh0, const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;element0, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh1)</td></tr>
<tr class="memdesc:a99300f6d583f9919dd0e1ec6622462ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data needed to interpolate discrete functions defined on different meshes. Interpolate on all cells in the mesh.  <br /></td></tr>
<tr class="separator:a99300f6d583f9919dd0e1ec6622462ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f9236f973560257770a583094c3b20"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:ae4f9236f973560257770a583094c3b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ae4f9236f973560257770a583094c3b20">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;u, const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;v, std::span&lt; const std::int32_t &gt; cells, const std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; U &gt;, std::vector&lt; std::int32_t &gt; &gt; &amp;nmm_interpolation_data={})</td></tr>
<tr class="memdesc:ae4f9236f973560257770a583094c3b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> to another one.  <br /></td></tr>
<tr class="separator:ae4f9236f973560257770a583094c3b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c7654625e34cd1263783aa850e4511"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, std::vector&lt; std::int32_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a29c7654625e34cd1263783aa850e4511">compute_integration_domains</a> (<a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> integral_type, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, std::span&lt; const std::int32_t &gt; entities, int dim, std::span&lt; const int &gt; values)</td></tr>
<tr class="memdesc:a29c7654625e34cd1263783aa850e4511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integral type and mesh tag data, compute the entities that should be integrated over.  <br /></td></tr>
<tr class="separator:a29c7654625e34cd1263783aa850e4511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0589b9e21481958b76c8862dd29903"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a5c0589b9e21481958b76c8862dd29903"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5c0589b9e21481958b76c8862dd29903">extract_function_spaces</a> (const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; * &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:a5c0589b9e21481958b76c8862dd29903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms.  <br /></td></tr>
<tr class="separator:a5c0589b9e21481958b76c8862dd29903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaad0b646d98814dc913c53fd44d7e97"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:adaad0b646d98814dc913c53fd44d7e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#adaad0b646d98814dc913c53fd44d7e97">create_sparsity_pattern</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;a)</td></tr>
<tr class="memdesc:adaad0b646d98814dc913c53fd44d7e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form.  <br /></td></tr>
<tr class="separator:adaad0b646d98814dc913c53fd44d7e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb021ee78aa8f2ee2705eaff9855c5b9"><td class="memItemLeft" align="right" valign="top"><a id="aeb021ee78aa8f2ee2705eaff9855c5b9" name="aeb021ee78aa8f2ee2705eaff9855c5b9"></a>
<a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_element_dof_layout</b> (const ufcx_dofmap &amp;dofmap, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">mesh::CellType</a> cell_type, const std::vector&lt; int &gt; &amp;parent_map={})</td></tr>
<tr class="memdesc:aeb021ee78aa8f2ee2705eaff9855c5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html" title="The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh ent...">ElementDofLayout</a> from a ufcx_dofmap. <br /></td></tr>
<tr class="separator:aeb021ee78aa8f2ee2705eaff9855c5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dbcc1a53a46b7cd96b93a1e41d6269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af5dbcc1a53a46b7cd96b93a1e41d6269">create_dofmap</a> (MPI_Comm comm, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;layout, <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn, const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;element)</td></tr>
<tr class="memdesc:af5dbcc1a53a46b7cd96b93a1e41d6269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dof map on mesh.  <br /></td></tr>
<tr class="separator:af5dbcc1a53a46b7cd96b93a1e41d6269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cc717205d7ac69d5eb101dbc335d0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a59cc717205d7ac69d5eb101dbc335d0e">get_coefficient_names</a> (const ufcx_form &amp;ufcx_form)</td></tr>
<tr class="memdesc:a59cc717205d7ac69d5eb101dbc335d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each coefficient in a UFC form.  <br /></td></tr>
<tr class="separator:a59cc717205d7ac69d5eb101dbc335d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00024efad1ca78d948796fb27e268648"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a00024efad1ca78d948796fb27e268648">get_constant_names</a> (const ufcx_form &amp;ufcx_form)</td></tr>
<tr class="memdesc:a00024efad1ca78d948796fb27e268648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each constant in a UFC form.  <br /></td></tr>
<tr class="separator:a00024efad1ca78d948796fb27e268648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d62cac6b73324adb4a113cb4b724fee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3d62cac6b73324adb4a113cb4b724fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3d62cac6b73324adb4a113cb4b724fee">create_form</a> (const ufcx_form &amp;ufcx_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:a3d62cac6b73324adb4a113cb4b724fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input.  <br /></td></tr>
<tr class="separator:a3d62cac6b73324adb4a113cb4b724fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad736ee837e55122073e8c12057fbf681"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad736ee837e55122073e8c12057fbf681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad736ee837e55122073e8c12057fbf681">create_form</a> (const ufcx_form &amp;ufcx_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:ad736ee837e55122073e8c12057fbf681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input.  <br /></td></tr>
<tr class="separator:ad736ee837e55122073e8c12057fbf681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075bdbeb2218c79b3437ca65c0193c2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a7075bdbeb2218c79b3437ca65c0193c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7075bdbeb2218c79b3437ca65c0193c2">create_form</a> (ufcx_form *(*fptr)(), const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;subdomains, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr)</td></tr>
<tr class="memdesc:a7075bdbeb2218c79b3437ca65c0193c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> using a factory function that returns a pointer to a ufcx_form.  <br /></td></tr>
<tr class="separator:a7075bdbeb2218c79b3437ca65c0193c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8d78c1e44756a465038d97a9207287"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a7e8d78c1e44756a465038d97a9207287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7e8d78c1e44756a465038d97a9207287">create_functionspace</a> (std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &gt; mesh, const basix::FiniteElement &amp;e, int bs, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a7e8d78c1e44756a465038d97a9207287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function space from a Basix element.  <br /></td></tr>
<tr class="separator:a7e8d78c1e44756a465038d97a9207287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9895c2e7488de79b88208facd2c27d95"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a9895c2e7488de79b88208facd2c27d95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9895c2e7488de79b88208facd2c27d95">create_functionspace</a> (ufcx_function_space *(*fptr)(const char *), const std::string &amp;function_name, std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &gt; mesh, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a9895c2e7488de79b88208facd2c27d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC data.  <br /></td></tr>
<tr class="separator:a9895c2e7488de79b88208facd2c27d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; T &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a08bb77b3d643db27d9e65e08a1c4b7b9">allocate_coefficient_storage</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> integral_type, int id)</td></tr>
<tr class="memdesc:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for coefficients of a pair <code>(integral_type, id)</code> from a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a08bb77b3d643db27d9e65e08a1c4b7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34293fe58acda313cb52fa5bf6af5c19"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a34293fe58acda313cb52fa5bf6af5c19"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a34293fe58acda313cb52fa5bf6af5c19">allocate_coefficient_storage</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form)</td></tr>
<tr class="memdesc:a34293fe58acda313cb52fa5bf6af5c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for packed coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a34293fe58acda313cb52fa5bf6af5c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3d41645e59a80bc5fb83565ba6bcf6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:afe3d41645e59a80bc5fb83565ba6bcf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afe3d41645e59a80bc5fb83565ba6bcf6">pack_coefficients</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> integral_type, int id, std::span&lt; T &gt; c, int cstride)</td></tr>
<tr class="memdesc:afe3d41645e59a80bc5fb83565ba6bcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> for a given integral type and domain id.  <br /></td></tr>
<tr class="separator:afe3d41645e59a80bc5fb83565ba6bcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39130cd92e31298977fa4dd0c0238efc"><td class="memTemplParams" colspan="2"><a id="a39130cd92e31298977fa4dd0c0238efc" name="a39130cd92e31298977fa4dd0c0238efc"></a>
template&lt;typename T , typename U  = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a39130cd92e31298977fa4dd0c0238efc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_expression</b> (const ufcx_expression &amp;e, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; argument_function_space=nullptr)</td></tr>
<tr class="memdesc:a39130cd92e31298977fa4dd0c0238efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.">Expression</a> from UFC. <br /></td></tr>
<tr class="separator:a39130cd92e31298977fa4dd0c0238efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21567c3d799c2cf9d1d13b9c295d17"><td class="memTemplParams" colspan="2"><a id="a3e21567c3d799c2cf9d1d13b9c295d17" name="a3e21567c3d799c2cf9d1d13b9c295d17"></a>
template&lt;typename T , typename U  = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3e21567c3d799c2cf9d1d13b9c295d17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_expression</b> (const ufcx_expression &amp;e, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;constants, std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt; mesh=nullptr, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; argument_function_space=nullptr)</td></tr>
<tr class="memdesc:a3e21567c3d799c2cf9d1d13b9c295d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.">Expression</a> from UFC input (with named coefficients and constants). <br /></td></tr>
<tr class="separator:a3e21567c3d799c2cf9d1d13b9c295d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8db5346f987c894fa348b1b1af67bd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a8b8db5346f987c894fa348b1b1af67bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8b8db5346f987c894fa348b1b1af67bd">pack_coefficients</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;form, std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a8b8db5346f987c894fa348b1b1af67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>.  <br /></td></tr>
<tr class="separator:a8b8db5346f987c894fa348b1b1af67bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d037c6964d9ff7d996268b3e75008a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::floating_point U&gt; </td></tr>
<tr class="memitem:a54d037c6964d9ff7d996268b3e75008a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; T &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a54d037c6964d9ff7d996268b3e75008a">pack_coefficients</a> (const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt; &amp;e, std::span&lt; const std::int32_t &gt; cells)</td></tr>
<tr class="memdesc:a54d037c6964d9ff7d996268b3e75008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.">Expression</a> u for a give list of active cells.  <br /></td></tr>
<tr class="separator:a54d037c6964d9ff7d996268b3e75008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76745e4ab8bddc25e8451f8d7bcfb8e0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a76745e4ab8bddc25e8451f8d7bcfb8e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename U::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a76745e4ab8bddc25e8451f8d7bcfb8e0">pack_constants</a> (const U &amp;u)</td></tr>
<tr class="memdesc:a76745e4ab8bddc25e8451f8d7bcfb8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack constants of u of generic type U ready for assembly.  <br /></td></tr>
<tr class="separator:a76745e4ab8bddc25e8451f8d7bcfb8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite element method functionality. </p>
<p>Classes and algorithms for finite element method spaces and operations. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac00c421a0f3a4e925538ebc7a05f2962" name="ac00c421a0f3a4e925538ebc7a05f2962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00c421a0f3a4e925538ebc7a05f2962">&#9670;&#160;</a></span>IntegralType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a> : std::int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of integral. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c" name="ac00c421a0f3a4e925538ebc7a05f2962a8d27600b0cae5308441ddf6d9bb3c74c"></a>cell&#160;</td><td class="fielddoc"><p>Cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213" name="ac00c421a0f3a4e925538ebc7a05f2962ab8e8c532206d46c91883de739daed213"></a>exterior_facet&#160;</td><td class="fielddoc"><p>Exterior facet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf" name="ac00c421a0f3a4e925538ebc7a05f2962a55142ac49a379bbdd12dd3fe2e8bcbdf"></a>interior_facet&#160;</td><td class="fielddoc"><p>Interior facet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a" name="ac00c421a0f3a4e925538ebc7a05f2962a2b5bc093b09bd81f51de433bde9d202a"></a>vertex&#160;</td><td class="fielddoc"><p>Vertex. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a34293fe58acda313cb52fa5bf6af5c19" name="a34293fe58acda313cb52fa5bf6af5c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34293fe58acda313cb52fa5bf6af5c19">&#9670;&#160;</a></span>allocate_coefficient_storage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; allocate_coefficient_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for packed coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from a form <code>(integral_type, domain_id)</code> pair to a <code>(coeffs, cstride)</code> pair </dd></dl>

</div>
</div>
<a id="a08bb77b3d643db27d9e65e08a1c4b7b9" name="a08bb77b3d643db27d9e65e08a1c4b7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bb77b3d643db27d9e65e08a1c4b7b9">&#9670;&#160;</a></span>allocate_coefficient_storage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, int &gt; allocate_coefficient_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>&#160;</td>
          <td class="paramname"><em>integral_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage for coefficients of a pair <code>(integral_type, id)</code> from a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Type of integral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id of the integration domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A storage container and the column stride </dd></dl>

</div>
</div>
<a id="a42abdb852de4ecd3bf98fc43f1eae817" name="a42abdb852de4ecd3bf98fc43f1eae817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42abdb852de4ecd3bf98fc43f1eae817">&#9670;&#160;</a></span>apply_lifting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_lifting </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="acecc7021dd7e760e5874e45c7f7cba99" name="acecc7021dd7e760e5874e45c7f7cba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc7021dd7e760e5874e45c7f7cba99">&#9670;&#160;</a></span>apply_lifting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_lifting </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a7374506cfbd6d7a4653eb8565c6d30bc" name="a7374506cfbd6d7a4653eb8565c6d30bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7374506cfbd6d7a4653eb8565c6d30bc">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd42eee23160562035e655ecb00c125d" name="acd42eee23160562035e655ecb00c125d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd42eee23160562035e655ecb00c125d">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;&#160;</td>
          <td class="paramname"><em>dof_marker0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;&#160;</td>
          <td class="paramname"><em>dof_marker1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7677555fb708d688acac92f1370b4c7" name="af7677555fb708d688acac92f1370b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7677555fb708d688acac92f1370b4c7">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0a03f1a72e1ccc0db29e1c78cba755" name="a0b0a03f1a72e1ccc0db29e1c78cba755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0a03f1a72e1ccc0db29e1c78cba755">&#9670;&#160;</a></span>assemble_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">la::MatSet&lt; T &gt; auto&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;&#160;</td>
          <td class="paramname"><em>dof_marker0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int8_t &gt;&#160;</td>
          <td class="paramname"><em>dof_marker1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac167a0c039f5a52846fb32ff121fd8ba" name="ac167a0c039f5a52846fb32ff121fd8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac167a0c039f5a52846fb32ff121fd8ba">&#9670;&#160;</a></span>assemble_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. </p>
<dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="a0f314895ce73b6f0667dc7556cb1b3ab" name="a0f314895ce73b6f0667dc7556cb1b3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f314895ce73b6f0667dc7556cb1b3ab">&#9670;&#160;</a></span>assemble_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. </p>
<p>The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p><dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>M</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>M</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="ac13e0e8a617dbb55d18198e5de2211f9" name="ac13e0e8a617dbb55d18198e5de2211f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13e0e8a617dbb55d18198e5de2211f9">&#9670;&#160;</a></span>assemble_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_vector </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ccb32526016191d2737c974d4bcfd5a" name="a2ccb32526016191d2737c974d4bcfd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb32526016191d2737c974d4bcfd5a">&#9670;&#160;</a></span>assemble_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assemble_vector </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::span&lt; const T &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector. </p>
<p>The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>L</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>L</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab63f8c979acd33aff3439507b9a89029" name="ab63f8c979acd33aff3439507b9a89029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63f8c979acd33aff3439507b9a89029">&#9670;&#160;</a></span>build_dofmap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; build_dofmap_data </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_dof_layouts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build dofmap data for an element on a mesh topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_dof_layouts</td><td>The element dof layouts for the function space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function that is applied to the dofmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index map and local to global DOF data for the DOF map </dd></dl>

</div>
</div>
<a id="ae68fed2204e6da434435b5b526923bd4" name="ae68fed2204e6da434435b5b526923bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68fed2204e6da434435b5b526923bd4">&#9670;&#160;</a></span>common_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt; &gt;, 2 &gt; common_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>Vector function spaces for (0) each row block and (1) each column block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c7654625e34cd1263783aa850e4511" name="a29c7654625e34cd1263783aa850e4511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c7654625e34cd1263783aa850e4511">&#9670;&#160;</a></span>compute_integration_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, std::vector&lt; std::int32_t &gt; &gt; &gt; compute_integration_domains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">fem::IntegralType</a>&#160;</td>
          <td class="paramname"><em>integral_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an integral type and mesh tag data, compute the entities that should be integrated over. </p>
<p>This function returns as list <code>[(id, entities)]</code>, where <code>entities</code> are the entities in <code>meshtags</code> with tag value <code>id</code>. For cell integrals <code>entities</code> are the cell indices. For exterior facet integrals, <code>entities</code> is a list of <code>(cell_index, local_facet_index)</code> pairs. For interior facet integrals, <code>entities</code> is a list of <code>(cell_index0, local_facet_index0, cell_index1, local_facet_index1)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Owned mesh entities only are returned. Ghost entities are not included.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Integral type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of tagged mesh entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of tagged entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Value associated with each entity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of <code>(integral id, entities)</code> pairs </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The topological dimension of the integral entity type and the topological dimension of mesh tag data must be equal. </dd>
<dd>
For facet integrals, the topology facet-to-cell and cell-to-facet connectivity must be computed before calling this function. </dd></dl>

</div>
</div>
<a id="af5dbcc1a53a46b7cd96b93a1e41d6269" name="af5dbcc1a53a46b7cd96b93a1e41d6269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dbcc1a53a46b7cd96b93a1e41d6269">&#9670;&#160;</a></span>create_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> create_dofmap </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dof map on mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The dof layout on an element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The finite element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>The graph reordering function called on the dofmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new dof map </dd></dl>

</div>
</div>
<a id="ad736ee837e55122073e8c12057fbf681" name="ad736ee837e55122073e8c12057fbf681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad736ee837e55122073e8c12057fbf681">&#9670;&#160;</a></span>create_form() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;&#160;</td>
          <td class="paramname"><em>ufcx_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain makers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a3d62cac6b73324adb4a113cb4b724fee" name="a3d62cac6b73324adb4a113cb4b724fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d62cac6b73324adb4a113cb4b724fee">&#9670;&#160;</a></span>create_form() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;&#160;</td>
          <td class="paramname"><em>ufcx_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>The UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>Vector of function spaces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7075bdbeb2218c79b3437ca65c0193c2" name="a7075bdbeb2218c79b3437ca65c0193c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075bdbeb2218c79b3437ca65c0193c2">&#9670;&#160;</a></span>create_form() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; create_form </td>
          <td>(</td>
          <td class="paramtype">ufcx_form *(*)()&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, std::vector&lt; std::pair&lt; std::int32_t, std::vector&lt; std::int32_t &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> using a factory function that returns a pointer to a ufcx_form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td>Pointer to a function returning a pointer to ufcx_form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name), </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name), </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each value in <code>subdomains</code> must be sorted by domain id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a7e8d78c1e44756a465038d97a9207287" name="a7e8d78c1e44756a465038d97a9207287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8d78c1e44756a465038d97a9207287">&#9670;&#160;</a></span>create_functionspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; create_functionspace </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basix::FiniteElement &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function space from a Basix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Basix finite element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bs</td><td>The block size, e.g. 3 for a 'vector' Lagrange element in 3D. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>The graph reordering function to call on the dofmap. If <code>nullptr</code>, the default re-ordering is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created function space </dd></dl>

</div>
</div>
<a id="a9895c2e7488de79b88208facd2c27d95" name="a9895c2e7488de79b88208facd2c27d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9895c2e7488de79b88208facd2c27d95">&#9670;&#160;</a></span>create_functionspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; create_functionspace </td>
          <td>(</td>
          <td class="paramtype">ufcx_function_space *(*)(const char *)&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td>Pointer to a ufcx_function_space_create function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_name</td><td>Name of a function whose function space to create. <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> name is the name of Python variable for ufl.Coefficient, ufl.TrialFunction or ufl.TestFunction as defined in the UFL file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function to call on the dofmap. If <code>nullptr</code>, the default re-ordering is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created function space. </dd></dl>

</div>
</div>
<a id="a2f7a37e1b19b4671f43dec79118e3e18" name="a2f7a37e1b19b4671f43dec79118e3e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7a37e1b19b4671f43dec79118e3e18">&#9670;&#160;</a></span>create_nonmatching_meshes_interpolation_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt; create_nonmatching_meshes_interpolation_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>geometry0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate data needed to interpolate discrete functions across different meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry0</td><td>Mesh geometry of the space to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element0</td><td>Element of the space to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1</td><td>Mesh of the function to interpolate from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the destination mesh on which to interpolate. Should be the same as the list used when calling <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2293c302f0b86dba57605304d92266b0" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99300f6d583f9919dd0e1ec6622462ea" name="a99300f6d583f9919dd0e1ec6622462ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99300f6d583f9919dd0e1ec6622462ea">&#9670;&#160;</a></span>create_nonmatching_meshes_interpolation_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt; create_nonmatching_meshes_interpolation_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate data needed to interpolate discrete functions defined on different meshes. Interpolate on all cells in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh0</td><td>Mesh of the space to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element0</td><td>Element of the space to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1</td><td>Mesh of the function to interpolate from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaad0b646d98814dc913c53fd44d7e97" name="adaad0b646d98814dc913c53fd44d7e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaad0b646d98814dc913c53fd44d7e97">&#9670;&#160;</a></span>create_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> create_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparsity pattern for a given form. </p>
<dl class="section note"><dt>Note</dt><dd>The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding sparsity pattern </dd></dl>

</div>
</div>
<a id="a798d14fb443e82798d1e79170723aabd" name="a798d14fb443e82798d1e79170723aabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798d14fb443e82798d1e79170723aabd">&#9670;&#160;</a></span>discrete_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void discrete_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a> &gt;, std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble a discrete gradient operator. </p>
<p>The discrete gradient operator \(A\) interpolates the gradient of a Lagrange finite element function in \(V_0 \subset H^1\) into a Nédélec (first kind) space \(V_1 \subset H({\rm curl})\), i.e. \(\nabla V_0 \rightarrow V_1\). If \(u_0\) is the degree-of-freedom vector associated with \(V_0\), the hen \(u_1=Au_0\) where \(u_1\) is the degrees-of-freedom vector for interpolating function in the \(H({\rm curl})\) space. An example of where discrete gradient operators are used is the creation of algebraic multigrid solvers for \(H({\rm curl})\) and \(H({\rm div})\) problems.</p>
<dl class="section note"><dt>Note</dt><dd>The sparsity pattern for a discrete operator can be initialised using <a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html#a2cee088c371060bcbe05f7f913f90c95" title="Iterate over cells and insert entries into sparsity pattern.">sparsitybuild::cells</a>. The space <code>V1</code> should be used for the rows of the sparsity pattern, <code>V0</code> for the columns.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function relies on the user supplying appropriate input and output spaces. See parameter descriptions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>Lagrange element and dofmap for corresponding space to interpolate the gradient from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>Nédélec (first kind) element and and dofmap for corresponding space to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>A functor that sets values in a matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c0589b9e21481958b76c8862dd29903" name="a5c0589b9e21481958b76c8862dd29903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0589b9e21481958b76c8862dd29903">&#9670;&#160;</a></span>extract_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;, 2 &gt; &gt; &gt; extract_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A rectangular block on bilinear forms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular array of the same shape as <code>a</code> with a pair of function spaces in each array entry. If a form is null, then the returned function space pair is (null, null). </dd></dl>

</div>
</div>
<a id="a59cc717205d7ac69d5eb101dbc335d0e" name="a59cc717205d7ac69d5eb101dbc335d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cc717205d7ac69d5eb101dbc335d0e">&#9670;&#160;</a></span>get_coefficient_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; get_coefficient_names </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;&#160;</td>
          <td class="paramname"><em>ufcx_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each coefficient in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>The UFC form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of each coefficient </dd></dl>

</div>
</div>
<a id="a00024efad1ca78d948796fb27e268648" name="a00024efad1ca78d948796fb27e268648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00024efad1ca78d948796fb27e268648">&#9670;&#160;</a></span>get_constant_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; get_constant_names </td>
          <td>(</td>
          <td class="paramtype">const ufcx_form &amp;&#160;</td>
          <td class="paramname"><em>ufcx_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each constant in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufcx_form</td><td>The UFC form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of each constant </dd></dl>

</div>
</div>
<a id="ae4f9236f973560257770a583094c3b20" name="ae4f9236f973560257770a583094c3b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f9236f973560257770a583094c3b20">&#9670;&#160;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; U &gt;, std::vector&lt; std::int32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>nmm_interpolation_data</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> to another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The function to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>List of cell indices to interpolate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmm_interpolation_data</td><td>Auxiliary data to interpolate on nonmatching meshes. This data can be generated with create_nonmatching_meshes_interpolation_data (optional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e94bc10b18fa604c007524a859f8d7" name="a75e94bc10b18fa604c007524a859f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e94bc10b18fa604c007524a859f8d7">&#9670;&#160;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>fshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an expression f(x) in a finite element space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Evaluation of the function <code>f(x)</code> at the physical points <code>x</code> given by <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2293c302f0b86dba57605304d92266b0" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. The element used in <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2293c302f0b86dba57605304d92266b0" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a> should be the same element as associated with <code>u</code>. The shape of <code>f</code> should be (value_size, num_points), with row-major storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fshape</td><td>The shape of <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh on which to interpolate. Should be the same as the list used when calling <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2293c302f0b86dba57605304d92266b0" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
    <tr><td class="paramname">U</td><td>Mesh geometry type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2293c302f0b86dba57605304d92266b0" name="a2293c302f0b86dba57605304d92266b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2293c302f0b86dba57605304d92266b0">&#9670;&#160;</a></span>interpolation_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; interpolation_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite element space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be interpolated into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Mesh geometry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh to compute interpolation coordinates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates in the physical space at which to evaluate an expression. The shape is (3, num_points) and storage is row-major. </dd></dl>

</div>
</div>
<a id="ad46c61a5c9cc2c1964a261c3a868cb4f" name="ad46c61a5c9cc2c1964a261c3a868cb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c61a5c9cc2c1964a261c3a868cb4f">&#9670;&#160;</a></span>interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble an interpolation operator matrix. </p>
<p>The interpolation operator \(A\) interpolates a function in the space \(V_0\) into a space \(V_1\). If \(u_0\) is the degree-of-freedom vector associated with \(V_0\), then the degree-of-freedom vector \(u_1\) for the interpolated function in \(V_1\) is given by \(u_1=Au_0\).</p>
<dl class="section note"><dt>Note</dt><dd>The sparsity pattern for a discrete operator can be initialised using <a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html#a2cee088c371060bcbe05f7f913f90c95" title="Iterate over cells and insert entries into sparsity pattern.">sparsitybuild::cells</a>. The space <code>V1</code> should be used for the rows of the sparsity pattern, <code>V0</code> for the columns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>The space to interpolate from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>The space to interpolate to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>A functor that sets values in a matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a0d39b240c84457b5d10674737d31c5" name="a7a0d39b240c84457b5d10674737d31c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0d39b240c84457b5d10674737d31c5">&#9670;&#160;</a></span>locate_dofs_geometrical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees of freedom will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="a6129e579cd57550d8dd008ef03e86ba0" name="a6129e579cd57550d8dd008ef03e86ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6129e579cd57550d8dd008ef03e86ba0">&#9670;&#160;</a></span>locate_dofs_geometrical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; T &gt; &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space(s) on which degrees of freedom will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the corresponding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="a2b1ce27cbdde6bbde8683e7777bb91ff" name="a2b1ce27cbdde6bbde8683e7777bb91ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1ce27cbdde6bbde8683e7777bb91ff">&#9670;&#160;</a></span>locate_dofs_topological() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>Dofmap that associated DOFs with cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="af5128b1414b0974ba7024f0c936d92d1" name="af5128b1414b0974ba7024f0c936d92d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5128b1414b0974ba7024f0c936d92d1">&#9670;&#160;</a></span>locate_dofs_topological() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> &gt;, 2 &gt;&#160;</td>
          <td class="paramname"><em>dofmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Mesh topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmaps</td><td>The dofmaps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the corresponding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="a54d037c6964d9ff7d996268b3e75008a" name="a54d037c6964d9ff7d996268b3e75008a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d037c6964d9ff7d996268b3e75008a">&#9670;&#160;</a></span>pack_coefficients() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; T &gt;, int &gt; pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.">Expression</a> u for a give list of active cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell.">Expression</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>A list of active cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of the form (coeffs, cstride) </dd></dl>

</div>
</div>
<a id="afe3d41645e59a80bc5fb83565ba6bcf6" name="afe3d41645e59a80bc5fb83565ba6bcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3d41645e59a80bc5fb83565ba6bcf6">&#9670;&#160;</a></span>pack_coefficients() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>&#160;</td>
          <td class="paramname"><em>integral_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> for a given integral type and domain id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Type of integral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id of the integration domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The coefficient array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cstride</td><td>The coefficient stride </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8db5346f987c894fa348b1b1af67bd" name="a8b8db5346f987c894fa348b1b1af67bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8db5346f987c894fa348b1b1af67bd">&#9670;&#160;</a></span>pack_coefficients() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac00c421a0f3a4e925538ebc7a05f2962">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is subject to change </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="A representation of finite element variational forms.">Form</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>A map from a (integral_type, domain_id) pair to a (coeffs, cstride) pair </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76745e4ab8bddc25e8451f8d7bcfb8e0" name="a76745e4ab8bddc25e8451f8d7bcfb8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76745e4ab8bddc25e8451f8d7bcfb8e0">&#9670;&#160;</a></span>pack_constants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename U::scalar_type &gt; pack_constants </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack constants of u of generic type U ready for assembly. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is subject to change </dd></dl>

</div>
</div>
<a id="acc24359fabe9bd7b729e37d5ba37819f" name="acc24359fabe9bd7b729e37d5ba37819f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc24359fabe9bd7b729e37d5ba37819f">&#9670;&#160;</a></span>set_diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_diagonal </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>set_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. </p>
<p>This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space for the rows and columns of the matrix. It is used to extract only the Dirichlet boundary conditions that are define on V or subspaces of V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>The Dirichlet boundary conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for rows with a boundary condition applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2482e48a77b23eb1b433c81552a70467" name="a2482e48a77b23eb1b433c81552a70467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2482e48a77b23eb1b433c81552a70467">&#9670;&#160;</a></span>set_diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_diagonal </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>set_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of a matrix for specified rows. </p>
<p>This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row blocks, in local indices, for which to add a value to the diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for the specified rows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa80fbbb7d5da42a5be17e8f9b7ba90c2" name="aa80fbbb7d5da42a5be17e8f9b7ba90c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80fbbb7d5da42a5be17e8f9b7ba90c2">&#9670;&#160;</a></span>transpose_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; transpose_dofmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>num_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. </p>
<p>It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index. If the usual dof map is:</p>
<p><code>Cell: 0 1 2 3</code> <br  />
 <code>Global index: [ [0, 3, 5], [3, 2, 4], [4, 3, 2], [2, 1, 0]]</code></p>
<p>the 'transpose' dof map will be:</p>
<p><code>Global index: 0 1 2 3 4 5</code> <br  />
 <code>Unassembled index: [ [0, 11], [10], [4, 8, 9], [1, 3, 7], [5, 6], [2] ]</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The standard dof map that for each cell (node) gives the global (process-wise) index of each local (cell-wise) index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>The number of cells (nodes) in <code>dofmap</code> to consider. The first <code>num_cells</code> are used. This is argument is typically used to exclude ghost cell contributions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from global (process-wise) index to positions in an unaassembled array. The links for each node are sorted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

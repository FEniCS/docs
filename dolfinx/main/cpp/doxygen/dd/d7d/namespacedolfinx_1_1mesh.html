<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::mesh Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.10.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a href="../../dd/d7d/namespacedolfinx_1_1mesh.html">mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::mesh Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:EntityMap" id="r_EntityMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">EntityMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional map relating entities in one topology to another.  <a href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:Geometry" id="r_Geometry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> stores the geometry imposed on a mesh.  <a href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html#details">More...</a><br /></td></tr>
<tr class="memitem:Mesh" id="r_Mesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> consists of a set of connected and numbered mesh topological entities, and geometry data.  <a href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshTags" id="r_MeshTags"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> associate values with mesh topology entities.  <a href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html#details">More...</a><br /></td></tr>
<tr class="memitem:Topology" id="r_Topology"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html" title="Topology stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relat...">Topology</a> stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relations for the mesh entities).  <a href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:MarkerFn" id="r_MarkerFn"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7b/conceptdolfinx_1_1mesh_1_1MarkerFn.html">MarkerFn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requirements on function for geometry marking. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acab22e3b5c8ac14664c8cd8e6f53fb70" id="r_acab22e3b5c8ac14664c8cd8e6f53fb70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td></tr>
<tr class="memdesc:acab22e3b5c8ac14664c8cd8e6f53fb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the cell partitioning function. Function that implement this interface compute the destination rank for cells currently on this rank.  <br /></td></tr>
<tr class="memitem:a6ae04a49cad2b0638dbc083a221f2279" id="r_a6ae04a49cad2b0638dbc083a221f2279"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a></td></tr>
<tr class="memdesc:a6ae04a49cad2b0638dbc083a221f2279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reorders (locally) cells that are owned by this process. It takes the local mesh dual graph as an argument and returns a list whose <span class="tt">i</span>th entry is the new index of cell <span class="tt">i</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7ff1deb71d3bfcd4e6b2426a59bbfde0" id="r_a7ff1deb71d3bfcd4e6b2426a59bbfde0"><td class="memItemLeft" align="right" valign="top"><a id="a7ff1deb71d3bfcd4e6b2426a59bbfde0" name="a7ff1deb71d3bfcd4e6b2426a59bbfde0"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> : std::int8_t { <br />
&#160;&#160;<b>point</b> = 1
, <b>interval</b> = 2
, <b>triangle</b> = 3
, <b>tetrahedron</b> = 4
, <br />
&#160;&#160;<b>quadrilateral</b> = -4
, <b>pyramid</b> = -5
, <b>prism</b> = -6
, <b>hexahedron</b> = -8
<br />
 }</td></tr>
<tr class="memdesc:a7ff1deb71d3bfcd4e6b2426a59bbfde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell type identifier. <br /></td></tr>
<tr class="memitem:a5fb0494804cb9b4baeeff5b9027a8dfd" id="r_a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="memItemLeft" align="right" valign="top"><a id="a5fb0494804cb9b4baeeff5b9027a8dfd" name="a5fb0494804cb9b4baeeff5b9027a8dfd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> { <br />
&#160;&#160;<b>left</b>
, <b>right</b>
, <b>crossed</b>
, <b>shared_facet</b>
, <br />
&#160;&#160;<b>left_right</b>
, <b>right_left</b>
<br />
 }</td></tr>
<tr class="memdesc:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different diagonal types. <br /></td></tr>
<tr class="memitem:aea1d3aae687d7fb2b510fd12026ecd4e" id="r_aea1d3aae687d7fb2b510fd12026ecd4e"><td class="memItemLeft" align="right" valign="top"><a id="aea1d3aae687d7fb2b510fd12026ecd4e" name="aea1d3aae687d7fb2b510fd12026ecd4e"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">GhostMode</a> : std::uint8_t { <b>none</b>
, <b>shared_facet</b>
 }</td></tr>
<tr class="memdesc:aea1d3aae687d7fb2b510fd12026ecd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different partitioning ghost modes. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1f0961be83abe152e146c14c8f8548a" id="r_ae1f0961be83abe152e146c14c8f8548a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1f0961be83abe152e146c14c8f8548a">to_string</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type)</td></tr>
<tr class="memitem:aec82a925447a9da2a086b7c93739ba9c" id="r_aec82a925447a9da2a086b7c93739ba9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec82a925447a9da2a086b7c93739ba9c">to_type</a> (const std::string &amp;cell)</td></tr>
<tr class="memitem:a6abcbdca3e3aae2fe00ad6ea7186cb0c" id="r_a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="memItemLeft" align="right" valign="top"><a id="a6abcbdca3e3aae2fe00ad6ea7186cb0c" name="a6abcbdca3e3aae2fe00ad6ea7186cb0c"></a>
<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_entity_type</b> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type, int d, int index)</td></tr>
<tr class="memdesc:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of cell for entity of dimension d at given entity index. <br /></td></tr>
<tr class="memitem:a66c376aedd08ad2dab6f13eba56b6f36" id="r_a66c376aedd08ad2dab6f13eba56b6f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66c376aedd08ad2dab6f13eba56b6f36">cell_facet_type</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type, int index)</td></tr>
<tr class="memitem:a928c84854cdb3701ae7410d2f2c1a913" id="r_a928c84854cdb3701ae7410d2f2c1a913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928c84854cdb3701ae7410d2f2c1a913">get_entity_vertices</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type, int dim)</td></tr>
<tr class="memitem:afec08aa43ab0e757eca314632a5b5c1b" id="r_afec08aa43ab0e757eca314632a5b5c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec08aa43ab0e757eca314632a5b5c1b">get_sub_entities</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type, int dim0, int dim1)</td></tr>
<tr class="memitem:a6984abad1707caa0c97b4e4b167106b3" id="r_a6984abad1707caa0c97b4e4b167106b3"><td class="memItemLeft" align="right" valign="top"><a id="a6984abad1707caa0c97b4e4b167106b3" name="a6984abad1707caa0c97b4e4b167106b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cell_dim</b> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type)</td></tr>
<tr class="memdesc:a6984abad1707caa0c97b4e4b167106b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return topological dimension of cell type. <br /></td></tr>
<tr class="memitem:abe2926fe64174120b2e865e0b7bf9946" id="r_abe2926fe64174120b2e865e0b7bf9946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe2926fe64174120b2e865e0b7bf9946">cell_num_entities</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type, int dim)</td></tr>
<tr class="memitem:ac88526e97d1edbaacb8471c0e9288a03" id="r_ac88526e97d1edbaacb8471c0e9288a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac88526e97d1edbaacb8471c0e9288a03">is_simplex</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type)</td></tr>
<tr class="memitem:a80294da14ab051e9f8eaf72080a7ee17" id="r_a80294da14ab051e9f8eaf72080a7ee17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80294da14ab051e9f8eaf72080a7ee17">num_cell_vertices</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> type)</td></tr>
<tr class="memitem:aacd44e8136c15b9593dfdd87cd744c32" id="r_aacd44e8136c15b9593dfdd87cd744c32"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::array&lt; int, 2 &gt;, std::vector&lt; std::set&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd44e8136c15b9593dfdd87cd744c32">cell_entity_closure</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> cell_type)</td></tr>
<tr class="memitem:aa44a1bbf3077eacea89cf5f62c24fe68" id="r_aa44a1bbf3077eacea89cf5f62c24fe68"><td class="memItemLeft" align="right" valign="top"><a id="aa44a1bbf3077eacea89cf5f62c24fe68" name="aa44a1bbf3077eacea89cf5f62c24fe68"></a>
basix::cell::type&#160;</td><td class="memItemRight" valign="bottom"><b>cell_type_to_basix_type</b> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> celltype)</td></tr>
<tr class="memdesc:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cell type to a Basix cell type. <br /></td></tr>
<tr class="memitem:a6c079ec392bf6c24c4879a67f53f4af8" id="r_a6c079ec392bf6c24c4879a67f53f4af8"><td class="memItemLeft" align="right" valign="top"><a id="a6c079ec392bf6c24c4879a67f53f4af8" name="a6c079ec392bf6c24c4879a67f53f4af8"></a>
<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_type_from_basix_type</b> (basix::cell::type celltype)</td></tr>
<tr class="memdesc:a6c079ec392bf6c24c4879a67f53f4af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cell type from a Basix cell type. <br /></td></tr>
<tr class="memitem:a72443a6c92cbec1609f371cb02b9f0d1" id="r_a72443a6c92cbec1609f371cb02b9f0d1"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a72443a6c92cbec1609f371cb02b9f0d1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72443a6c92cbec1609f371cb02b9f0d1">create_box</a> (MPI_Comm comm, MPI_Comm subcomm, std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 3 &gt; n, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> celltype, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner=nullptr, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:a72443a6c92cbec1609f371cb02b9f0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:a0380a96c220af888dca75b52089a220c" id="r_a0380a96c220af888dca75b52089a220c"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a0380a96c220af888dca75b52089a220c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0380a96c220af888dca75b52089a220c">create_box</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 3 &gt; n, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> celltype, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner=nullptr, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:a0380a96c220af888dca75b52089a220c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:a039ebe1f5145c2083a2296563b172605" id="r_a039ebe1f5145c2083a2296563b172605"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a039ebe1f5145c2083a2296563b172605 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a039ebe1f5145c2083a2296563b172605">create_rectangle</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 2 &gt; n, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> celltype, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner, <a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:a039ebe1f5145c2083a2296563b172605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:a327c492002b54befefb2077e4b5f861c" id="r_a327c492002b54befefb2077e4b5f861c"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a327c492002b54befefb2077e4b5f861c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327c492002b54befefb2077e4b5f861c">create_rectangle</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 2 &gt; n, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> celltype, <a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right)</td></tr>
<tr class="memdesc:a327c492002b54befefb2077e4b5f861c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:ac1a1f8d09938c720131fa7a5f229568e" id="r_ac1a1f8d09938c720131fa7a5f229568e"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:ac1a1f8d09938c720131fa7a5f229568e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1a1f8d09938c720131fa7a5f229568e">create_interval</a> (MPI_Comm comm, std::int64_t n, std::array&lt; T, 2 &gt; p, <a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">mesh::GhostMode</a> ghost_mode=mesh::GhostMode::none, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner=nullptr, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:ac1a1f8d09938c720131fa7a5f229568e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval mesh of the 1D line <span class="tt">[a, b]</span>.  <br /></td></tr>
<tr class="memitem:a9f1a204290ebf7fa49bf222e542fe36f" id="r_a9f1a204290ebf7fa49bf222e542fe36f"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a9f1a204290ebf7fa49bf222e542fe36f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f1a204290ebf7fa49bf222e542fe36f">create_geometry</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;elements, std::span&lt; const std::int64_t &gt; nodes, std::span&lt; const std::int64_t &gt; xdofs, const U &amp;x, int dim, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a9f1a204290ebf7fa49bf222e542fe36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data.  <br /></td></tr>
<tr class="memitem:a56638f86b4503af796a8b8991a69c30b" id="r_a56638f86b4503af796a8b8991a69c30b"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56638f86b4503af796a8b8991a69c30b">build_local_dual_graph</a> (std::span&lt; const <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt; celltypes, const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;cells, std::optional&lt; std::int32_t &gt; max_facet_to_cell_links=2)</td></tr>
<tr class="memdesc:a56638f86b4503af796a8b8991a69c30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the local part of the dual graph (cell-cell connections via facets) and facets with only one attached cell.  <br /></td></tr>
<tr class="memitem:ae72ddf156d9cc7a5d7429237c671b9c9" id="r_ae72ddf156d9cc7a5d7429237c671b9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae72ddf156d9cc7a5d7429237c671b9c9">build_dual_graph</a> (MPI_Comm comm, std::span&lt; const <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt; celltypes, const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;cells, std::optional&lt; std::int32_t &gt; max_facet_to_cell_links=2)</td></tr>
<tr class="memdesc:ae72ddf156d9cc7a5d7429237c671b9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data.  <br /></td></tr>
<tr class="memitem:a2bdcd9e9469ae3185e6ca6a3ee3fa581" id="r_a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2bdcd9e9469ae3185e6ca6a3ee3fa581 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bdcd9e9469ae3185e6ca6a3ee3fa581">create_meshtags</a> (std::shared_ptr&lt; const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &gt; topology, int dim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;entities, std::span&lt; const T &gt; values)</td></tr>
<tr class="memdesc:a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> from arrays.  <br /></td></tr>
<tr class="memitem:aeb806bcc85940ea4818196d210d7dff7" id="r_aeb806bcc85940ea4818196d210d7dff7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb806bcc85940ea4818196d210d7dff7">compute_entity_permutations</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="memitem:a3f0323e28305c7aa394d8ecbfeb905c6" id="r_a3f0323e28305c7aa394d8ecbfeb905c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0323e28305c7aa394d8ecbfeb905c6">create_topology</a> (MPI_Comm comm, const std::vector&lt; <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt; &amp;cell_types, std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; cells, std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; original_cell_index, std::vector&lt; std::span&lt; const int &gt; &gt; ghost_owners, std::span&lt; const std::int64_t &gt; boundary_vertices)</td></tr>
<tr class="memdesc:a3f0323e28305c7aa394d8ecbfeb905c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh topology.  <br /></td></tr>
<tr class="memitem:a332133c6fd59b509e8a60420ba7bc67b" id="r_a332133c6fd59b509e8a60420ba7bc67b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a332133c6fd59b509e8a60420ba7bc67b">create_topology</a> (MPI_Comm comm, std::span&lt; const std::int64_t &gt; cells, std::span&lt; const std::int64_t &gt; original_cell_index, std::span&lt; const int &gt; ghost_owners, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> cell_type, std::span&lt; const std::int64_t &gt; boundary_vertices)</td></tr>
<tr class="memdesc:a332133c6fd59b509e8a60420ba7bc67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh topology for a single cell type.  <br /></td></tr>
<tr class="memitem:a6af09e67e8db0d211e9b00393cf9f5ae" id="r_a6af09e67e8db0d211e9b00393cf9f5ae"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>, std::vector&lt; int32_t &gt;, std::vector&lt; int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af09e67e8db0d211e9b00393cf9f5ae">create_subtopology</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a6af09e67e8db0d211e9b00393cf9f5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a topology for a subset of entities of a given topological dimension.  <br /></td></tr>
<tr class="memitem:af81ae5994989c886b804b3f6b64275fd" id="r_af81ae5994989c886b804b3f6b64275fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81ae5994989c886b804b3f6b64275fd">entities_to_index</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:af81ae5994989c886b804b3f6b64275fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entity indices for entities defined by their vertices.  <br /></td></tr>
<tr class="memitem:ad451e1d60af5b31e3d8fc950f35ee31c" id="r_ad451e1d60af5b31e3d8fc950f35ee31c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad451e1d60af5b31e3d8fc950f35ee31c">compute_mixed_cell_pairs</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a> facet_type)</td></tr>
<tr class="memdesc:ad451e1d60af5b31e3d8fc950f35ee31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a list of cell-cell connections for each possible combination in the topology which have the same connecting facet type.  <br /></td></tr>
<tr class="memitem:a9555ca279c1bd88d79220fcfdf9c019e" id="r_a9555ca279c1bd88d79220fcfdf9c019e"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9555ca279c1bd88d79220fcfdf9c019e">compute_entities</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> entity_type)</td></tr>
<tr class="memdesc:a9555ca279c1bd88d79220fcfdf9c019e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh entities of given topological dimension by computing cell-to-entity <span class="tt">(tdim, i) -&gt; </span>(dim, entity_type)<span class="tt"> and
/ entity-to-vertex connectivity </span>(dim, entity_type) -&gt; <span class="tt">(0, 0)</span> connectivity.  <br /></td></tr>
<tr class="memitem:a86452baf0d97bcbb8ffee0131c8338eb" id="r_a86452baf0d97bcbb8ffee0131c8338eb"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86452baf0d97bcbb8ffee0131c8338eb">compute_connectivity</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, std::array&lt; int, 2 &gt; d0, std::array&lt; int, 2 &gt; d1)</td></tr>
<tr class="memdesc:a86452baf0d97bcbb8ffee0131c8338eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connectivity (d0 -&gt; d1) for given pair of entity types, given by topological dimension and index, as found in <span class="tt"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#a84c162f215cf4619f2d4e112ff0eef00" title="Entity types in the topology for a given dimension.">Topology::entity_types()</a></span>  <br /></td></tr>
<tr class="memitem:a7f25ea9250efb80e92fa44d379f3afa4" id="r_a7f25ea9250efb80e92fa44d379f3afa4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f25ea9250efb80e92fa44d379f3afa4">exterior_facet_indices</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int facet_type_idx)</td></tr>
<tr class="memdesc:a7f25ea9250efb80e92fa44d379f3afa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indices of all exterior facets that are owned by the caller.  <br /></td></tr>
<tr class="memitem:abcd805c0f4a1ee1533a6b05417ddcaa1" id="r_abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd805c0f4a1ee1533a6b05417ddcaa1">exterior_facet_indices</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="memdesc:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indices of all exterior facets that are owned by the caller.  <br /></td></tr>
<tr class="memitem:a9de66904187ae980935d3603d65e5e13" id="r_a9de66904187ae980935d3603d65e5e13"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de66904187ae980935d3603d65e5e13">create_boundary_vertices_fn</a> (const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn)</td></tr>
<tr class="memdesc:a9de66904187ae980935d3603d65e5e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the default boundary vertices routine for a given reorder function.  <br /></td></tr>
<tr class="memitem:ac0d9b5cca14603833020dfa05d886207" id="r_ac0d9b5cca14603833020dfa05d886207"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d9b5cca14603833020dfa05d886207">extract_topology</a> (<a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> cell_type, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;layout, std::span&lt; const std::int64_t &gt; cells)</td></tr>
<tr class="memdesc:ac0d9b5cca14603833020dfa05d886207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract topology from cell data, i.e. extract cell vertices.  <br /></td></tr>
<tr class="memitem:a8294c20389ab1f3b4c5b70eaa6f1dc00" id="r_a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a8294c20389ab1f3b4c5b70eaa6f1dc00 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8294c20389ab1f3b4c5b70eaa6f1dc00">h</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, std::span&lt; const std::int32_t &gt; entities, int dim)</td></tr>
<tr class="memdesc:a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute greatest distance between any two vertices of the mesh entities (<span class="tt">h</span>).  <br /></td></tr>
<tr class="memitem:a67fa456882009e9a0025061837b40e55" id="r_a67fa456882009e9a0025061837b40e55"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a67fa456882009e9a0025061837b40e55 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67fa456882009e9a0025061837b40e55">cell_normals</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a67fa456882009e9a0025061837b40e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normal to given cell (viewed as embedded in 3D).  <br /></td></tr>
<tr class="memitem:ad4dbbf93d4d231f00b543bf8cc9fece7" id="r_ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ad4dbbf93d4d231f00b543bf8cc9fece7 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4dbbf93d4d231f00b543bf8cc9fece7">compute_midpoints</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the midpoints for mesh entities of a given dimension.  <br /></td></tr>
<tr class="memitem:ac50e2b6669877ea08fd2743981d3b907" id="r_ac50e2b6669877ea08fd2743981d3b907"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:ac50e2b6669877ea08fd2743981d3b907 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac50e2b6669877ea08fd2743981d3b907">locate_entities</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, U marker, int entity_type_idx)</td></tr>
<tr class="memdesc:ac50e2b6669877ea08fd2743981d3b907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that evaluate to true for the provided geometric marking function.  <br /></td></tr>
<tr class="memitem:ab344919e038891a57c7a943cc5a420ee" id="r_ab344919e038891a57c7a943cc5a420ee"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:ab344919e038891a57c7a943cc5a420ee template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab344919e038891a57c7a943cc5a420ee">locate_entities</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, U marker)</td></tr>
<tr class="memdesc:ab344919e038891a57c7a943cc5a420ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that evaluate to true for the provided geometric marking function.  <br /></td></tr>
<tr class="memitem:a7f4773c26421814d452b07150df4ece8" id="r_a7f4773c26421814d452b07150df4ece8"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:a7f4773c26421814d452b07150df4ece8 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4773c26421814d452b07150df4ece8">locate_entities_boundary</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, U marker)</td></tr>
<tr class="memdesc:a7f4773c26421814d452b07150df4ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function.  <br /></td></tr>
<tr class="memitem:ab28a78ae146e601321bd3f1235842e02" id="r_ab28a78ae146e601321bd3f1235842e02"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ab28a78ae146e601321bd3f1235842e02 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::int32_t &gt;, std::array&lt; std::size_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28a78ae146e601321bd3f1235842e02">entities_to_geometry</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities, bool permute=false)</td></tr>
<tr class="memdesc:ab28a78ae146e601321bd3f1235842e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry degrees of freedom associated with the closure of a given set of cell entities.  <br /></td></tr>
<tr class="memitem:aff22d3fa3023edcd8cdd5d8550b19484" id="r_aff22d3fa3023edcd8cdd5d8550b19484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a> (<a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">mesh::GhostMode</a> ghost_mode=mesh::GhostMode::none, const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#aa2e8bbea5ac3a27249e3155bc455f887">graph::partition_fn</a> &amp;partfn=&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a>)</td></tr>
<tr class="memdesc:aff22d3fa3023edcd8cdd5d8550b19484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function that computes destination rank for mesh cells on this rank by applying the default graph partitioner to the dual graph of the mesh.  <br /></td></tr>
<tr class="memitem:abec76d69eb4bf33692781bc8995c9b5f" id="r_abec76d69eb4bf33692781bc8995c9b5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec76d69eb4bf33692781bc8995c9b5f">compute_incident_entities</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, std::span&lt; const std::int32_t &gt; entities, int d0, int d1)</td></tr>
<tr class="memdesc:abec76d69eb4bf33692781bc8995c9b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute incident entities.  <br /></td></tr>
<tr class="memitem:ae172f8e7a0ae9871f969d8d9f861bbf7" id="r_ae172f8e7a0ae9871f969d8d9f861bbf7"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ae172f8e7a0ae9871f969d8d9f861bbf7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae172f8e7a0ae9871f969d8d9f861bbf7">create_mesh</a> (MPI_Comm comm, MPI_Comm commt, std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; cells, const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;elements, MPI_Comm commg, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:ae172f8e7a0ae9871f969d8d9f861bbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> from mesh data and using the provided graph partitioning function for determining the parallel distribution of the mesh.  <br /></td></tr>
<tr class="memitem:a21548d376331e4a8cb443b7cdbceeb22" id="r_a21548d376331e4a8cb443b7cdbceeb22"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a21548d376331e4a8cb443b7cdbceeb22 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21548d376331e4a8cb443b7cdbceeb22">create_mesh</a> (MPI_Comm comm, MPI_Comm commt, std::span&lt; const std::int64_t &gt; cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;element, MPI_Comm commg, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner, const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;reorder_fn=<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a>)</td></tr>
<tr class="memdesc:a21548d376331e4a8cb443b7cdbceeb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mesh with a single cell type from mesh data and using a provided graph partitioning function for determining the parallel distribution of the mesh.  <br /></td></tr>
<tr class="memitem:ada3471710d7fca68f819993efab03d81" id="r_ada3471710d7fca68f819993efab03d81"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ada3471710d7fca68f819993efab03d81 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada3471710d7fca68f819993efab03d81">create_mesh</a> (MPI_Comm comm, std::span&lt; const std::int64_t &gt; cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;elements, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, <a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">GhostMode</a> ghost_mode)</td></tr>
<tr class="memdesc:ada3471710d7fca68f819993efab03d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mesh from mesh data using the default graph partitioner to determine the parallel distribution of the mesh.  <br /></td></tr>
<tr class="memitem:a8e805f1f5252c2cc4c88a00ad6393025" id="r_a8e805f1f5252c2cc4c88a00ad6393025"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a8e805f1f5252c2cc4c88a00ad6393025 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; T &gt;, std::vector&lt; int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e805f1f5252c2cc4c88a00ad6393025">create_subgeometry</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; subentity_to_entity)</td></tr>
<tr class="memdesc:a8e805f1f5252c2cc4c88a00ad6393025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sub-geometry from a mesh and a subset of mesh entities to be included.  <br /></td></tr>
<tr class="memitem:a6ba043a7e771c657a95b435c70dc1395" id="r_a6ba043a7e771c657a95b435c70dc1395"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a6ba043a7e771c657a95b435c70dc1395 template"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;, <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">EntityMap</a>, <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">EntityMap</a>, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ba043a7e771c657a95b435c70dc1395">create_submesh</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a6ba043a7e771c657a95b435c70dc1395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new mesh consisting of a subset of entities in a mesh.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes. </p>
<p>Representations of meshes and support for operations on meshes. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="acab22e3b5c8ac14664c8cd8e6f53fb70" name="acab22e3b5c8ac14664c8cd8e6f53fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab22e3b5c8ac14664c8cd8e6f53fb70">&#9670;&#160;</a></span>CellPartitionFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;graph::AdjacencyList&lt;std::int32_t&gt;(</div>
<div class="line">    MPI_Comm comm, <span class="keywordtype">int</span> nparts, <span class="keyword">const</span> std::vector&lt;CellType&gt;&amp; cell_types,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::span&lt;const std::int64_t&gt;&gt;&amp; cells)&gt;</div>
</div><!-- fragment -->
<p>Signature for the cell partitioning function. Function that implement this interface compute the destination rank for cells currently on this rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nparts</td><td>Number of partitions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_types</td><td>Cell types in the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Lists of cells of each cell type. <span class="tt">cells[i]</span> is a flattened row major 2D array of shape (num_cells, num_cell_vertices) for <span class="tt">cell_types[i]</span> on this process, containing the global indices for the cell vertices. Each cell can appear only once across all processes. The cell vertex indices are not necessarily contiguous globally, i.e. the maximum index across all processes can be greater than the number of vertices. High-order 'nodes', e.g. mid-side points, should not be included. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destination ranks for each cell on this process. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cells can have multiple destination ranks, when ghosted. </dd></dl>

</div>
</div>
<a id="a6ae04a49cad2b0638dbc083a221f2279" name="a6ae04a49cad2b0638dbc083a221f2279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae04a49cad2b0638dbc083a221f2279">&#9670;&#160;</a></span>CellReorderFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;std::vector&lt;std::int32_t&gt;(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList&lt;std::int32_t&gt;</a>&amp;)&gt;</div>
<div class="ttc" id="aclassdolfinx_1_1graph_1_1AdjacencyList_html"><div class="ttname"><a href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">dolfinx::graph::AdjacencyList</a></div><div class="ttdoc">This class provides a static adjacency list data structure.</div><div class="ttdef"><b>Definition</b> AdjacencyList.h:38</div></div>
</div><!-- fragment -->
<p>Function that reorders (locally) cells that are owned by this process. It takes the local mesh dual graph as an argument and returns a list whose <span class="tt">i</span>th entry is the new index of cell <span class="tt">i</span>. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae72ddf156d9cc7a5d7429237c671b9c9" name="ae72ddf156d9cc7a5d7429237c671b9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72ddf156d9cc7a5d7429237c671b9c9">&#9670;&#160;</a></span>build_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; build_dual_graph </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>celltypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>max_facet_to_cell_links</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data. </p>
<p>The computed dual graph is typically passed to a graph partitioner.</p>
<dl class="section note"><dt>Note</dt><dd>Collective function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltypes</td><td>List of cell types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Collections of cells, defined by the cell vertices from which to build the dual graph, as flattened arrays for each cell type in <span class="tt">celltypes</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_facet_to_cell_links</td><td>Bound on the number of cells a facet needs to be connected to to be considered <em>matched</em>, i.e. a matched facet is not connected any cells on other processes. All facets connected to less than <span class="tt">max_facet_to_cell_links</span> cells are considered <em>unmatched</em> and parallel communication will check for further connections. Defaults to <span class="tt">2</span>, which covers non-branching manifold meshes. Passing std::nullopt (no upper bound) corresponds to <span class="tt">max_facet_to_cell_links</span>=∞, i.e. every facet is considered unmatched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dual graph.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><span class="tt">cells</span> and <span class="tt">celltypes</span> must have the same size.</dd>
<dd>
The assumption in <span class="tt">build_local_dual_graph</span> on how unmatched facets are identified will not allow for T-joints (or any other higher branching) across process boundaries to be picked up by the dual graph. If the joints do not live on the process boundary this is not a problem. </dd></dl>

</div>
</div>
<a id="a56638f86b4503af796a8b8991a69c30b" name="a56638f86b4503af796a8b8991a69c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56638f86b4503af796a8b8991a69c30b">&#9670;&#160;</a></span>build_local_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt; build_local_dual_graph </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>celltypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>max_facet_to_cell_links</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the local part of the dual graph (cell-cell connections via facets) and facets with only one attached cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">celltypes</td><td>List of cell types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Lists of cell vertices (stored as flattened lists, one for each cell type). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_facet_to_cell_links</td><td>Bound on the number of cells a facet needs to be connected to to be considered <em>matched</em>, i.e. a matched facet is not connected any cells on other processes. All facets connected to less than <span class="tt">max_facet_to_cell_links</span> cells are considered <em>unmatched</em> and parallel communication will check for further connections. Defaults to <span class="tt">2</span>, which covers non-branching manifold meshes. Passing std::nullopt (no upper bound) corresponds to <span class="tt">max_facet_to_cell_links</span>=∞, i.e. every facet is considered unmatched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>Local dual graph</li>
<li>Facets, defined by their sorted vertices, that are shared by only <span class="tt">max_facet_to_cell_links</span> or less cells on this rank. The logically 2D array is flattened (row-major).</li>
<li>Facet data array (2) number of columns</li>
<li>Attached cell (local index) to each returned facet in (2).</li>
</ol>
</dd></dl>
<p>Each row of the returned data (2) contains <span class="tt">[v0, ... v_(n-1), x, ..,
/ x]</span>, where <span class="tt">v_i</span> is a vertex global index, <span class="tt">x</span> is a negative value (all padding values will be equal). The vertex global indices are sorted for each facet.</p>
<dl class="section note"><dt>Note</dt><dd>The cells of each cell type are numbered locally consecutively, i.e. if there are <span class="tt">n</span> cells of type <span class="tt">0</span> and <span class="tt">m</span> cells of type <span class="tt">1</span>, then cells of type <span class="tt">0</span> are numbered <span class="tt">0..(n-1)</span> and cells of type <span class="tt">1</span> are numbered <span class="tt">n..(n+m-1)</span> respectively, in the returned dual graph.</dd>
<dd>
Facet (2) and cell (4) data will contain multiple entries for the same facet for branching meshes with <span class="tt">max_facet_to_cell_links&gt;2</span> to account for all facet cell connectivies. </dd></dl>

</div>
</div>
<a id="aacd44e8136c15b9593dfdd87cd744c32" name="aacd44e8136c15b9593dfdd87cd744c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd44e8136c15b9593dfdd87cd744c32">&#9670;&#160;</a></span>cell_entity_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::array&lt; int, 2 &gt;, std::vector&lt; std::set&lt; int &gt; &gt; &gt; cell_entity_closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closure entities for a cell, i.e., all lower-dimensional entities attached to a cell entity. Map from entity {dim_e, entity_e} to closure{sub_dim, (sub_entities)} </p>

</div>
</div>
<a id="a66c376aedd08ad2dab6f13eba56b6f36" name="a66c376aedd08ad2dab6f13eba56b6f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c376aedd08ad2dab6f13eba56b6f36">&#9670;&#160;</a></span>cell_facet_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a> cell_facet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return facet type of cell For simplex and hypercube cell types, this is independent of the facet index, but for prism and pyramid, it can be triangle or quadrilateral. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The facet index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of facet for this cell at this index </dd></dl>

</div>
</div>
<a id="a67fa456882009e9a0025061837b40e55" name="a67fa456882009e9a0025061837b40e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fa456882009e9a0025061837b40e55">&#9670;&#160;</a></span>cell_normals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; cell_normals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute normal to given cell (viewed as embedded in 3D). </p>
<dl class="section return"><dt>Returns</dt><dd>The entity normals. The shape is <span class="tt">(entities.size(), 3)</span> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="abe2926fe64174120b2e865e0b7bf9946" name="abe2926fe64174120b2e865e0b7bf9946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2926fe64174120b2e865e0b7bf9946">&#9670;&#160;</a></span>cell_num_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cell_num_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entities of dimension dim </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Entity dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entities in cell </dd></dl>

</div>
</div>
<a id="a86452baf0d97bcbb8ffee0131c8338eb" name="a86452baf0d97bcbb8ffee0131c8338eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86452baf0d97bcbb8ffee0131c8338eb">&#9670;&#160;</a></span>compute_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt; compute_connectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>d0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connectivity (d0 -&gt; d1) for given pair of entity types, given by topological dimension and index, as found in <span class="tt"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#a84c162f215cf4619f2d4e112ff0eef00" title="Entity types in the topology for a given dimension.">Topology::entity_types()</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>Dimension and index of the entities, <span class="tt">(dim0, i)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>Dimension and index of the incident entities, <span class="tt">(dim1,
/ j)</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The connectivities [(d0 -&gt; d1), (d1 -&gt; d0)] if they are computed. If (d0, d1) already exists then a nullptr is returned. If (d0, d1) is computed and the computation of (d1, d0) was required as part of computing (d0, d1), the (d1, d0) is returned as the second entry. The second entry is otherwise nullptr. </dd></dl>

</div>
</div>
<a id="a9555ca279c1bd88d79220fcfdf9c019e" name="a9555ca279c1bd88d79220fcfdf9c019e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9555ca279c1bd88d79220fcfdf9c019e">&#9670;&#160;</a></span>compute_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt; compute_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>entity_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mesh entities of given topological dimension by computing cell-to-entity <span class="tt">(tdim, i) -&gt; </span>(dim, entity_type)<span class="tt"> and
/ entity-to-vertex connectivity </span>(dim, entity_type) -&gt; <span class="tt">(0, 0)</span> connectivity. </p>
<p>Computed entities are oriented such that their local (to the process) orientation agrees with their global orientation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension of the entities to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_type</td><td>Entity type in dimension <span class="tt">dim</span> to create. Entity type must be in the list returned by <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#a84c162f215cf4619f2d4e112ff0eef00" title="Entity types in the topology for a given dimension.">Topology::entity_types</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (cell-&gt;entity connectivity, entity-&gt;vertex connectivity, index map for created entities, list of interprocess entities). Interprocess entities lie on the "true" boundary between owned cells of each process. If entities of type <span class="tt">entity_type</span> already exists, then {nullptr, nullptr, nullptr, std::vector()} is returned. </dd></dl>

</div>
</div>
<a id="aeb806bcc85940ea4818196d210d7dff7" name="aeb806bcc85940ea4818196d210d7dff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb806bcc85940ea4818196d210d7dff7">&#9670;&#160;</a></span>compute_entity_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt; compute_entity_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute (1) facet rotation and reflection data, and (2) cell permutation data. This information is used in the assembly of (1) facet integrals and (2) most non-Lagrange elements.</p>
<ol type="1">
<li><p class="startli">The facet rotation and reflection data is encoded so that:</p><ul>
<li><span class="tt">n % 2</span> gives the number of reflections to apply</li>
<li><span class="tt">n // 2</span> gives the number of rotations to apply</li>
</ul>
<p class="startli">The data is stored in a flattened 2D array, so that <span class="tt">data[cell_index *
/    facets_per_cell + facet_index]</span> contains the facet with index <span class="tt">facet_index</span> of the cell with index <span class="tt">cell_index</span>. This data passed to FFCx kernels, where it is used to permute the quadrature points on facet integrals when data from the cells on both sides of the facet is used.</p>
</li>
<li><p class="startli">The cell permutation data contains information about the entities of each cell, relative to a low-to-high ordering. This data is packed so that a 32-bit int is used for each cell. For 2D cells, one bit is used for each edge, to represent whether or not the edge is reversed: the least significant bit is for edge 0, the next for edge 1, etc. For 3D cells, three bits are used for each face, and for each edge: the least significant bit says whether or not face 0 is reflected, the next 2 bits say how many times face 0 is rotated; the next three bits are for face 1, then three for face 2, etc; after all the faces, there is 1 bit for each edge to say whether or not they are reversed.</p>
<p class="startli">For example, if a quadrilateral has cell permutation info <span class="tt">....0111</span> then (from right to left):</p><ul>
<li>edge 0 is reflected (1)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is reflected (1)</li>
<li>edge 3 is not permuted (0)</li>
</ul>
<p class="startli">and if a tetrahedron has cell permutation info <span class="tt">....011010010101001000</span> then (from right to left):</p><ul>
<li>face 0 is not permuted (000)</li>
<li>face 1 is reflected (001)</li>
<li>face 2 is rotated twice then reflected (101)</li>
<li>face 3 is rotated once (010)</li>
<li>edge 0 is not permuted (0)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is not permuted (0)</li>
<li>edge 3 is reflected (1)</li>
<li>edge 4 is reflected (1)</li>
<li>edge 5 is not permuted (0)</li>
</ul>
<p class="startli">This data is used to correct the direction of vector function on permuted facets.</p>
</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Facet permutation and cells permutations </dd></dl>

</div>
</div>
<a id="abec76d69eb4bf33692781bc8995c9b5f" name="abec76d69eb4bf33692781bc8995c9b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec76d69eb4bf33692781bc8995c9b5f">&#9670;&#160;</a></span>compute_incident_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_incident_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute incident entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of indices of topological dimension <span class="tt">d0</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>Topological dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>Topological dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of entities of topological dimension <span class="tt">d1</span> that are incident to entities in <span class="tt">entities</span> (topological dimension <span class="tt">d0</span>). </dd></dl>

</div>
</div>
<a id="ad4dbbf93d4d231f00b543bf8cc9fece7" name="ad4dbbf93d4d231f00b543bf8cc9fece7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbbf93d4d231f00b543bf8cc9fece7">&#9670;&#160;</a></span>compute_midpoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; compute_midpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the midpoints for mesh entities of a given dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>The entity midpoints. The shape is <span class="tt">(entities.size(), 3)</span> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="ad451e1d60af5b31e3d8fc950f35ee31c" name="ad451e1d60af5b31e3d8fc950f35ee31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad451e1d60af5b31e3d8fc950f35ee31c">&#9670;&#160;</a></span>compute_mixed_cell_pairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::int32_t &gt; &gt; compute_mixed_cell_pairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a></td>          <td class="paramname"><span class="paramname"><em>facet_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a list of cell-cell connections for each possible combination in the topology which have the same connecting facet type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topology</td><td>A mesh topology </td></tr>
    <tr><td class="paramname">facet_type</td><td>Type of facet connection between cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list for each possible cell-cell connection, arranged in the ordering given by <span class="tt">cell_types()</span> in the topology. i.e. if the cell types are tet, prism, hex, and the facet_type is quadrilateral, then the lists returned are: tet-tet (empty), tet-prism (empty), tet-hex (empty), prism-tet (empty), prism-prism, prism-hex, hex-tet (empty), hex-prism, hex-hex. Note there are empty lists for the invalid cases, and also that there is currently redundant data, since the transpose is also computed, i.e. prism-hex as well as hex-prism. Each list contains a flattened array with data in the order (cell0, local facet0, cell1, local facet1) for each connection between cells. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All facet-cell connectivity and cell-facet connectivity must be computed beforehand in the topology. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000010">Todo</a></b></dt><dd>Remove redundant data. </dd></dl>

</div>
</div>
<a id="a9de66904187ae980935d3603d65e5e13" name="a9de66904187ae980935d3603d65e5e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de66904187ae980935d3603d65e5e13">&#9670;&#160;</a></span>create_boundary_vertices_fn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto create_boundary_vertices_fn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the default boundary vertices routine for a given reorder function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>A cell reorder funciton which will be applied to reorder the cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boundary vertices function which can be passed to <span class="tt">create_mesh</span>. TODO: offload to cpp? </dd></dl>
<p>brief Function that computes the process boundary vertices of a mesh during creation. param[in] celltypes List of celltypes in mesh. param[in] doflayouts List of DOF layouts in mesh. param[in] ghost_owners List of ghost owner per cell per celltype. param[out] cells List of cells per celltpye. Reorderd during call. param[out] cells_v List of vertices (no higher order nodes) of cell per celltype. Reordered during call. param[out] original_idx Contains the permutation applied to the cells per celltype. return Boundary vetices (for all cell types).</p>

</div>
</div>
<a id="a72443a6c92cbec1609f371cb02b9f0d1" name="a72443a6c92cbec1609f371cb02b9f0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72443a6c92cbec1609f371cb02b9f0d1">&#9670;&#160;</a></span>create_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_box </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>subcomm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <span class="tt">p</span>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <span class="tt">(n[0] +
/ 1)*(n[1] + 1)*(n[2] + 1)</span>. For tetrahedra there will be will be <span class="tt">6*n[0]*n[1]*n[2]</span> cells. For hexahedra the number of cells will be <span class="tt">n[0]*n[1]*n[2]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to distribute the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subcomm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to construct and partition the mesh topology on. If the process should not be involved in the topology creation and partitioning then this communicator should be <span class="tt">MPI_COMM_NULL</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Corner of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for (locally) reordering cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a0380a96c220af888dca75b52089a220c" name="a0380a96c220af888dca75b52089a220c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0380a96c220af888dca75b52089a220c">&#9670;&#160;</a></span>create_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_box </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <span class="tt">p</span>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <span class="tt">(n[0] +
/ 1)*(n[1] + 1)*(n[2] + 1)</span>. For tetrahedra there will be will be <span class="tt">6*n[0]*n[1]*n[2]</span> cells. For hexahedra the number of cells will be <span class="tt">n[0]*n[1]*n[2]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to distribute the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Corner of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for (locally) reordering cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="aff22d3fa3023edcd8cdd5d8550b19484" name="aff22d3fa3023edcd8cdd5d8550b19484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff22d3fa3023edcd8cdd5d8550b19484">&#9670;&#160;</a></span>create_cell_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">mesh::CellPartitionFunction</a> create_cell_partitioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">mesh::GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mesh::GhostMode::none</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#aa2e8bbea5ac3a27249e3155bc455f887">graph::partition_fn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partfn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function that computes destination rank for mesh cells on this rank by applying the default graph partitioner to the dual graph of the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Function that computes the destination ranks for each cell. </dd></dl>

</div>
</div>
<a id="a9f1a204290ebf7fa49bf222e542fe36f" name="a9f1a204290ebf7fa49bf222e542fe36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1a204290ebf7fa49bf222e542fe36f">&#9670;&#160;</a></span>create_geometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>xdofs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data. </p>
<p>This function should be called after the mesh topology is built and 'node' coordinate data has been distributed to the processes where it is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>List of elements that defines the geometry map for each cell type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> node global indices for cells on this process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be sorted. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xdofs</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> degree-of-freedom map (using global indices) for cells on this process. <span class="tt">nodes</span> is a sorted and unique list of the indices in <span class="tt">xdofs</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The node coordinates (row-major, with shape <span class="tt">(num_nodes, dim)</span>. The global index of each node is <span class="tt">i +
/ rank_offset</span>, where <span class="tt">i</span> is the local row index in <span class="tt">x</span> and <span class="tt">rank_offset</span> is the sum of <span class="tt">x</span> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Geometric dimension (1, 2, or 3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for re-ordering the degree-of-freedom map associated with the geometry data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Experimental new interface for multiple cmap/dofmap </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh geometry. </dd></dl>

</div>
</div>
<a id="ac1a1f8d09938c720131fa7a5f229568e" name="ac1a1f8d09938c720131fa7a5f229568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a1f8d09938c720131fa7a5f229568e">&#9670;&#160;</a></span>create_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_interval </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">mesh::GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mesh::GhostMode::none</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval mesh of the 1D line <span class="tt">[a, b]</span>. </p>
<p>Given <span class="tt">n</span> cells in the axial direction, the total number of intervals will be <span class="tt">n</span> and the total number of vertices will be <span class="tt">n + 1</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>End points of the interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>ghost mode of the created mesh, defaults to none </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for (locally) reordering cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh. </dd></dl>

</div>
</div>
<a id="a21548d376331e4a8cb443b7cdbceeb22" name="a21548d376331e4a8cb443b7cdbceeb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21548d376331e4a8cb443b7cdbceeb22">&#9670;&#160;</a></span>create_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mesh with a single cell type from mesh data and using a provided graph partitioning function for determining the parallel distribution of the mesh. </p>
<p>From mesh input data that is distributed across processes, a distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> is created. If the partitioning function is not callable, i.e. it does not store a callable function, no re-distribution of cells is done.</p>
<p>This constructor provides a simplified interface to the more general <a class="el" href="#ae172f8e7a0ae9871f969d8d9f861bbf7" title="Create a distributed mesh::Mesh from mesh data and using the provided graph partitioning function for...">create_mesh</a> constructor, which supports meshes with more than one cell type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commt</td><td>Communicator that the topology data (<span class="tt">cells</span>) is distributed on. This should be <span class="tt">MPI_COMM_NULL</span> for ranks that should not participate in computing the topology partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on the calling process. Each cell (node in the <span class="tt">AdjacencyList</span>) is defined by its 'nodes' (using global indices) following the Basix ordering. For lowest order cells this will be just the cell vertices. For higher-order cells, other cells 'nodes' will be included. See <a class="el" href="../../df/dcf/namespacedolfinx_1_1io_1_1cells.html" title="Functions for the re-ordering of input mesh topology to the DOLFINx ordering, and transpose orderings...">dolfinx::io::cells</a> for examples of the Basix ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Coordinate element for the cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commg</td><td>Communicator for geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). Row-major storage. The global index of the <span class="tt">i</span>th node (row) in <span class="tt">x</span> is taken as <span class="tt">i</span> plus the process offset on<span class="tt">comm</span>, The offset is the sum of <span class="tt">x</span> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>Shape of the <span class="tt">x</span> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Graph partitioner that computes the owning rank for each cell. If not callable, cells are not redistributed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function that reorders (locally) cells that are owned by this process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <span class="tt">comm</span>. </dd></dl>

</div>
</div>
<a id="ae172f8e7a0ae9871f969d8d9f861bbf7" name="ae172f8e7a0ae9871f969d8d9f861bbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172f8e7a0ae9871f969d8d9f861bbf7">&#9670;&#160;</a></span>create_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const std::int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> from mesh data and using the provided graph partitioning function for determining the parallel distribution of the mesh. </p>
<p>The input cells and geometry data can be distributed across the calling ranks, but must be not duplicated across ranks.</p>
<p>The function <span class="tt">partitioner</span> computes the parallel distribution, i.e. the destination rank for each cell passed to the constructor. If <span class="tt">partitioner</span> is not callable, i.e. it does not store a callable function, no parallel re-distribution of cells is performed.</p>
<dl class="section note"><dt>Note</dt><dd>Collective.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commt</td><td>Communicator that the topology data (<span class="tt">cells</span>) is distributed on. This should be <span class="tt">MPI_COMM_NULL</span> for ranks that should not participate in computing the topology partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells, grouped by cell type with <span class="tt">cells[i]</span> being the cells of the same type. Cells are defined by their 'nodes' (using global indices) following the Basix ordering, and for each cell type concatenated to form a flattened list. For lowest-order cells this will be just the cell vertices. For higher-order geometry cells, other cell 'nodes' will be included. See <a class="el" href="../../df/dcf/namespacedolfinx_1_1io_1_1cells.html" title="Functions for the re-ordering of input mesh topology to the DOLFINx ordering, and transpose orderings...">io::cells</a> for examples of the Basix ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Coordinate elements for the cells, where <span class="tt">elements[i]</span> is the coordinate element for the cells in <span class="tt">cells[i]</span>. <b>The list of elements must be the same on all calling parallel ranks.</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commg</td><td>Communicator for geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). Row-major storage. The global index of the <span class="tt">i</span>th node (row) in <span class="tt">x</span> is taken as <span class="tt">i</span> plus the parallel rank offset (on <span class="tt">comm</span>), where the offset is the sum of <span class="tt">x</span> rows on all lower ranks than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>Shape of the <span class="tt">x</span> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Graph partitioner that computes the owning rank for each cell in <span class="tt">cells</span>. If not callable, cells are not redistributed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function that reorders (locally) cells that are owned by this process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <span class="tt">comm</span>. </dd></dl>

</div>
</div>
<a id="ada3471710d7fca68f819993efab03d81" name="ada3471710d7fca68f819993efab03d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3471710d7fca68f819993efab03d81">&#9670;&#160;</a></span>create_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aea1d3aae687d7fb2b510fd12026ecd4e">GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mesh from mesh data using the default graph partitioner to determine the parallel distribution of the mesh. </p>
<p>This function takes mesh input data that is distributed across processes and creates a <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a>, with the mesh cell distribution determined by the default cell partitioner. The default partitioner is based on graph partitioning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on the calling process. See <a class="el" href="#ae172f8e7a0ae9871f969d8d9f861bbf7" title="Create a distributed mesh::Mesh from mesh data and using the provided graph partitioning function for...">create_mesh</a> for a detailed description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Coordinate elements for the cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). See <a class="el" href="#ae172f8e7a0ae9871f969d8d9f861bbf7" title="Create a distributed mesh::Mesh from mesh data and using the provided graph partitioning function for...">create_mesh</a> for a detailed description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>Shape of <span class="tt">x</span>. It should be <span class="tt">(num_points, gdim)</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>Required type of cell ghosting/overlap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <span class="tt">comm</span>. </dd></dl>

</div>
</div>
<a id="a2bdcd9e9469ae3185e6ca6a3ee3fa581" name="a2bdcd9e9469ae3185e6ca6a3ee3fa581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdcd9e9469ae3185e6ca6a3ee3fa581">&#9670;&#160;</a></span>create_meshtags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt; T &gt; create_meshtags </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> from arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology that the tags are associated with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of tagged entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Local vertex indices for tagged entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Tag values for each entity in <span class="tt">entities</span>. The length of <span class="tt">values</span> must be equal to number of rows in <span class="tt">entities</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entities that do not exist on this rank are ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="tt">entities</span> must not contain duplicate entities. </dd></dl>

</div>
</div>
<a id="a039ebe1f5145c2083a2296563b172605" name="a039ebe1f5145c2083a2296563b172605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039ebe1f5145c2083a2296563b172605">&#9670;&#160;</a></span>create_rectangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a></td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DiagonalType::right</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ae04a49cad2b0638dbc083a221f2279">CellReorderFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a37b611787453853f724b8972b6e2a851">graph::reorder_gps</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <span class="tt">p</span>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <span class="tt">(n[0] +
/ 1)*(n[1] + 1)</span>. For triangles there will be will be <span class="tt">2*n[0]*n[1]</span> cells. For quadrilaterals the number of cells will be <span class="tt">n[0]*n[1]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Bottom-left and top-right corners of the rectangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for (locally) reordering cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a327c492002b54befefb2077e4b5f861c" name="a327c492002b54befefb2077e4b5f861c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c492002b54befefb2077e4b5f861c">&#9670;&#160;</a></span>create_rectangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a></td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DiagonalType::right</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <span class="tt">p</span>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <span class="tt">(n[0] +
/ 1)*(n[1] + 1)</span>. For triangles there will be will be <span class="tt">2*n[0]*n[1]</span> cells. For quadrilaterals the number of cells will be <span class="tt">n[0]*n[1]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Two corner points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a8e805f1f5252c2cc4c88a00ad6393025" name="a8e805f1f5252c2cc4c88a00ad6393025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e805f1f5252c2cc4c88a00ad6393025">&#9670;&#160;</a></span>create_subgeometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; T &gt;, std::vector&lt; int32_t &gt; &gt; create_subgeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>subentity_to_entity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sub-geometry from a mesh and a subset of mesh entities to be included. </p>
<p>A sub-geometry is simply a <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">mesh::Geometry</a> object containing only the geometric information for the subset of entities. The entities may differ in topological dimension from the original mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The full mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the sub-topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subentity_to_entity</td><td>Map from sub-topology entity to the entity in the parent topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sub-geometry and a map from sub-geometry coordinate degree-of-freedom to the coordinate degree-of-freedom in <span class="tt">geometry</span>. </dd></dl>

</div>
</div>
<a id="a6ba043a7e771c657a95b435c70dc1395" name="a6ba043a7e771c657a95b435c70dc1395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba043a7e771c657a95b435c70dc1395">&#9670;&#160;</a></span>create_submesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;, <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">EntityMap</a>, <a class="el" href="../../df/d2e/classdolfinx_1_1mesh_1_1EntityMap.html">EntityMap</a>, std::vector&lt; std::int32_t &gt; &gt; create_submesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new mesh consisting of a subset of entities in a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension entities in <span class="tt">mesh</span> that will be cells in the sub-mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of entities in <span class="tt">mesh</span> to include in the sub-mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new mesh, and maps from the new mesh entities, vertices, and geometry to the input mesh entities, vertices, and geometry. </dd></dl>

</div>
</div>
<a id="a6af09e67e8db0d211e9b00393cf9f5ae" name="a6af09e67e8db0d211e9b00393cf9f5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af09e67e8db0d211e9b00393cf9f5ae">&#9670;&#160;</a></span>create_subtopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>, std::vector&lt; int32_t &gt;, std::vector&lt; int32_t &gt; &gt; create_subtopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a topology for a subset of entities of a given topological dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>Original (parent) topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities in the new topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of entities in <span class="tt">topology</span> to include in the new topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New topology of dimension <span class="tt">dim</span> with all entities in <span class="tt">entities</span>, map from entities of dimension <span class="tt">dim</span> in new sub-topology to entities in <span class="tt">topology</span>, and map from vertices in new sub-topology to vertices in <span class="tt">topology</span>. </dd></dl>

</div>
</div>
<a id="a3f0323e28305c7aa394d8ecbfeb905c6" name="a3f0323e28305c7aa394d8ecbfeb905c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0323e28305c7aa394d8ecbfeb905c6">&#9670;&#160;</a></span>create_topology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> create_topology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const std::int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const std::int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>original_cell_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>ghost_owners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_vertices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mesh topology. </p>
<p>This function creates a <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html" title="Topology stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relat...">Topology</a> from cells that have been already distributed to the processes that own or ghost the cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator across which the topology will be distributed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_types</td><td>List of cell types in the topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cell topology (list of vertices for each cell) for each cell type using global indices for the vertices. The cell type for <span class="tt">cells[i]</span> is <span class="tt">cell_types[i]</span>, using row-major storage and where the row <span class="tt">cells[i][j]</span> is the vertices for cell <span class="tt">j</span> of cell type <span class="tt">i</span>. Each <span class="tt">cells[i]</span> contains cells that have been distributed to this rank, e.g. via a graph partitioner. It must also contain all ghost cells via facet, i.e. cells that are on a neighboring process and which share a facet with a local cell. Ghost cells are the last <span class="tt">n</span> entries in <span class="tt">cells[i]</span>, where <span class="tt">n</span> is given by the length of <span class="tt">ghost_owners[i]</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_cell_index</td><td>Input cell index for each cell type, e.g. the cell index in an input file. This index remains associated with the cell after any re-ordering and parallel (re)distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_owners</td><td>Owning rank for ghost cells (ghost cells are at end of each list of cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_vertices</td><td>Vertices on the 'exterior' (boundary) of the local topology. These vertices might appear on other processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distributed mesh topology. </dd></dl>

</div>
</div>
<a id="a332133c6fd59b509e8a60420ba7bc67b" name="a332133c6fd59b509e8a60420ba7bc67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332133c6fd59b509e8a60420ba7bc67b">&#9670;&#160;</a></span>create_topology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> create_topology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>original_cell_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>ghost_owners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_vertices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mesh topology for a single cell type. </p>
<p>This function provides a simplified interface to <a class="el" href="#a3f0323e28305c7aa394d8ecbfeb905c6" title="Create a mesh topology.">create_topology</a> for the case that a mesh has one cell type only,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator across which the topology will be distributed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cell topology (list of vertices for each cell) using global indices for the vertices. It contains cells that have been distributed to this rank, e.g. via a graph partitioner. It must also contain all ghost cells via facet, i.e. cells that are on a neighboring process and which share a facet with a local cell. Ghost cells are the last <span class="tt">n</span> entries in <span class="tt">cells</span>, where <span class="tt">n</span> is given by the length of <span class="tt">ghost_owners</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_cell_index</td><td>Original global index associated with each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_owners</td><td>Owning rank of each ghost cell (ghost cells are always at the end of the list of <span class="tt">cells</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>A vector with cell shapes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_vertices</td><td>Vertices on the 'exterior' (boundary) of the local topology. These vertices might appear on other processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distributed mesh topology. </dd></dl>

</div>
</div>
<a id="ab28a78ae146e601321bd3f1235842e02" name="ab28a78ae146e601321bd3f1235842e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28a78ae146e601321bd3f1235842e02">&#9670;&#160;</a></span>entities_to_geometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::int32_t &gt;, std::array&lt; std::size_t, 2 &gt; &gt; entities_to_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>permute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the geometry degrees of freedom associated with the closure of a given set of cell entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Entity indices (local to process). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permute</td><td>If <span class="tt">true</span>, permute the DOFs such that they are consistent with the orientation of <span class="tt">dim</span>-dimensional mesh entities. This requires <span class="tt">create_entity_permutations</span> to be called first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> DOFs associated with the closure of each entity in <span class="tt">entities</span> and the shape. The shape is <span class="tt">(num_entities,
/ num_xdofs_per_entity)</span> and the storage is row-major. The index <span class="tt">indices[i, j]</span> is the position in the geometry array of the <span class="tt">j</span>-th vertex of the <span class="tt">entity[i]</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> connectivities <span class="tt">dim -&gt; mesh.topology().dim()</span> and <span class="tt">mesh.topology().dim() -&gt; dim</span> must have been computed. Otherwise an exception is thrown. </dd></dl>

</div>
</div>
<a id="af81ae5994989c886b804b3f6b64275fd" name="af81ae5994989c886b804b3f6b64275fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ae5994989c886b804b3f6b64275fd">&#9670;&#160;</a></span>entities_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; entities_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get entity indices for entities defined by their vertices. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function may be removed in the future.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> entities defined by their vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the ith entity in <span class="tt">entities</span>, If an entity cannot be found on this rank, -1 is returned as the index. </dd></dl>

</div>
</div>
<a id="abcd805c0f4a1ee1533a6b05417ddcaa1" name="abcd805c0f4a1ee1533a6b05417ddcaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd805c0f4a1ee1533a6b05417ddcaa1">&#9670;&#160;</a></span>exterior_facet_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; exterior_facet_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indices of all exterior facets that are owned by the caller. </p>
<p>An exterior facet (co-dimension 1) is one that is connected globally to only one cell of co-dimension 0).</p>
<dl class="section note"><dt>Note</dt><dd>Collective.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted list of owned facet indices that are exterior facets of the mesh. </dd></dl>

</div>
</div>
<a id="a7f25ea9250efb80e92fa44d379f3afa4" name="a7f25ea9250efb80e92fa44d379f3afa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f25ea9250efb80e92fa44d379f3afa4">&#9670;&#160;</a></span>exterior_facet_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; exterior_facet_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet_type_idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indices of all exterior facets that are owned by the caller. </p>
<p>An exterior facet (co-dimension 1) is one that is connected globally to only one cell of co-dimension 0).</p>
<dl class="section note"><dt>Note</dt><dd>Collective.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_type_idx</td><td>The index of the facet type in Topology::entity_types(facet_dim) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted list of owned facet indices that are exterior facets of the mesh. </dd></dl>

</div>
</div>
<a id="ac0d9b5cca14603833020dfa05d886207" name="ac0d9b5cca14603833020dfa05d886207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d9b5cca14603833020dfa05d886207">&#9670;&#160;</a></span>extract_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int64_t &gt; extract_topology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract topology from cell data, i.e. extract cell vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Layout of geometry 'degrees-of-freedom' on the reference cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>List of 'nodes' for each cell using global indices. The layout must be consistent with <span class="tt">layout</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell topology. The global indices will, in general, have 'gaps' due to mid-side and other higher-order nodes being removed from the input <span class="tt">cell</span>. </dd></dl>

</div>
</div>
<a id="a928c84854cdb3701ae7410d2f2c1a913" name="a928c84854cdb3701ae7410d2f2c1a913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928c84854cdb3701ae7410d2f2c1a913">&#9670;&#160;</a></span>get_entity_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt; get_entity_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return list of entities, where entities(e, k) is the local vertex index for the kth vertex of entity e of dimension dim </p>

</div>
</div>
<a id="afec08aa43ab0e757eca314632a5b5c1b" name="afec08aa43ab0e757eca314632a5b5c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec08aa43ab0e757eca314632a5b5c1b">&#9670;&#160;</a></span>get_sub_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt; get_sub_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get entities of dimension dim1 and that make up entities of dimension dim0 </p>

</div>
</div>
<a id="a8294c20389ab1f3b4c5b70eaa6f1dc00" name="a8294c20389ab1f3b4c5b70eaa6f1dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8294c20389ab1f3b4c5b70eaa6f1dc00">&#9670;&#160;</a></span>h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute greatest distance between any two vertices of the mesh entities (<span class="tt">h</span>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> that the entities belong to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices (local to process) of entities to compute <span class="tt">h</span> for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest distance between any two vertices, <span class="tt">h[i]</span> corresponds to the entity <span class="tt">entities[i]</span>. </dd></dl>

</div>
</div>
<a id="ac88526e97d1edbaacb8471c0e9288a03" name="ac88526e97d1edbaacb8471c0e9288a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88526e97d1edbaacb8471c0e9288a03">&#9670;&#160;</a></span>is_simplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if cell is a simplex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is the cell type is a simplex </dd></dl>

</div>
</div>
<a id="ab344919e038891a57c7a943cc5a420ee" name="ab344919e038891a57c7a943cc5a420ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab344919e038891a57c7a943cc5a420ee">&#9670;&#160;</a></span>locate_entities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that evaluate to true for the provided geometric marking function. </p>
<p>An entity is considered marked if the marker function evaluates to true for all of its vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> to mark entities on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>Marking function, returns <span class="tt">true</span> for a point that is 'marked', and <span class="tt">false</span> otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices, including any ghost indices (indices local to the process). </dd></dl>

</div>
</div>
<a id="ac50e2b6669877ea08fd2743981d3b907" name="ac50e2b6669877ea08fd2743981d3b907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50e2b6669877ea08fd2743981d3b907">&#9670;&#160;</a></span>locate_entities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>entity_type_idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that evaluate to true for the provided geometric marking function. </p>
<p>An entity is considered marked if the marker function evaluates to true for all of its vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> to mark entities on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>Marking function, returns <span class="tt">true</span> for a point that is 'marked', and <span class="tt">false</span> otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entity_type_idx</td><td>The index of the entity type in Topology::entity_types(dim) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices, including any ghost indices (indices local to the process). </dd></dl>

</div>
</div>
<a id="a7f4773c26421814d452b07150df4ece8" name="a7f4773c26421814d452b07150df4ece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4773c26421814d452b07150df4ece8">&#9670;&#160;</a></span>locate_entities_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function. </p>
<p>An entity is considered marked if the marker function evaluates to true for all of its vertices.</p>
<dl class="section note"><dt>Note</dt><dd>For vertices and edges, in parallel this function will not necessarily mark all entities that are on the exterior boundary. For example, it is possible for a process to have a vertex that lies on the boundary without any of the attached facets being a boundary facet. When used to find degrees-of-freedom, e.g. using <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a84cd6568b465fbe013715ad3d70190cb" title="Find degrees-of-freedom which belong to the provided mesh entities (topological).">fem::locate_dofs_topological</a>, the function that uses the data returned by this function must typically perform some parallel communication.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> to mark entities on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities to be considered. Must be less than the topological dimension of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>Marking function, returns <span class="tt">true</span> for a point that is 'marked', and <span class="tt">false</span> otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices (indices local to the process). </dd></dl>

</div>
</div>
<a id="a80294da14ab051e9f8eaf72080a7ee17" name="a80294da14ab051e9f8eaf72080a7ee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80294da14ab051e9f8eaf72080a7ee17">&#9670;&#160;</a></span>num_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_cell_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number vertices for a cell type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of cell vertices </dd></dl>

</div>
</div>
<a id="ae1f0961be83abe152e146c14c8f8548a" name="ae1f0961be83abe152e146c14c8f8548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0961be83abe152e146c14c8f8548a">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the cell string type for a cell type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type string </dd></dl>

</div>
</div>
<a id="aec82a925447a9da2a086b7c93739ba9c" name="aec82a925447a9da2a086b7c93739ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec82a925447a9da2a086b7c93739ba9c">&#9670;&#160;</a></span>to_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7ff1deb71d3bfcd4e6b2426a59bbfde0">mesh::CellType</a> to_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the cell type from a cell string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>Cell shape string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::mesh Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.10.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html">mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::mesh Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> stores the geometry imposed on a mesh.  <a href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> consists of a set of connected and numbered mesh topological entities, and geometry data.  <a href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> associate values with mesh topology entities.  <a href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html" title="Topology stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relat...">Topology</a> stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relations for the mesh entities).  <a href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7b/conceptdolfinx_1_1mesh_1_1MarkerFn.html">MarkerFn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requirements on function for geometry marking. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acab22e3b5c8ac14664c8cd8e6f53fb70" id="r_acab22e3b5c8ac14664c8cd8e6f53fb70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td></tr>
<tr class="memdesc:acab22e3b5c8ac14664c8cd8e6f53fb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the cell partitioning function. The function should compute the destination rank for cells currently on this rank.  <br /></td></tr>
<tr class="separator:acab22e3b5c8ac14664c8cd8e6f53fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac3c2cbbef08f3b7ddc3b06c6bd5a2271" id="r_ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="memItemLeft" align="right" valign="top"><a id="ac3c2cbbef08f3b7ddc3b06c6bd5a2271" name="ac3c2cbbef08f3b7ddc3b06c6bd5a2271"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> : int { <br />
&#160;&#160;<b>point</b> = 1
, <b>interval</b> = 2
, <b>triangle</b> = 3
, <b>tetrahedron</b> = 4
, <br />
&#160;&#160;<b>quadrilateral</b> = -4
, <b>pyramid</b> = -5
, <b>prism</b> = -6
, <b>hexahedron</b> = -8
<br />
 }</td></tr>
<tr class="memdesc:ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell type identifier. <br /></td></tr>
<tr class="separator:ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0494804cb9b4baeeff5b9027a8dfd" id="r_a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="memItemLeft" align="right" valign="top"><a id="a5fb0494804cb9b4baeeff5b9027a8dfd" name="a5fb0494804cb9b4baeeff5b9027a8dfd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> { <br />
&#160;&#160;<b>left</b>
, <b>right</b>
, <b>crossed</b>
, <b>shared_facet</b>
, <br />
&#160;&#160;<b>left_right</b>
, <b>right_left</b>
<br />
 }</td></tr>
<tr class="memdesc:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different diagonal types. <br /></td></tr>
<tr class="separator:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d109d131f3180f43267fcf9fe9c4c4" id="r_a38d109d131f3180f43267fcf9fe9c4c4"><td class="memItemLeft" align="right" valign="top"><a id="a38d109d131f3180f43267fcf9fe9c4c4" name="a38d109d131f3180f43267fcf9fe9c4c4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">GhostMode</a> : int { <b>none</b>
, <b>shared_facet</b>
, <b>shared_vertex</b>
 }</td></tr>
<tr class="memdesc:a38d109d131f3180f43267fcf9fe9c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different partitioning ghost modes. <br /></td></tr>
<tr class="separator:a38d109d131f3180f43267fcf9fe9c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1f0961be83abe152e146c14c8f8548a" id="r_ae1f0961be83abe152e146c14c8f8548a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1f0961be83abe152e146c14c8f8548a">to_string</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="separator:ae1f0961be83abe152e146c14c8f8548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec82a925447a9da2a086b7c93739ba9c" id="r_aec82a925447a9da2a086b7c93739ba9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec82a925447a9da2a086b7c93739ba9c">to_type</a> (const std::string &amp;cell)</td></tr>
<tr class="separator:aec82a925447a9da2a086b7c93739ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abcbdca3e3aae2fe00ad6ea7186cb0c" id="r_a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="memItemLeft" align="right" valign="top"><a id="a6abcbdca3e3aae2fe00ad6ea7186cb0c" name="a6abcbdca3e3aae2fe00ad6ea7186cb0c"></a>
<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_entity_type</b> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int d, int index)</td></tr>
<tr class="memdesc:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of cell for entity of dimension d at given entity index. <br /></td></tr>
<tr class="separator:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c376aedd08ad2dab6f13eba56b6f36" id="r_a66c376aedd08ad2dab6f13eba56b6f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66c376aedd08ad2dab6f13eba56b6f36">cell_facet_type</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int index)</td></tr>
<tr class="separator:a66c376aedd08ad2dab6f13eba56b6f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928c84854cdb3701ae7410d2f2c1a913" id="r_a928c84854cdb3701ae7410d2f2c1a913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928c84854cdb3701ae7410d2f2c1a913">get_entity_vertices</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim)</td></tr>
<tr class="separator:a928c84854cdb3701ae7410d2f2c1a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec08aa43ab0e757eca314632a5b5c1b" id="r_afec08aa43ab0e757eca314632a5b5c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec08aa43ab0e757eca314632a5b5c1b">get_sub_entities</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim0, int dim1)</td></tr>
<tr class="separator:afec08aa43ab0e757eca314632a5b5c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6984abad1707caa0c97b4e4b167106b3" id="r_a6984abad1707caa0c97b4e4b167106b3"><td class="memItemLeft" align="right" valign="top"><a id="a6984abad1707caa0c97b4e4b167106b3" name="a6984abad1707caa0c97b4e4b167106b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cell_dim</b> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="memdesc:a6984abad1707caa0c97b4e4b167106b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return topological dimension of cell type. <br /></td></tr>
<tr class="separator:a6984abad1707caa0c97b4e4b167106b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2926fe64174120b2e865e0b7bf9946" id="r_abe2926fe64174120b2e865e0b7bf9946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe2926fe64174120b2e865e0b7bf9946">cell_num_entities</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim)</td></tr>
<tr class="separator:abe2926fe64174120b2e865e0b7bf9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88526e97d1edbaacb8471c0e9288a03" id="r_ac88526e97d1edbaacb8471c0e9288a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac88526e97d1edbaacb8471c0e9288a03">is_simplex</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="separator:ac88526e97d1edbaacb8471c0e9288a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80294da14ab051e9f8eaf72080a7ee17" id="r_a80294da14ab051e9f8eaf72080a7ee17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80294da14ab051e9f8eaf72080a7ee17">num_cell_vertices</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="separator:a80294da14ab051e9f8eaf72080a7ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd44e8136c15b9593dfdd87cd744c32" id="r_aacd44e8136c15b9593dfdd87cd744c32"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::array&lt; int, 2 &gt;, std::vector&lt; std::set&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd44e8136c15b9593dfdd87cd744c32">cell_entity_closure</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> cell_type)</td></tr>
<tr class="separator:aacd44e8136c15b9593dfdd87cd744c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44a1bbf3077eacea89cf5f62c24fe68" id="r_aa44a1bbf3077eacea89cf5f62c24fe68"><td class="memItemLeft" align="right" valign="top"><a id="aa44a1bbf3077eacea89cf5f62c24fe68" name="aa44a1bbf3077eacea89cf5f62c24fe68"></a>
basix::cell::type&#160;</td><td class="memItemRight" valign="bottom"><b>cell_type_to_basix_type</b> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype)</td></tr>
<tr class="memdesc:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cell type to a Basix cell type. <br /></td></tr>
<tr class="separator:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c079ec392bf6c24c4879a67f53f4af8" id="r_a6c079ec392bf6c24c4879a67f53f4af8"><td class="memItemLeft" align="right" valign="top"><a id="a6c079ec392bf6c24c4879a67f53f4af8" name="a6c079ec392bf6c24c4879a67f53f4af8"></a>
<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_type_from_basix_type</b> (basix::cell::type celltype)</td></tr>
<tr class="memdesc:a6c079ec392bf6c24c4879a67f53f4af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cell type from a Basix cell type. <br /></td></tr>
<tr class="separator:a6c079ec392bf6c24c4879a67f53f4af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33474c393dedcbd953593f52e6188296" id="r_a33474c393dedcbd953593f52e6188296"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a33474c393dedcbd953593f52e6188296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33474c393dedcbd953593f52e6188296">create_box</a> (MPI_Comm comm, MPI_Comm subcomm, std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 3 &gt; n, <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner=nullptr)</td></tr>
<tr class="memdesc:a33474c393dedcbd953593f52e6188296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <code>p</code>.  <br /></td></tr>
<tr class="separator:a33474c393dedcbd953593f52e6188296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb4517e0694412cafd31bde307baed9" id="r_a8cb4517e0694412cafd31bde307baed9"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a8cb4517e0694412cafd31bde307baed9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8cb4517e0694412cafd31bde307baed9">create_box</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 3 &gt; n, <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner=nullptr)</td></tr>
<tr class="memdesc:a8cb4517e0694412cafd31bde307baed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <code>p</code>.  <br /></td></tr>
<tr class="separator:a8cb4517e0694412cafd31bde307baed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf31dd1565b3df8ce4f0f180e68965a9" id="r_aaf31dd1565b3df8ce4f0f180e68965a9"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:aaf31dd1565b3df8ce4f0f180e68965a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf31dd1565b3df8ce4f0f180e68965a9">create_rectangle</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 2 &gt; n, <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner, <a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right)</td></tr>
<tr class="memdesc:aaf31dd1565b3df8ce4f0f180e68965a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>.  <br /></td></tr>
<tr class="separator:aaf31dd1565b3df8ce4f0f180e68965a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c492002b54befefb2077e4b5f861c" id="r_a327c492002b54befefb2077e4b5f861c"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:a327c492002b54befefb2077e4b5f861c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a327c492002b54befefb2077e4b5f861c">create_rectangle</a> (MPI_Comm comm, std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt; p, std::array&lt; std::int64_t, 2 &gt; n, <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, <a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right)</td></tr>
<tr class="memdesc:a327c492002b54befefb2077e4b5f861c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>.  <br /></td></tr>
<tr class="separator:a327c492002b54befefb2077e4b5f861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafdc3673f5b50c40ec814e8f47d0bf8" id="r_abafdc3673f5b50c40ec814e8f47d0bf8"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = double&gt; </td></tr>
<tr class="memitem:abafdc3673f5b50c40ec814e8f47d0bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abafdc3673f5b50c40ec814e8f47d0bf8">create_interval</a> (MPI_Comm comm, std::int64_t n, std::array&lt; T, 2 &gt; p, <a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a> ghost_mode=mesh::GhostMode::none, <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> partitioner=nullptr)</td></tr>
<tr class="memdesc:abafdc3673f5b50c40ec814e8f47d0bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval mesh of the 1D line <code>[a, b]</code>.  <br /></td></tr>
<tr class="separator:abafdc3673f5b50c40ec814e8f47d0bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517d9b85ae3658d28f603f29116130a" id="r_a4517d9b85ae3658d28f603f29116130a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4517d9b85ae3658d28f603f29116130a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4517d9b85ae3658d28f603f29116130a">create_geometry</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;elements, std::span&lt; const std::int64_t &gt; nodes, std::span&lt; const std::int64_t &gt; xdofs, const U &amp;x, int dim, std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a4517d9b85ae3658d28f603f29116130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data.  <br /></td></tr>
<tr class="separator:a4517d9b85ae3658d28f603f29116130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b4223a067001f49af0dca0c47ac340" id="r_a51b4223a067001f49af0dca0c47ac340"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a51b4223a067001f49af0dca0c47ac340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51b4223a067001f49af0dca0c47ac340">create_geometry</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;element, std::span&lt; const std::int64_t &gt; nodes, std::span&lt; const std::int64_t &gt; xdofs, const U &amp;x, int dim, std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a51b4223a067001f49af0dca0c47ac340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data.  <br /></td></tr>
<tr class="separator:a51b4223a067001f49af0dca0c47ac340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5c2d292165f0f24be6db01db324529" id="r_aab5c2d292165f0f24be6db01db324529"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab5c2d292165f0f24be6db01db324529">build_local_dual_graph</a> (std::span&lt; const <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt; celltypes, const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;cells)</td></tr>
<tr class="memdesc:aab5c2d292165f0f24be6db01db324529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the local part of the dual graph (cell-cell connections via facets) and facets with only one attached cell.  <br /></td></tr>
<tr class="separator:aab5c2d292165f0f24be6db01db324529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ecab159304e7a6c7146533196aca6f" id="r_ac4ecab159304e7a6c7146533196aca6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4ecab159304e7a6c7146533196aca6f">build_dual_graph</a> (MPI_Comm comm, std::span&lt; const <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt; celltypes, const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;cells)</td></tr>
<tr class="memdesc:ac4ecab159304e7a6c7146533196aca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data.  <br /></td></tr>
<tr class="separator:ac4ecab159304e7a6c7146533196aca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdcd9e9469ae3185e6ca6a3ee3fa581" id="r_a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2bdcd9e9469ae3185e6ca6a3ee3fa581">create_meshtags</a> (std::shared_ptr&lt; const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &gt; topology, int dim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;entities, std::span&lt; const T &gt; values)</td></tr>
<tr class="memdesc:a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> from arrays.  <br /></td></tr>
<tr class="separator:a2bdcd9e9469ae3185e6ca6a3ee3fa581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb806bcc85940ea4818196d210d7dff7" id="r_aeb806bcc85940ea4818196d210d7dff7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb806bcc85940ea4818196d210d7dff7">compute_entity_permutations</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="separator:aeb806bcc85940ea4818196d210d7dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332133c6fd59b509e8a60420ba7bc67b" id="r_a332133c6fd59b509e8a60420ba7bc67b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a332133c6fd59b509e8a60420ba7bc67b">create_topology</a> (MPI_Comm comm, std::span&lt; const std::int64_t &gt; cells, std::span&lt; const std::int64_t &gt; original_cell_index, std::span&lt; const int &gt; ghost_owners, <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> cell_type, std::span&lt; const std::int64_t &gt; boundary_vertices)</td></tr>
<tr class="memdesc:a332133c6fd59b509e8a60420ba7bc67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh topology.  <br /></td></tr>
<tr class="separator:a332133c6fd59b509e8a60420ba7bc67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f7a4d6e8491a383dc59d52155fdc5" id="r_a5d6f7a4d6e8491a383dc59d52155fdc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d6f7a4d6e8491a383dc59d52155fdc5">create_topology</a> (MPI_Comm comm, const std::vector&lt; <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt; &amp;cell_type, std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; cells, std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; original_cell_index, std::vector&lt; std::span&lt; const int &gt; &gt; ghost_owners, std::span&lt; const std::int64_t &gt; boundary_vertices)</td></tr>
<tr class="memdesc:a5d6f7a4d6e8491a383dc59d52155fdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a topology of mixed cell type.  <br /></td></tr>
<tr class="separator:a5d6f7a4d6e8491a383dc59d52155fdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af09e67e8db0d211e9b00393cf9f5ae" id="r_a6af09e67e8db0d211e9b00393cf9f5ae"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>, std::vector&lt; int32_t &gt;, std::vector&lt; int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af09e67e8db0d211e9b00393cf9f5ae">create_subtopology</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a6af09e67e8db0d211e9b00393cf9f5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a topology for a subset of entities of a given topological dimension.  <br /></td></tr>
<tr class="separator:a6af09e67e8db0d211e9b00393cf9f5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ae5994989c886b804b3f6b64275fd" id="r_af81ae5994989c886b804b3f6b64275fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81ae5994989c886b804b3f6b64275fd">entities_to_index</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:af81ae5994989c886b804b3f6b64275fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entity indices for entities defined by their vertices.  <br /></td></tr>
<tr class="separator:af81ae5994989c886b804b3f6b64275fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ce5855b890649f0943dae9d9a6f38" id="r_a282ce5855b890649f0943dae9d9a6f38"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a282ce5855b890649f0943dae9d9a6f38">compute_entities</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, int index)</td></tr>
<tr class="memdesc:a282ce5855b890649f0943dae9d9a6f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh entities of given topological dimension by computing entity-to-vertex connectivity <code>(dim, 0)</code>, and cell-to-entity connectivity <code>(tdim, dim)</code>.  <br /></td></tr>
<tr class="separator:a282ce5855b890649f0943dae9d9a6f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4f42aff4598cabfd26cffcad782913" id="r_add4f42aff4598cabfd26cffcad782913"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add4f42aff4598cabfd26cffcad782913">compute_connectivity</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, std::pair&lt; std::int8_t, std::int8_t &gt; d0, std::pair&lt; std::int8_t, std::int8_t &gt; d1)</td></tr>
<tr class="memdesc:add4f42aff4598cabfd26cffcad782913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connectivity (d0 -&gt; d1) for given pair of entity types, given by topological dimension and index, as found in <code><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#a9d7170c6e2d646c7b6fdfa139dbdc2f6" title="Get the entity types in the topology for a given dimension.">Topology::entity_types()</a></code>  <br /></td></tr>
<tr class="separator:add4f42aff4598cabfd26cffcad782913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd805c0f4a1ee1533a6b05417ddcaa1" id="r_abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd805c0f4a1ee1533a6b05417ddcaa1">exterior_facet_indices</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="memdesc:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indices of all exterior facets that are owned by the caller.  <br /></td></tr>
<tr class="separator:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d9b5cca14603833020dfa05d886207" id="r_ac0d9b5cca14603833020dfa05d886207"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d9b5cca14603833020dfa05d886207">extract_topology</a> (<a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> cell_type, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;layout, std::span&lt; const std::int64_t &gt; cells)</td></tr>
<tr class="memdesc:ac0d9b5cca14603833020dfa05d886207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract topology from cell data, i.e. extract cell vertices.  <br /></td></tr>
<tr class="separator:ac0d9b5cca14603833020dfa05d886207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294c20389ab1f3b4c5b70eaa6f1dc00" id="r_a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8294c20389ab1f3b4c5b70eaa6f1dc00">h</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, std::span&lt; const std::int32_t &gt; entities, int dim)</td></tr>
<tr class="memdesc:a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute greatest distance between any two vertices of the mesh entities (<code>h</code>).  <br /></td></tr>
<tr class="separator:a8294c20389ab1f3b4c5b70eaa6f1dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fa456882009e9a0025061837b40e55" id="r_a67fa456882009e9a0025061837b40e55"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a67fa456882009e9a0025061837b40e55"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67fa456882009e9a0025061837b40e55">cell_normals</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a67fa456882009e9a0025061837b40e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normal to given cell (viewed as embedded in 3D)  <br /></td></tr>
<tr class="separator:a67fa456882009e9a0025061837b40e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbbf93d4d231f00b543bf8cc9fece7" id="r_ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4dbbf93d4d231f00b543bf8cc9fece7">compute_midpoints</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the midpoints for mesh entities of a given dimension.  <br /></td></tr>
<tr class="separator:ad4dbbf93d4d231f00b543bf8cc9fece7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab344919e038891a57c7a943cc5a420ee" id="r_ab344919e038891a57c7a943cc5a420ee"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:ab344919e038891a57c7a943cc5a420ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab344919e038891a57c7a943cc5a420ee">locate_entities</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, U marker)</td></tr>
<tr class="memdesc:ab344919e038891a57c7a943cc5a420ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that evaluate to true for the provided geometric marking function.  <br /></td></tr>
<tr class="separator:ab344919e038891a57c7a943cc5a420ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4773c26421814d452b07150df4ece8" id="r_a7f4773c26421814d452b07150df4ece8"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:a7f4773c26421814d452b07150df4ece8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f4773c26421814d452b07150df4ece8">locate_entities_boundary</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, U marker)</td></tr>
<tr class="memdesc:a7f4773c26421814d452b07150df4ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function.  <br /></td></tr>
<tr class="separator:a7f4773c26421814d452b07150df4ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecd3563f7690e56e947dfcf0a66a4a6" id="r_a8ecd3563f7690e56e947dfcf0a66a4a6"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a8ecd3563f7690e56e947dfcf0a66a4a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ecd3563f7690e56e947dfcf0a66a4a6">entities_to_geometry</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities, bool permute=false)</td></tr>
<tr class="memdesc:a8ecd3563f7690e56e947dfcf0a66a4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry degrees of freedom associated with the closure of a given set of cell entities.  <br /></td></tr>
<tr class="separator:a8ecd3563f7690e56e947dfcf0a66a4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22d3fa3023edcd8cdd5d8550b19484" id="r_aff22d3fa3023edcd8cdd5d8550b19484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a> (<a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a> ghost_mode=mesh::GhostMode::none, const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#aa2e8bbea5ac3a27249e3155bc455f887">graph::partition_fn</a> &amp;partfn=&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a>)</td></tr>
<tr class="separator:aff22d3fa3023edcd8cdd5d8550b19484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec76d69eb4bf33692781bc8995c9b5f" id="r_abec76d69eb4bf33692781bc8995c9b5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec76d69eb4bf33692781bc8995c9b5f">compute_incident_entities</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, std::span&lt; const std::int32_t &gt; entities, int d0, int d1)</td></tr>
<tr class="memdesc:abec76d69eb4bf33692781bc8995c9b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute incident indices.  <br /></td></tr>
<tr class="separator:abec76d69eb4bf33692781bc8995c9b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611ba63b9b9197c08613cccdc41464ee" id="r_a611ba63b9b9197c08613cccdc41464ee"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a611ba63b9b9197c08613cccdc41464ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a611ba63b9b9197c08613cccdc41464ee">create_mesh</a> (MPI_Comm comm, MPI_Comm commt, std::span&lt; const std::int64_t &gt; cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;element, MPI_Comm commg, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner)</td></tr>
<tr class="memdesc:a611ba63b9b9197c08613cccdc41464ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mesh from mesh data using a provided graph partitioning function for determining the parallel distribution of the mesh.  <br /></td></tr>
<tr class="separator:a611ba63b9b9197c08613cccdc41464ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ba431380eb85176f0842c4df2144fe" id="r_a70ba431380eb85176f0842c4df2144fe"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a70ba431380eb85176f0842c4df2144fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70ba431380eb85176f0842c4df2144fe">create_mesh</a> (MPI_Comm comm, MPI_Comm commt, const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;cells, const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;elements, MPI_Comm commg, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;partitioner)</td></tr>
<tr class="memdesc:a70ba431380eb85176f0842c4df2144fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mixed-topology mesh from mesh data using a provided graph partitioning function for determining the parallel distribution of the mesh.  <br /></td></tr>
<tr class="separator:a70ba431380eb85176f0842c4df2144fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3471710d7fca68f819993efab03d81" id="r_ada3471710d7fca68f819993efab03d81"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ada3471710d7fca68f819993efab03d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada3471710d7fca68f819993efab03d81">create_mesh</a> (MPI_Comm comm, std::span&lt; const std::int64_t &gt; cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;elements, const U &amp;x, std::array&lt; std::size_t, 2 &gt; xshape, <a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">GhostMode</a> ghost_mode)</td></tr>
<tr class="memdesc:ada3471710d7fca68f819993efab03d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mesh from mesh data using the default graph partitioner to determine the parallel distribution of the mesh.  <br /></td></tr>
<tr class="separator:ada3471710d7fca68f819993efab03d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e805f1f5252c2cc4c88a00ad6393025" id="r_a8e805f1f5252c2cc4c88a00ad6393025"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a8e805f1f5252c2cc4c88a00ad6393025"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; T &gt;, std::vector&lt; int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e805f1f5252c2cc4c88a00ad6393025">create_subgeometry</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; subentity_to_entity)</td></tr>
<tr class="memdesc:a8e805f1f5252c2cc4c88a00ad6393025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sub-geometry from a mesh and a subset of mesh entities to be included. A sub-geometry is simply a <code><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a></code> object containing only the geometric information for the subset of entities. The entities may differ in topological dimension from the original mesh.  <br /></td></tr>
<tr class="separator:a8e805f1f5252c2cc4c88a00ad6393025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae246db16404ff4ea5d09b858ae2ba65c" id="r_ae246db16404ff4ea5d09b858ae2ba65c"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ae246db16404ff4ea5d09b858ae2ba65c"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae246db16404ff4ea5d09b858ae2ba65c">create_submesh</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:ae246db16404ff4ea5d09b858ae2ba65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new mesh consisting of a subset of entities in a mesh.  <br /></td></tr>
<tr class="separator:ae246db16404ff4ea5d09b858ae2ba65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes. </p>
<p>Representations of meshes and support for operations on meshes. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="acab22e3b5c8ac14664c8cd8e6f53fb70" name="acab22e3b5c8ac14664c8cd8e6f53fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab22e3b5c8ac14664c8cd8e6f53fb70">&#9670;&#160;</a></span>CellPartitionFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;graph::AdjacencyList&lt;std::int32_t&gt;(</div>
<div class="line">    MPI_Comm comm, <span class="keywordtype">int</span> nparts, <span class="keyword">const</span> std::vector&lt;CellType&gt;&amp; cell_types,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::span&lt;const std::int64_t&gt;&gt;&amp; cells)&gt;</div>
</div><!-- fragment -->
<p>Signature for the cell partitioning function. The function should compute the destination rank for cells currently on this rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nparts</td><td>Number of partitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_types</td><td>Cell types in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Lists of cells of each cell type. cells[i] is a flattened row major 2D array of shape (num_cells, num_cell_vertices) for cell_types[i] on this process, containing the global indices for the cell vertices. Each cell can appear only once across all processes. The cell vertex indices are not necessarily contiguous globally, i.e. the maximum index across all processes can be greater than the number of vertices. High-order 'nodes', e.g. mid-side points, should not be included. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destination ranks for each cell on this process </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cells can have multiple destination ranks, when ghosted. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac4ecab159304e7a6c7146533196aca6f" name="ac4ecab159304e7a6c7146533196aca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ecab159304e7a6c7146533196aca6f">&#9670;&#160;</a></span>build_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; build_dual_graph </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>celltypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data. </p>
<p>The computed dual graph is typically passed to a graph partitioner.</p>
<dl class="section note"><dt>Note</dt><dd>Collective function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltypes</td><td>List of cell types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Collections of cells, defined by the cell vertices from which to build the dual graph, as flattened arrays for each cell type in <code>celltypes</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>cells</code> and <code>celltypes</code> must have the same size. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The dual graph </dd></dl>

</div>
</div>
<a id="aab5c2d292165f0f24be6db01db324529" name="aab5c2d292165f0f24be6db01db324529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5c2d292165f0f24be6db01db324529">&#9670;&#160;</a></span>build_local_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt; build_local_dual_graph </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>celltypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the local part of the dual graph (cell-cell connections via facets) and facets with only one attached cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">celltypes</td><td>List of cell types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Lists of cell vertices (stored as flattened lists, one for each cell type). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>Local dual graph</li>
<li>Facets, defined by their vertices, that are shared by only one cell on this rank. The logically 2D array is flattened (row-major).</li>
<li>The number of columns for the facet data array (2).</li>
<li>The attached cell (local index) to each returned facet in (2).</li>
</ol>
</dd></dl>
<p>Each row of the returned data (2) contains <code>[v0, ... v_(n-1), x, .., / x]</code>, where <code>v_i</code> is a vertex global index, <code>x</code> is a padding value (all padding values will be equal).</p>
<dl class="section note"><dt>Note</dt><dd>The cells of each cell type are numbered locally consecutively, i.e. if there are <code>n</code> cells of type <code>0</code> and <code>m</code> cells of type <code>1</code>, then cells of type <code>0</code> are numbered <code>0..(n-1)</code> and cells of type <code>1</code> are numbered <code>n..(n+m-1)</code> respectively, in the returned dual graph. </dd></dl>

</div>
</div>
<a id="aacd44e8136c15b9593dfdd87cd744c32" name="aacd44e8136c15b9593dfdd87cd744c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd44e8136c15b9593dfdd87cd744c32">&#9670;&#160;</a></span>cell_entity_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::array&lt; int, 2 &gt;, std::vector&lt; std::set&lt; int &gt; &gt; &gt; cell_entity_closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closure entities for a cell, i.e., all lower-dimensional entities attached to a cell entity. Map from entity {dim_e, entity_e} to closure{sub_dim, (sub_entities)} </p>

</div>
</div>
<a id="a66c376aedd08ad2dab6f13eba56b6f36" name="a66c376aedd08ad2dab6f13eba56b6f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c376aedd08ad2dab6f13eba56b6f36">&#9670;&#160;</a></span>cell_facet_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">mesh::CellType</a> cell_facet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return facet type of cell For simplex and hypercube cell types, this is independent of the facet index, but for prism and pyramid, it can be triangle or quadrilateral. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The facet index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of facet for this cell at this index </dd></dl>

</div>
</div>
<a id="a67fa456882009e9a0025061837b40e55" name="a67fa456882009e9a0025061837b40e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fa456882009e9a0025061837b40e55">&#9670;&#160;</a></span>cell_normals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; cell_normals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute normal to given cell (viewed as embedded in 3D) </p>
<dl class="section return"><dt>Returns</dt><dd>The entity normals. The shape is <code>(entities.size(), 3)</code> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="abe2926fe64174120b2e865e0b7bf9946" name="abe2926fe64174120b2e865e0b7bf9946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2926fe64174120b2e865e0b7bf9946">&#9670;&#160;</a></span>cell_num_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cell_num_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entities of dimension dim </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Entity dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entities in cell </dd></dl>

</div>
</div>
<a id="add4f42aff4598cabfd26cffcad782913" name="add4f42aff4598cabfd26cffcad782913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4f42aff4598cabfd26cffcad782913">&#9670;&#160;</a></span>compute_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt; compute_connectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::int8_t, std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>d0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::int8_t, std::int8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connectivity (d0 -&gt; d1) for given pair of entity types, given by topological dimension and index, as found in <code><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#a9d7170c6e2d646c7b6fdfa139dbdc2f6" title="Get the entity types in the topology for a given dimension.">Topology::entity_types()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>The dimension and index of the entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>The dimension and index of the incident entities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The connectivities [(d0 -&gt; d1), (d1 -&gt; d0)] if they are computed. If (d0, d1) already exists then a nullptr is returned. If (d0, d1) is computed and the computation of (d1, d0) was required as part of computing (d0, d1), the (d1, d0) is returned as the second entry. The second entry is otherwise nullptr. </dd></dl>

</div>
</div>
<a id="a282ce5855b890649f0943dae9d9a6f38" name="a282ce5855b890649f0943dae9d9a6f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282ce5855b890649f0943dae9d9a6f38">&#9670;&#160;</a></span>compute_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt; compute_entities </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mesh entities of given topological dimension by computing entity-to-vertex connectivity <code>(dim, 0)</code>, and cell-to-entity connectivity <code>(tdim, dim)</code>. </p>
<p>Computed entities are oriented such that their local (to the process) orientation agrees with their global orientation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the entities to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of entity in dimension <code>dim</code> as listed in <code>Topology::entity_types(dim)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (cell-entity connectivity, entity-vertex connectivity, index map, list of interprocess entities). Interprocess entities lie on the "true" boundary between owned cells of each process. If the entities already exists, then {nullptr, nullptr, nullptr, std::vector()} is returned. </dd></dl>

</div>
</div>
<a id="aeb806bcc85940ea4818196d210d7dff7" name="aeb806bcc85940ea4818196d210d7dff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb806bcc85940ea4818196d210d7dff7">&#9670;&#160;</a></span>compute_entity_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt; compute_entity_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute (1) facet rotation and reflection data, and (2) cell permutation data. This information is used in the assembly of (1) facet integrals and (2) most non-Lagrange elements.</p>
<ol type="1">
<li><p class="startli">The facet rotation and reflection data is encoded so that:</p><ul>
<li><code>n % 2</code> gives the number of reflections to apply</li>
<li><code>n // 2</code> gives the number of rotations to apply</li>
</ul>
<p class="startli">The data is stored in a flattened 2D array, so that <code>data[cell_index * / facets_per_cell + facet_index]</code> contains the facet with index <code>facet_index</code> of the cell with index <code>cell_index</code>. This data passed to FFCx kernels, where it is used to permute the quadrature points on facet integrals when data from the cells on both sides of the facet is used.</p>
</li>
<li><p class="startli">The cell permutation data contains information about the entities of each cell, relative to a low-to-high ordering. This data is packed so that a 32-bit int is used for each cell. For 2D cells, one bit is used for each edge, to represent whether or not the edge is reversed: the least significant bit is for edge 0, the next for edge 1, etc. For 3D cells, three bits are used for each face, and for each edge: the least significant bit says whether or not face 0 is reflected, the next 2 bits say how many times face 0 is rotated; the next three bits are for face 1, then three for face 2, etc; after all the faces, there is 1 bit for each edge to say whether or not they are reversed.</p>
<p class="startli">For example, if a quadrilateral has cell permutation info <code>....0111</code> then (from right to left):</p><ul>
<li>edge 0 is reflected (1)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is reflected (1)</li>
<li>edge 3 is not permuted (0)</li>
</ul>
<p class="startli">and if a tetrahedron has cell permutation info <code>....011010010101001000</code> then (from right to left):</p><ul>
<li>face 0 is not permuted (000)</li>
<li>face 1 is reflected (001)</li>
<li>face 2 is rotated twice then reflected (101)</li>
<li>face 3 is rotated once (010)</li>
<li>edge 0 is not permuted (0)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is not permuted (0)</li>
<li>edge 3 is reflected (1)</li>
<li>edge 4 is reflected (1)</li>
<li>edge 5 is not permuted (0)</li>
</ul>
<p class="startli">This data is used to correct the direction of vector function on permuted facets.</p>
</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Facet permutation and cells permutations </dd></dl>

</div>
</div>
<a id="abec76d69eb4bf33692781bc8995c9b5f" name="abec76d69eb4bf33692781bc8995c9b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec76d69eb4bf33692781bc8995c9b5f">&#9670;&#160;</a></span>compute_incident_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_incident_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute incident indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of indices of topological dimension <code>d0</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>Topological dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>Topological dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of entities of topological dimension <code>d1</code> that are incident to entities in <code>entities</code> (topological dimension <code>d0</code>) </dd></dl>

</div>
</div>
<a id="ad4dbbf93d4d231f00b543bf8cc9fece7" name="ad4dbbf93d4d231f00b543bf8cc9fece7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbbf93d4d231f00b543bf8cc9fece7">&#9670;&#160;</a></span>compute_midpoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; compute_midpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the midpoints for mesh entities of a given dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>The entity midpoints. The shape is <code>(entities.size(), 3)</code> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="a33474c393dedcbd953593f52e6188296" name="a33474c393dedcbd953593f52e6188296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33474c393dedcbd953593f52e6188296">&#9670;&#160;</a></span>create_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_box </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>subcomm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <code>p</code>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + / 1)*(n[1] + 1)*(n[2] + 1)</code>. For tetrahedra there will be will be <code>6*n[0]*n[1]*n[2]</code> cells. For hexahedra the number of cells will be <code>n[0]*n[1]*n[2]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to distribute the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subcomm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to construct and partition the mesh topology on. If the process should not be involved in the topology creation and partitioning then this communicator should be <code>MPI_COMM_NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Corner of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a8cb4517e0694412cafd31bde307baed9" name="a8cb4517e0694412cafd31bde307baed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb4517e0694412cafd31bde307baed9">&#9670;&#160;</a></span>create_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_box </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 3 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over rectangular prism spanned by the two points <code>p</code>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + / 1)*(n[1] + 1)*(n[2] + 1)</code>. For tetrahedra there will be will be <code>6*n[0]*n[1]*n[2]</code> cells. For hexahedra the number of cells will be <code>n[0]*n[1]*n[2]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to distribute the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Corner of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="aff22d3fa3023edcd8cdd5d8550b19484" name="aff22d3fa3023edcd8cdd5d8550b19484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff22d3fa3023edcd8cdd5d8550b19484">&#9670;&#160;</a></span>create_cell_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">mesh::CellPartitionFunction</a> create_cell_partitioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mesh::GhostMode::none</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#aa2e8bbea5ac3a27249e3155bc455f887">graph::partition_fn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partfn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a function that computes destination rank for mesh cells in this rank by applying the default graph partitioner to the dual graph of the mesh </p><dl class="section return"><dt>Returns</dt><dd>Function that computes the destination ranks for each cell </dd></dl>

</div>
</div>
<a id="a51b4223a067001f49af0dca0c47ac340" name="a51b4223a067001f49af0dca0c47ac340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b4223a067001f49af0dca0c47ac340">&#9670;&#160;</a></span>create_geometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>xdofs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data. </p>
<p>This function should be called after the mesh topology is built and 'node' coordinate data has been distributed to the processes where it is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Element that defines the geometry map for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> node global indices for cells on this process. Must be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xdofs</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> degree-of-freedom map (using global indices) for cells on this process. <code>nodes</code> is a sorted and unique list of the indices in <code>xdofs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The node coordinates (row-major, with shape <code>(num_nodes, dim)</code>. The global index of each node is <code>i + / rank_offset</code>, where <code>i</code> is the local row index in <code>x</code> and <code>rank_offset</code> is the sum of <code>x</code> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Geometric dimension (1, 2, or 3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for re-ordering the degree-of-freedom map associated with the geometry data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh geometry. </dd></dl>

</div>
</div>
<a id="a4517d9b85ae3658d28f603f29116130a" name="a4517d9b85ae3658d28f603f29116130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4517d9b85ae3658d28f603f29116130a">&#9670;&#160;</a></span>create_geometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>xdofs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>reorder_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data. </p>
<p>This function should be called after the mesh topology is built and 'node' coordinate data has been distributed to the processes where it is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>List of elements that defines the geometry map for each cell type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> node global indices for cells on this process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be sorted. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xdofs</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> degree-of-freedom map (using global indices) for cells on this process. <code>nodes</code> is a sorted and unique list of the indices in <code>xdofs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The node coordinates (row-major, with shape <code>(num_nodes, dim)</code>. The global index of each node is <code>i + / rank_offset</code>, where <code>i</code> is the local row index in <code>x</code> and <code>rank_offset</code> is the sum of <code>x</code> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Geometric dimension (1, 2, or 3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for re-ordering the degree-of-freedom map associated with the geometry data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Experimental new interface for multiple cmap/dofmap </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh geometry. </dd></dl>

</div>
</div>
<a id="abafdc3673f5b50c40ec814e8f47d0bf8" name="abafdc3673f5b50c40ec814e8f47d0bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafdc3673f5b50c40ec814e8f47d0bf8">&#9670;&#160;</a></span>create_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_interval </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mesh::GhostMode::none</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval mesh of the 1D line <code>[a, b]</code>. </p>
<p>Given <code>n</code> cells in the axial direction, the total number of intervals will be <code>n</code> and the total number of vertices will be <code>n + 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>End points of the interval. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>ghost mode of the created mesh, defaults to none </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh. </dd></dl>

</div>
</div>
<a id="a70ba431380eb85176f0842c4df2144fe" name="a70ba431380eb85176f0842c4df2144fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ba431380eb85176f0842c4df2144fe">&#9670;&#160;</a></span>create_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::span&lt; const std::int64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mixed-topology mesh from mesh data using a provided graph partitioning function for determining the parallel distribution of the mesh. </p>
<p>From mesh input data that is distributed across processes, a distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> is created. If the partitioning function is not callable, i.e. it does not store a callable function, no re-distribution of cells is done.</p>
<dl class="section note"><dt>Note</dt><dd>This is an experimental specialised version of <code>create_mesh</code> for mixed topology meshes, and does not include cell reordering.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commt</td><td>Communicator that the topology data (<code>cells</code>) is distributed on. This should be <code>MPI_COMM_NULL</code> for ranks that should not participate in computing the topology partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on the calling process, as a list of lists, one list for each cell type (or an empty list if there are no cells of that type on this process). The cells are defined by their 'nodes' (using global indices) following the Basix ordering, and concatenated to form a flattened list. For lowest order cells this will be just the cell vertices. For higher-order cells, other cells 'nodes' will be included. See <a class="el" href="../../df/dcf/namespacedolfinx_1_1io_1_1cells.html" title="Functions for the re-ordering of input mesh topology to the DOLFINx ordering, and transpose orderings...">dolfinx::io::cells</a> for examples of the Basix ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Coordinate elements for the cells, one for each cell type in the mesh. In parallel, these must be the same on all processes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commg</td><td>Communicator for geometry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). Row-major storage. The global index of the <code>i</code>th node (row) in <code>x</code> is taken as <code>i</code> plus the process offset on<code>comm</code>, The offset is the sum of <code>x</code> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>Shape of the <code>x</code> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Graph partitioner that computes the owning rank for each cell. If not callable, cells are not redistributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <code>comm</code>. </dd></dl>

</div>
</div>
<a id="a611ba63b9b9197c08613cccdc41464ee" name="a611ba63b9b9197c08613cccdc41464ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611ba63b9b9197c08613cccdc41464ee">&#9670;&#160;</a></span>create_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>commg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mesh from mesh data using a provided graph partitioning function for determining the parallel distribution of the mesh. </p>
<p>From mesh input data that is distributed across processes, a distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> is created. If the partitioning function is not callable, i.e. it does not store a callable function, no re-distribution of cells is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commt</td><td>Communicator that the topology data (<code>cells</code>) is distributed on. This should be <code>MPI_COMM_NULL</code> for ranks that should not participate in computing the topology partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on the calling process. Each cell (node in the <code>AdjacencyList</code>) is defined by its 'nodes' (using global indices) following the Basix ordering. For lowest order cells this will be just the cell vertices. For higher-order cells, other cells 'nodes' will be included. See <a class="el" href="../../df/dcf/namespacedolfinx_1_1io_1_1cells.html" title="Functions for the re-ordering of input mesh topology to the DOLFINx ordering, and transpose orderings...">dolfinx::io::cells</a> for examples of the Basix ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Coordinate element for the cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commg</td><td>Communicator for geometry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). Row-major storage. The global index of the <code>i</code>th node (row) in <code>x</code> is taken as <code>i</code> plus the process offset on<code>comm</code>, The offset is the sum of <code>x</code> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>Shape of the <code>x</code> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Graph partitioner that computes the owning rank for each cell. If not callable, cells are not redistributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <code>comm</code>. </dd></dl>

</div>
</div>
<a id="ada3471710d7fca68f819993efab03d81" name="ada3471710d7fca68f819993efab03d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3471710d7fca68f819993efab03d81">&#9670;&#160;</a></span>create_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; typename std::remove_reference_t&lt; typename U::value_type &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&lt; std::remove_reference_t&lt; typename U::value_type &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>xshape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a38d109d131f3180f43267fcf9fe9c4c4">GhostMode</a></td>          <td class="paramname"><span class="paramname"><em>ghost_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mesh from mesh data using the default graph partitioner to determine the parallel distribution of the mesh. </p>
<p>This function takes mesh input data that is distributed across processes and creates a <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a>, with the mesh cell distribution determined by the default cell partitioner. The default partitioner is based on graph partitioning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on the calling process. See <a class="el" href="#a611ba63b9b9197c08613cccdc41464ee" title="Create a distributed mesh from mesh data using a provided graph partitioning function for determining...">create_mesh</a> for a detailed description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Coordinate elements for the cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> data ('node' coordinates). See <a class="el" href="#a611ba63b9b9197c08613cccdc41464ee" title="Create a distributed mesh from mesh data using a provided graph partitioning function for determining...">create_mesh</a> for a detailed description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>The shape of <code>x</code>. It should be <code>(num_points, gdim)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>The requested type of cell ghosting/overlap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh distributed on the communicator <code>comm</code>. </dd></dl>

</div>
</div>
<a id="a2bdcd9e9469ae3185e6ca6a3ee3fa581" name="a2bdcd9e9469ae3185e6ca6a3ee3fa581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdcd9e9469ae3185e6ca6a3ee3fa581">&#9670;&#160;</a></span>create_meshtags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt; T &gt; create_meshtags </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh topology entities.">MeshTags</a> from arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology that the tags are associated with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of tagged entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Local vertex indices for tagged entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Tag values for each entity in <code>entities</code>. The length of <code>values</code> must be equal to number of rows in <code>entities</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entities that do not exist on this rank are ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>entities</code> must not contain duplicate entities. </dd></dl>

</div>
</div>
<a id="aaf31dd1565b3df8ce4f0f180e68965a9" name="aaf31dd1565b3df8ce4f0f180e68965a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf31dd1565b3df8ce4f0f180e68965a9">&#9670;&#160;</a></span>create_rectangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab22e3b5c8ac14664c8cd8e6f53fb70">CellPartitionFunction</a></td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a></td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DiagonalType::right</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + / 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Bottom-left and top-right corners of the rectangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function for distributing cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a327c492002b54befefb2077e4b5f861c" name="a327c492002b54befefb2077e4b5f861c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c492002b54befefb2077e4b5f861c">&#9670;&#160;</a></span>create_rectangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::array&lt; T, 2 &gt;, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::int64_t, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>celltype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a></td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DiagonalType::right</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. </p>
<p>The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + / 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Two corner points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a8e805f1f5252c2cc4c88a00ad6393025" name="a8e805f1f5252c2cc4c88a00ad6393025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e805f1f5252c2cc4c88a00ad6393025">&#9670;&#160;</a></span>create_subgeometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a>&lt; T &gt;, std::vector&lt; int32_t &gt; &gt; create_subgeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>subentity_to_entity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sub-geometry from a mesh and a subset of mesh entities to be included. A sub-geometry is simply a <code><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a></code> object containing only the geometric information for the subset of entities. The entities may differ in topological dimension from the original mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The full mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the sub-topology. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subentity_to_entity</td><td>Map from sub-topology entity to the entity in the parent topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sub-geometry and a map from sub-geometry coordinate degree-of-freedom to the coordinate degree-of-freedom in <code>geometry</code>. </dd></dl>

</div>
</div>
<a id="ae246db16404ff4ea5d09b858ae2ba65c" name="ae246db16404ff4ea5d09b858ae2ba65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae246db16404ff4ea5d09b858ae2ba65c">&#9670;&#160;</a></span>create_submesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt; &gt; create_submesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new mesh consisting of a subset of entities in a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Entity dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of entity indices in <code>mesh</code> to include in the new mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new mesh, and maps from the new mesh entities, vertices, and geometry to the input mesh entities, vertices, and geometry. </dd></dl>

</div>
</div>
<a id="a6af09e67e8db0d211e9b00393cf9f5ae" name="a6af09e67e8db0d211e9b00393cf9f5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af09e67e8db0d211e9b00393cf9f5ae">&#9670;&#160;</a></span>create_subtopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>, std::vector&lt; int32_t &gt;, std::vector&lt; int32_t &gt; &gt; create_subtopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a topology for a subset of entities of a given topological dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topology</td><td>Original (parent) topology. </td></tr>
    <tr><td class="paramname">dim</td><td>Topological dimension of the entities in the new topology. </td></tr>
    <tr><td class="paramname">entities</td><td>Indices of entities in <code>topology</code> to include in the new topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New topology of dimension <code>dim</code> with all entities in <code>entities</code>, map from entities of dimension <code>dim</code> in new sub-topology to entities in <code>topology</code>, and map from vertices in new sub-topology to vertices in <code>topology</code>. </dd></dl>

</div>
</div>
<a id="a5d6f7a4d6e8491a383dc59d52155fdc5" name="a5d6f7a4d6e8491a383dc59d52155fdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6f7a4d6e8491a383dc59d52155fdc5">&#9670;&#160;</a></span>create_topology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> create_topology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const std::int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const std::int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>original_cell_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::span&lt; const int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>ghost_owners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_vertices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a topology of mixed cell type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator </td></tr>
    <tr><td class="paramname">cell_type</td><td>List of cell types </td></tr>
    <tr><td class="paramname">cells</td><td>Lists of cells, using vertex indices, flattened, for each cell type. </td></tr>
    <tr><td class="paramname">original_cell_index</td><td>Input cell index for each cell type </td></tr>
    <tr><td class="paramname">ghost_owners</td><td>Owning rank for ghost cells (at end of each list of cells). </td></tr>
    <tr><td class="paramname">boundary_vertices</td><td>Vertices of undetermined ownership on external or inter-process boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a332133c6fd59b509e8a60420ba7bc67b" name="a332133c6fd59b509e8a60420ba7bc67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332133c6fd59b509e8a60420ba7bc67b">&#9670;&#160;</a></span>create_topology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> create_topology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>original_cell_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>ghost_owners</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_vertices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mesh topology. </p>
<p>This function creates a <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html" title="Topology stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relat...">Topology</a> from cells that have been distributed to the processes that own or ghost the cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>Communicator across which the topology is distributed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cell topology (list of vertices for each cell) using global indices for the vertices. It contains cells that have been distributed to this rank, e.g. via a graph partitioner. It must also contain all ghost cells via facet, i.e. cells that are on a neighboring process and which share a facet with a local cell. Ghost cells are the last <code>n</code> entries in <code>cells</code>, where <code>n</code> is given by the length of <code>ghost_owners</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_cell_index</td><td>Original global index associated with each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_owners</td><td>Owning rank of each ghost cell (ghost cells are always at the end of the list of <code>cells</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>A vector with cell shapes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_vertices</td><td>Vertices on the 'exterior' (boundary) of the local topology. These vertices might appear on other processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distributed mesh topology </dd></dl>

</div>
</div>
<a id="a8ecd3563f7690e56e947dfcf0a66a4a6" name="a8ecd3563f7690e56e947dfcf0a66a4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecd3563f7690e56e947dfcf0a66a4a6">&#9670;&#160;</a></span>entities_to_geometry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; entities_to_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>permute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the geometry degrees of freedom associated with the closure of a given set of cell entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Entity indices (local to process). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permute</td><td>If <code>true</code>, permute the DOFs such that they are consistent with the orientation of <code>dim</code>-dimensional mesh entities. This requires <code>create_entity_permutations</code> to be called first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The geometry DOFs associated with the closure of each entity in <code>entities</code>. The shape is <code>(num_entities, num_xdofs_per_entity)</code> and the storage is row-major. The index <code>indices[i, j]</code> is the position in the geometry array of the <code>j</code>-th vertex of the <code>entity[i]</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The mesh connectivities <code>dim -&gt; mesh.topology().dim()</code> and <code>mesh.topology().dim() -&gt; dim</code> must have been computed. Otherwise an exception is thrown. </dd></dl>

</div>
</div>
<a id="af81ae5994989c886b804b3f6b64275fd" name="af81ae5994989c886b804b3f6b64275fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ae5994989c886b804b3f6b64275fd">&#9670;&#160;</a></span>entities_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; entities_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get entity indices for entities defined by their vertices. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function may be removed in the future.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>The mesh entities defined by their vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the ith entity in <code>entities</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an entity cannot be found on this rank, -1 is returned as the index. </dd></dl>

</div>
</div>
<a id="abcd805c0f4a1ee1533a6b05417ddcaa1" name="abcd805c0f4a1ee1533a6b05417ddcaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd805c0f4a1ee1533a6b05417ddcaa1">&#9670;&#160;</a></span>exterior_facet_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; exterior_facet_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>topology</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indices of all exterior facets that are owned by the caller. </p>
<p>An exterior facet (co-dimension 1) is one that is connected globally to only one cell of co-dimension 0).</p>
<dl class="section note"><dt>Note</dt><dd>Collective</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted list of owned facet indices that are exterior facets of the mesh. </dd></dl>

</div>
</div>
<a id="ac0d9b5cca14603833020dfa05d886207" name="ac0d9b5cca14603833020dfa05d886207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d9b5cca14603833020dfa05d886207">&#9670;&#160;</a></span>extract_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int64_t &gt; extract_topology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>cell_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract topology from cell data, i.e. extract cell vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The layout of geometry 'degrees-of-freedom' on the reference cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>List of 'nodes' for each cell using global indices. The layout must be consistent with <code>layout</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell topology. The global indices will, in general, have 'gaps' due to mid-side and other higher-order nodes being removed from the input <code>cell</code>. </dd></dl>

</div>
</div>
<a id="a928c84854cdb3701ae7410d2f2c1a913" name="a928c84854cdb3701ae7410d2f2c1a913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928c84854cdb3701ae7410d2f2c1a913">&#9670;&#160;</a></span>get_entity_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt; get_entity_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return list of entities, where entities(e, k) is the local vertex index for the kth vertex of entity e of dimension dim </p>

</div>
</div>
<a id="afec08aa43ab0e757eca314632a5b5c1b" name="afec08aa43ab0e757eca314632a5b5c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec08aa43ab0e757eca314632a5b5c1b">&#9670;&#160;</a></span>get_sub_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt; get_sub_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get entities of dimension dim1 and that make up entities of dimension dim0 </p>

</div>
</div>
<a id="a8294c20389ab1f3b4c5b70eaa6f1dc00" name="a8294c20389ab1f3b4c5b70eaa6f1dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8294c20389ab1f3b4c5b70eaa6f1dc00">&#9670;&#160;</a></span>h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute greatest distance between any two vertices of the mesh entities (<code>h</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> that the entities belong to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices (local to process) of entities to compute <code>h</code> for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest distance between any two vertices, <code>h[i]</code> corresponds to the entity <code>entities[i]</code>. </dd></dl>

</div>
</div>
<a id="ac88526e97d1edbaacb8471c0e9288a03" name="ac88526e97d1edbaacb8471c0e9288a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88526e97d1edbaacb8471c0e9288a03">&#9670;&#160;</a></span>is_simplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if cell is a simplex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is the cell type is a simplex </dd></dl>

</div>
</div>
<a id="ab344919e038891a57c7a943cc5a420ee" name="ab344919e038891a57c7a943cc5a420ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab344919e038891a57c7a943cc5a420ee">&#9670;&#160;</a></span>locate_entities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that evaluate to true for the provided geometric marking function. </p>
<p>An entity is considered marked if the marker function evaluates to true for all of its vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> to mark entities on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>Marking function, returns <code>true</code> for a point that is 'marked', and <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices, including any ghost indices (indices local to the process) </dd></dl>

</div>
</div>
<a id="a7f4773c26421814d452b07150df4ece8" name="a7f4773c26421814d452b07150df4ece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4773c26421814d452b07150df4ece8">&#9670;&#160;</a></span>locate_entities_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T, MarkerFn&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>marker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function. </p>
<p>An entity is considered marked if the marker function evaluates to true for all of its vertices.</p>
<dl class="section note"><dt>Note</dt><dd>For vertices and edges, in parallel this function will not necessarily mark all entities that are on the exterior boundary. For example, it is possible for a process to have a vertex that lies on the boundary without any of the attached facets being a boundary facet. When used to find degrees-of-freedom, e.g. using <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a84cd6568b465fbe013715ad3d70190cb" title="Find degrees-of-freedom which belong to the provided mesh entities (topological).">fem::locate_dofs_topological</a>, the function that uses the data returned by this function must typically perform some parallel communication.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> to mark entities on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities to be considered. Must be less than the topological dimension of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>Marking function, returns <code>true</code> for a point that is 'marked', and <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices (indices local to the process) </dd></dl>

</div>
</div>
<a id="a80294da14ab051e9f8eaf72080a7ee17" name="a80294da14ab051e9f8eaf72080a7ee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80294da14ab051e9f8eaf72080a7ee17">&#9670;&#160;</a></span>num_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_cell_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number vertices for a cell type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of cell vertices </dd></dl>

</div>
</div>
<a id="ae1f0961be83abe152e146c14c8f8548a" name="ae1f0961be83abe152e146c14c8f8548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0961be83abe152e146c14c8f8548a">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the cell string type for a cell type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type string </dd></dl>

</div>
</div>
<a id="aec82a925447a9da2a086b7c93739ba9c" name="aec82a925447a9da2a086b7c93739ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec82a925447a9da2a086b7c93739ba9c">&#9670;&#160;</a></span>to_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">mesh::CellType</a> to_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the cell type from a cell string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>Cell shape string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

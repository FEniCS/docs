<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::mesh Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFINx
   &#160;<span id="projectnumber">0.6.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dolfinx</b></li><li class="navelem"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html">mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dolfinx::mesh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes.  
<a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh entities.">MeshTags</a> associate values with mesh entities.  <a href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">Geometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> stores the geometry imposed on a mesh.  <a href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> consists of a set of connected and numbered mesh topological entities, and geometry data.  <a href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html" title="Topology stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relat...">Topology</a> stores the topology of a mesh, consisting of mesh entities and connectivity (incidence relations for the mesh entities).  <a href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae047b9fda4fdc9c521b6c1725480a582"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> = std::function&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">dolfinx::graph::AdjacencyList</a>&lt; std::int32_t &gt;(MPI_Comm comm, int nparts, int tdim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">dolfinx::graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells)&gt;</td></tr>
<tr class="memdesc:ae047b9fda4fdc9c521b6c1725480a582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the cell partitioning function. The function should compute the destination rank for cells currently on this rank.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">More...</a><br /></td></tr>
<tr class="separator:ae047b9fda4fdc9c521b6c1725480a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="memItemLeft" align="right" valign="top"><a id="ac3c2cbbef08f3b7ddc3b06c6bd5a2271"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> : int { <br />
&#160;&#160;<b>point</b> = 1
, <b>interval</b> = 2
, <b>triangle</b> = 3
, <b>tetrahedron</b> = 4
, <br />
&#160;&#160;<b>quadrilateral</b> = -4
, <b>pyramid</b> = -5
, <b>prism</b> = -6
, <b>hexahedron</b> = -8
<br />
 }</td></tr>
<tr class="memdesc:ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell type identifier. <br /></td></tr>
<tr class="separator:ac3c2cbbef08f3b7ddc3b06c6bd5a2271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="memItemLeft" align="right" valign="top"><a id="a5fb0494804cb9b4baeeff5b9027a8dfd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> { <br />
&#160;&#160;<b>left</b>
, <b>right</b>
, <b>crossed</b>
, <b>shared_facet</b>
, <br />
&#160;&#160;<b>left_right</b>
, <b>right_left</b>
<br />
 }</td></tr>
<tr class="memdesc:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different diagonal types. <br /></td></tr>
<tr class="separator:a5fb0494804cb9b4baeeff5b9027a8dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d109d131f3180f43267fcf9fe9c4c4"><td class="memItemLeft" align="right" valign="top"><a id="a38d109d131f3180f43267fcf9fe9c4c4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a38d109d131f3180f43267fcf9fe9c4c4">GhostMode</a> : int { <b>none</b>
, <b>shared_facet</b>
, <b>shared_vertex</b>
 }</td></tr>
<tr class="memdesc:a38d109d131f3180f43267fcf9fe9c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different partitioning ghost modes. <br /></td></tr>
<tr class="separator:a38d109d131f3180f43267fcf9fe9c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1f0961be83abe152e146c14c8f8548a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae1f0961be83abe152e146c14c8f8548a">to_string</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="memdesc:ae1f0961be83abe152e146c14c8f8548a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell string type for a cell type.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae1f0961be83abe152e146c14c8f8548a">More...</a><br /></td></tr>
<tr class="separator:ae1f0961be83abe152e146c14c8f8548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec82a925447a9da2a086b7c93739ba9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aec82a925447a9da2a086b7c93739ba9c">to_type</a> (const std::string &amp;cell)</td></tr>
<tr class="memdesc:aec82a925447a9da2a086b7c93739ba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell type from a cell string.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aec82a925447a9da2a086b7c93739ba9c">More...</a><br /></td></tr>
<tr class="separator:aec82a925447a9da2a086b7c93739ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="memItemLeft" align="right" valign="top"><a id="a6abcbdca3e3aae2fe00ad6ea7186cb0c"></a>
<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a6abcbdca3e3aae2fe00ad6ea7186cb0c">cell_entity_type</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int d, int index)</td></tr>
<tr class="memdesc:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of cell for entity of dimension d at given entity index. <br /></td></tr>
<tr class="separator:a6abcbdca3e3aae2fe00ad6ea7186cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c376aedd08ad2dab6f13eba56b6f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a66c376aedd08ad2dab6f13eba56b6f36">cell_facet_type</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int index)</td></tr>
<tr class="memdesc:a66c376aedd08ad2dab6f13eba56b6f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return facet type of cell For simplex and hypercube cell types, this is independent of the facet index, but for prism and pyramid, it can be triangle or quadrilateral.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a66c376aedd08ad2dab6f13eba56b6f36">More...</a><br /></td></tr>
<tr class="separator:a66c376aedd08ad2dab6f13eba56b6f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928c84854cdb3701ae7410d2f2c1a913"><td class="memItemLeft" align="right" valign="top"><a id="a928c84854cdb3701ae7410d2f2c1a913"></a>
<a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a928c84854cdb3701ae7410d2f2c1a913">get_entity_vertices</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim)</td></tr>
<tr class="memdesc:a928c84854cdb3701ae7410d2f2c1a913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of entities, where entities(e, k) is the local vertex index for the kth vertex of entity e of dimension dim. <br /></td></tr>
<tr class="separator:a928c84854cdb3701ae7410d2f2c1a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec08aa43ab0e757eca314632a5b5c1b"><td class="memItemLeft" align="right" valign="top"><a id="afec08aa43ab0e757eca314632a5b5c1b"></a>
<a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#afec08aa43ab0e757eca314632a5b5c1b">get_sub_entities</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim0, int dim1)</td></tr>
<tr class="memdesc:afec08aa43ab0e757eca314632a5b5c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entities of dimension dim1 and that make up entities of dimension dim0. <br /></td></tr>
<tr class="separator:afec08aa43ab0e757eca314632a5b5c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6984abad1707caa0c97b4e4b167106b3"><td class="memItemLeft" align="right" valign="top"><a id="a6984abad1707caa0c97b4e4b167106b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a6984abad1707caa0c97b4e4b167106b3">cell_dim</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="memdesc:a6984abad1707caa0c97b4e4b167106b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return topological dimension of cell type. <br /></td></tr>
<tr class="separator:a6984abad1707caa0c97b4e4b167106b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2926fe64174120b2e865e0b7bf9946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abe2926fe64174120b2e865e0b7bf9946">cell_num_entities</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type, int dim)</td></tr>
<tr class="memdesc:abe2926fe64174120b2e865e0b7bf9946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entities of dimension dim.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abe2926fe64174120b2e865e0b7bf9946">More...</a><br /></td></tr>
<tr class="separator:abe2926fe64174120b2e865e0b7bf9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88526e97d1edbaacb8471c0e9288a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac88526e97d1edbaacb8471c0e9288a03">is_simplex</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="memdesc:ac88526e97d1edbaacb8471c0e9288a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cell is a simplex.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac88526e97d1edbaacb8471c0e9288a03">More...</a><br /></td></tr>
<tr class="separator:ac88526e97d1edbaacb8471c0e9288a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80294da14ab051e9f8eaf72080a7ee17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a80294da14ab051e9f8eaf72080a7ee17">num_cell_vertices</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> type)</td></tr>
<tr class="memdesc:a80294da14ab051e9f8eaf72080a7ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number vertices for a cell type.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a80294da14ab051e9f8eaf72080a7ee17">More...</a><br /></td></tr>
<tr class="separator:a80294da14ab051e9f8eaf72080a7ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd44e8136c15b9593dfdd87cd744c32"><td class="memItemLeft" align="right" valign="top"><a id="aacd44e8136c15b9593dfdd87cd744c32"></a>
std::map&lt; std::array&lt; int, 2 &gt;, std::vector&lt; std::set&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aacd44e8136c15b9593dfdd87cd744c32">cell_entity_closure</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> cell_type)</td></tr>
<tr class="memdesc:aacd44e8136c15b9593dfdd87cd744c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closure entities for a cell, i.e., all lower-dimensional entities attached to a cell entity. Map from entity {dim_e, entity_e} to closure{sub_dim, (sub_entities)}. <br /></td></tr>
<tr class="separator:aacd44e8136c15b9593dfdd87cd744c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="memItemLeft" align="right" valign="top"><a id="aa44a1bbf3077eacea89cf5f62c24fe68"></a>
basix::cell::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aa44a1bbf3077eacea89cf5f62c24fe68">cell_type_to_basix_type</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype)</td></tr>
<tr class="memdesc:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cell type to a Basix cell type. <br /></td></tr>
<tr class="separator:aa44a1bbf3077eacea89cf5f62c24fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c079ec392bf6c24c4879a67f53f4af8"><td class="memItemLeft" align="right" valign="top"><a id="a6c079ec392bf6c24c4879a67f53f4af8"></a>
<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a6c079ec392bf6c24c4879a67f53f4af8">cell_type_from_basix_type</a> (basix::cell::type celltype)</td></tr>
<tr class="memdesc:a6c079ec392bf6c24c4879a67f53f4af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cell type from a Basix cell type. <br /></td></tr>
<tr class="separator:a6c079ec392bf6c24c4879a67f53f4af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf90b06991e3e1dbfe69a536f5366da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5bf90b06991e3e1dbfe69a536f5366da">create_box</a> (MPI_Comm comm, const std::array&lt; std::array&lt; double, 3 &gt;, 2 &gt; &amp;p, std::array&lt; std::size_t, 3 &gt; n, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">mesh::CellPartitionFunction</a> &amp;partitioner=<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a>())</td></tr>
<tr class="memdesc:a5bf90b06991e3e1dbfe69a536f5366da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangular prism spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)*(n[2] + 1)</code>. For tetrahedra there will be will be <code>6*n[0]*n[1]*n[2]</code> cells. For hexahedra the number of cells will be <code>n[0]*n[1]*n[2]</code>.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5bf90b06991e3e1dbfe69a536f5366da">More...</a><br /></td></tr>
<tr class="separator:a5bf90b06991e3e1dbfe69a536f5366da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605bf1988871a529c632b64e67739140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a605bf1988871a529c632b64e67739140">create_interval</a> (MPI_Comm comm, std::size_t n, std::array&lt; double, 2 &gt; x, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> &amp;partitioner=<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a>())</td></tr>
<tr class="memdesc:a605bf1988871a529c632b64e67739140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval mesh of the 1D line <code>[a, b]</code>. Given <code>n</code> cells in the axial direction, the total number of intervals will be <code>n</code> and the total number of vertices will be <code>n + 1</code>.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a605bf1988871a529c632b64e67739140">More...</a><br /></td></tr>
<tr class="separator:a605bf1988871a529c632b64e67739140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c143b040987f2f4f7985b15e81eab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a03c143b040987f2f4f7985b15e81eab0">create_rectangle</a> (MPI_Comm comm, const std::array&lt; std::array&lt; double, 2 &gt;, 2 &gt; &amp;p, std::array&lt; std::size_t, 2 &gt; n, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right)</td></tr>
<tr class="memdesc:a03c143b040987f2f4f7985b15e81eab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a03c143b040987f2f4f7985b15e81eab0">More...</a><br /></td></tr>
<tr class="separator:a03c143b040987f2f4f7985b15e81eab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0edc2c6282954156661e6de401ca43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a4d0edc2c6282954156661e6de401ca43">create_rectangle</a> (MPI_Comm comm, const std::array&lt; std::array&lt; double, 2 &gt;, 2 &gt; &amp;p, std::array&lt; std::size_t, 2 &gt; n, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> celltype, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> &amp;partitioner, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a> diagonal=DiagonalType::right)</td></tr>
<tr class="memdesc:a4d0edc2c6282954156661e6de401ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a4d0edc2c6282954156661e6de401ca43">More...</a><br /></td></tr>
<tr class="separator:a4d0edc2c6282954156661e6de401ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c3ddb85f803374684b345439d5e686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a72c3ddb85f803374684b345439d5e686">create_geometry</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> &amp;element, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells, const std::span&lt; const double &gt; &amp;x, int dim, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn=nullptr)</td></tr>
<tr class="memdesc:a72c3ddb85f803374684b345439d5e686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a72c3ddb85f803374684b345439d5e686">More...</a><br /></td></tr>
<tr class="separator:a72c3ddb85f803374684b345439d5e686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a3288c50439bdb2cb71cc233823214"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a02a3288c50439bdb2cb71cc233823214">build_local_dual_graph</a> (const std::span&lt; const std::int64_t &gt; &amp;cells, const std::span&lt; const std::int32_t &gt; &amp;offsets, int tdim)</td></tr>
<tr class="memdesc:a02a3288c50439bdb2cb71cc233823214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the local part of the dual graph (cell-cell connections via facets) and facet with only one attached cell.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a02a3288c50439bdb2cb71cc233823214">More...</a><br /></td></tr>
<tr class="separator:a02a3288c50439bdb2cb71cc233823214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ea0c3dadb01d044dfb9f80ca6bd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ad66ea0c3dadb01d044dfb9f80ca6bd2f">build_dual_graph</a> (const MPI_Comm comm, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells, int tdim)</td></tr>
<tr class="memdesc:ad66ea0c3dadb01d044dfb9f80ca6bd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ad66ea0c3dadb01d044dfb9f80ca6bd2f">More...</a><br /></td></tr>
<tr class="separator:ad66ea0c3dadb01d044dfb9f80ca6bd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0e66b84417fea9607011f59962590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a3dd0e66b84417fea9607011f59962590">create_mesh</a> (MPI_Comm comm, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> &amp;element, std::span&lt; const double &gt; x, std::array&lt; std::size_t, 2 &gt; xshape, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a38d109d131f3180f43267fcf9fe9c4c4">GhostMode</a> ghost_mode)</td></tr>
<tr class="memdesc:a3dd0e66b84417fea9607011f59962590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh using the default partitioner.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a3dd0e66b84417fea9607011f59962590">More...</a><br /></td></tr>
<tr class="separator:a3dd0e66b84417fea9607011f59962590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876b1cd6515819d320092a5f20b579f4"><td class="memItemLeft" align="right" valign="top"><a id="a876b1cd6515819d320092a5f20b579f4"></a>
<a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a876b1cd6515819d320092a5f20b579f4">create_mesh</a> (MPI_Comm comm, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells, const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> &amp;element, std::span&lt; const double &gt; x, std::array&lt; std::size_t, 2 &gt; xshape, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> &amp;cell_partitioner)</td></tr>
<tr class="memdesc:a876b1cd6515819d320092a5f20b579f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mesh using a provided mesh partitioning function. <br /></td></tr>
<tr class="separator:a876b1cd6515819d320092a5f20b579f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6377819f6e59a7182e63dffcae592f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a2e6377819f6e59a7182e63dffcae592f">create_submesh</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::span&lt; const std::int32_t &gt; &amp;entities)</td></tr>
<tr class="memdesc:a2e6377819f6e59a7182e63dffcae592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new mesh consisting of a subset of entities in a mesh.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a2e6377819f6e59a7182e63dffcae592f">More...</a><br /></td></tr>
<tr class="separator:a2e6377819f6e59a7182e63dffcae592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e9d0c06ead392e0921473ce5d863b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59e9d0c06ead392e0921473ce5d863b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a59e9d0c06ead392e0921473ce5d863b7">create_meshtags</a> (std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &gt; mesh, int dim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;entities, const std::span&lt; const T &gt; &amp;values)</td></tr>
<tr class="memdesc:a59e9d0c06ead392e0921473ce5d863b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh entities.">MeshTags</a> from arrays.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a59e9d0c06ead392e0921473ce5d863b7">More...</a><br /></td></tr>
<tr class="separator:a59e9d0c06ead392e0921473ce5d863b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb806bcc85940ea4818196d210d7dff7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aeb806bcc85940ea4818196d210d7dff7">compute_entity_permutations</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="memdesc:aeb806bcc85940ea4818196d210d7dff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute (1) facet rotation and reflection data, and (2) cell permutation data. This information is used assemble of (1) facet inetgrals and (2) vector elements.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aeb806bcc85940ea4818196d210d7dff7">More...</a><br /></td></tr>
<tr class="separator:aeb806bcc85940ea4818196d210d7dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df7ee6ead2d5295a73fca44d65d316c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5df7ee6ead2d5295a73fca44d65d316c">create_topology</a> (MPI_Comm comm, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells, const std::span&lt; const std::int64_t &gt; &amp;original_cell_index, const std::span&lt; const int &gt; &amp;ghost_owners, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &amp;cell_type, const std::vector&lt; std::int64_t &gt; &amp;boundary_vertices)</td></tr>
<tr class="memdesc:a5df7ee6ead2d5295a73fca44d65d316c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed mesh topology.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5df7ee6ead2d5295a73fca44d65d316c">More...</a><br /></td></tr>
<tr class="separator:a5df7ee6ead2d5295a73fca44d65d316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32dfbd0b82df8d91e09ba654c6abd77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aa32dfbd0b82df8d91e09ba654c6abd77">entities_to_index</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;entities)</td></tr>
<tr class="memdesc:aa32dfbd0b82df8d91e09ba654c6abd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entity indices for entities defined by their vertices.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aa32dfbd0b82df8d91e09ba654c6abd77">More...</a><br /></td></tr>
<tr class="separator:aa32dfbd0b82df8d91e09ba654c6abd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a8bb59548f3a120365028ab2e76b17"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aa1a8bb59548f3a120365028ab2e76b17">compute_entities</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int dim)</td></tr>
<tr class="memdesc:aa1a8bb59548f3a120365028ab2e76b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh entities of given topological dimension by computing entity-to-vertex connectivity (dim, 0), and cell-to-entity connectivity (tdim, dim)  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aa1a8bb59548f3a120365028ab2e76b17">More...</a><br /></td></tr>
<tr class="separator:aa1a8bb59548f3a120365028ab2e76b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c4fa9d6d7c2783965c4f56216350a6"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#af1c4fa9d6d7c2783965c4f56216350a6">compute_connectivity</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology, int d0, int d1)</td></tr>
<tr class="memdesc:af1c4fa9d6d7c2783965c4f56216350a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connectivity (d0 -&gt; d1) for given pair of topological dimensions.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#af1c4fa9d6d7c2783965c4f56216350a6">More...</a><br /></td></tr>
<tr class="separator:af1c4fa9d6d7c2783965c4f56216350a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae41357d694f4aa69288c4e9c50d0ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aae41357d694f4aa69288c4e9c50d0ad2">extract_topology</a> (const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &amp;cell_type, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;layout, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cells)</td></tr>
<tr class="memdesc:aae41357d694f4aa69288c4e9c50d0ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract topology from cell data, i.e. extract cell vertices.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aae41357d694f4aa69288c4e9c50d0ad2">More...</a><br /></td></tr>
<tr class="separator:aae41357d694f4aa69288c4e9c50d0ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5b87af3153f98e1b053d94158feed5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abd5b87af3153f98e1b053d94158feed5">h</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, const std::span&lt; const std::int32_t &gt; &amp;entities, int dim)</td></tr>
<tr class="memdesc:abd5b87af3153f98e1b053d94158feed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute greatest distance between any two vertices of the mesh entities (<code>h</code>).  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abd5b87af3153f98e1b053d94158feed5">More...</a><br /></td></tr>
<tr class="separator:abd5b87af3153f98e1b053d94158feed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81d469ebf748bea2c2331e7ed78eda6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ab81d469ebf748bea2c2331e7ed78eda6">cell_normals</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::span&lt; const std::int32_t &gt; &amp;entities)</td></tr>
<tr class="memdesc:ab81d469ebf748bea2c2331e7ed78eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normal to given cell (viewed as embedded in 3D)  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ab81d469ebf748bea2c2331e7ed78eda6">More...</a><br /></td></tr>
<tr class="separator:ab81d469ebf748bea2c2331e7ed78eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5c5cf87e2225c2f105a5819b97e2c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a35e5c5cf87e2225c2f105a5819b97e2c">compute_midpoints</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::span&lt; const std::int32_t &gt; &amp;entities)</td></tr>
<tr class="memdesc:a35e5c5cf87e2225c2f105a5819b97e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the midpoints for mesh entities of a given dimension.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a35e5c5cf87e2225c2f105a5819b97e2c">More...</a><br /></td></tr>
<tr class="separator:a35e5c5cf87e2225c2f105a5819b97e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0496282ac2613c4448097610b7d90f62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a0496282ac2613c4448097610b7d90f62">locate_entities</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::function&lt; std::vector&lt; std::int8_t &gt;(std::experimental::mdspan&lt; const double, std::experimental::extents&lt; std::size_t, 3, std::experimental::dynamic_extent &gt;&gt;)&gt; &amp;marker)</td></tr>
<tr class="memdesc:a0496282ac2613c4448097610b7d90f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that evaluate to true for the provided geometric marking function. An entity is considered marked if the marker function evaluates true for all of its vertices.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a0496282ac2613c4448097610b7d90f62">More...</a><br /></td></tr>
<tr class="separator:a0496282ac2613c4448097610b7d90f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791f3002700f19e0393c3eab2a863f8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5791f3002700f19e0393c3eab2a863f8">locate_entities_boundary</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::function&lt; std::vector&lt; std::int8_t &gt;(std::experimental::mdspan&lt; const double, std::experimental::extents&lt; std::size_t, 3, std::experimental::dynamic_extent &gt;&gt;)&gt; &amp;marker)</td></tr>
<tr class="memdesc:a5791f3002700f19e0393c3eab2a863f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function. An entity is considered marked if the marker function evaluates true for all of its vertices.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5791f3002700f19e0393c3eab2a863f8">More...</a><br /></td></tr>
<tr class="separator:a5791f3002700f19e0393c3eab2a863f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadacffd7341b5a10571e785d50250918"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aadacffd7341b5a10571e785d50250918">entities_to_geometry</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, int dim, const std::span&lt; const std::int32_t &gt; &amp;entities, bool orient)</td></tr>
<tr class="memdesc:aadacffd7341b5a10571e785d50250918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the indices in the geometry data for each vertex of the given mesh entities.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aadacffd7341b5a10571e785d50250918">More...</a><br /></td></tr>
<tr class="separator:aadacffd7341b5a10571e785d50250918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abcd805c0f4a1ee1533a6b05417ddcaa1">exterior_facet_indices</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;topology)</td></tr>
<tr class="memdesc:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indices of all exterior facets that are owned by the caller.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#abcd805c0f4a1ee1533a6b05417ddcaa1">More...</a><br /></td></tr>
<tr class="separator:abcd805c0f4a1ee1533a6b05417ddcaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22d3fa3023edcd8cdd5d8550b19484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a> (<a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a> ghost_mode=mesh::GhostMode::none, const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a762d023211be837448a62f229e1bc4a8">graph::partition_fn</a> &amp;partfn=&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a>)</td></tr>
<tr class="memdesc:aff22d3fa3023edcd8cdd5d8550b19484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function that computes destination rank for mesh cells in this rank by applying the default graph partitioner to the dual graph of the mesh.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">More...</a><br /></td></tr>
<tr class="separator:aff22d3fa3023edcd8cdd5d8550b19484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab326ca5634a9a06d712e2dee29ea04b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ab326ca5634a9a06d712e2dee29ea04b9">compute_incident_entities</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;mesh, const std::span&lt; const std::int32_t &gt; &amp;entities, int d0, int d1)</td></tr>
<tr class="memdesc:ab326ca5634a9a06d712e2dee29ea04b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute incident indices.  <a href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ab326ca5634a9a06d712e2dee29ea04b9">More...</a><br /></td></tr>
<tr class="separator:ab326ca5634a9a06d712e2dee29ea04b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> data structures and algorithms on meshes. </p>
<p>Representations of meshes and support for operations on meshes. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae047b9fda4fdc9c521b6c1725480a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae047b9fda4fdc9c521b6c1725480a582">&#9670;&nbsp;</a></span>CellPartitionFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> =  std::function&lt;<a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">dolfinx::graph::AdjacencyList</a>&lt;std::int32_t&gt;( MPI_Comm comm, int nparts, int tdim, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">dolfinx::graph::AdjacencyList</a>&lt;std::int64_t&gt;&amp; cells)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for the cell partitioning function. The function should compute the destination rank for cells currently on this rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nparts</td><td>Number of partitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tdim</td><td>Topological dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Cells on this process. The ith entry in list contains the global indices for the cell vertices. Each cell can appear only once across all processes. The cell vertex indices are not necessarily contiguous globally, i.e. the maximum index across all processes can be greater than the number of vertices. High-order 'nodes', e.g. mid-side points, should not be included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>How to overlap the cell partitioning: none, shared_facet or shared_vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destination ranks for each cell on this process </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad66ea0c3dadb01d044dfb9f80ca6bd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66ea0c3dadb01d044dfb9f80ca6bd2f">&#9670;&nbsp;</a></span>build_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; build_dual_graph </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build distributed mesh dual graph (cell-cell connections via facets) from minimal mesh data. </p>
<p>The computed dual graph is typically passed to a graph partitioner.</p>
<dl class="section note"><dt>Note</dt><dd>Collective function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Collection of cells, defined by the cell vertices from which to build the dual graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tdim</td><td>The topological dimension of the cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dual graph </dd></dl>

</div>
</div>
<a id="a02a3288c50439bdb2cb71cc233823214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a3288c50439bdb2cb71cc233823214">&#9670;&nbsp;</a></span>build_local_dual_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;, std::vector&lt; std::int64_t &gt;, std::size_t, std::vector&lt; std::int32_t &gt; &gt; build_local_dual_graph </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the local part of the dual graph (cell-cell connections via facets) and facet with only one attached cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Array for cell vertices adjacency list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Adjacency list offsets, i.e. index of the first entry of cell <code>i</code> in <code>cell_vertices</code> <code>is offsets[i]</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tdim</td><td>The topological dimension of the cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ol type="1">
<li>Local dual graph</li>
<li>Facets, defined by their vertices, that are shared by only one cell on this rank. The logically 2D is array flattened (row-major).</li>
<li>The number of columns for the facet data array (2).</li>
<li>The attached cell (local index) to each returned facet in (2).</li>
</ol>
</dd></dl>
<p>Each row of the returned data (2) contains <code>[v0, ... v_(n-1), x, .., x]</code>, where <code>v_i</code> is a vertex global index, <code>x</code> is a padding value (all padding values will be equal).</p>
<dl class="section note"><dt>Note</dt><dd>The return data will likely change once we support mixed topology meshes. </dd></dl>

</div>
</div>
<a id="a66c376aedd08ad2dab6f13eba56b6f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c376aedd08ad2dab6f13eba56b6f36">&#9670;&nbsp;</a></span>cell_facet_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">mesh::CellType</a> cell_facet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return facet type of cell For simplex and hypercube cell types, this is independent of the facet index, but for prism and pyramid, it can be triangle or quadrilateral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The facet index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of facet for this cell at this index </dd></dl>

</div>
</div>
<a id="ab81d469ebf748bea2c2331e7ed78eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81d469ebf748bea2c2331e7ed78eda6">&#9670;&nbsp;</a></span>cell_normals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cell_normals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute normal to given cell (viewed as embedded in 3D) </p>
<dl class="section return"><dt>Returns</dt><dd>The entity normals. The shape is <code>(entities.size(), 3)</code> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="abe2926fe64174120b2e865e0b7bf9946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2926fe64174120b2e865e0b7bf9946">&#9670;&nbsp;</a></span>cell_num_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cell_num_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of entities of dimension dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Entity dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entities in cell </dd></dl>

</div>
</div>
<a id="af1c4fa9d6d7c2783965c4f56216350a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c4fa9d6d7c2783965c4f56216350a6">&#9670;&nbsp;</a></span>compute_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, 2 &gt; compute_connectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connectivity (d0 -&gt; d1) for given pair of topological dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>The dimension of the nodes in the adjacency list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>The dimension of the edges in the adjacency list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The connectivities [(d0, d1), (d1, d0)] if they are computed. If (d0, d1) already exists then a nullptr is returned. If (d0, d1) is computed and the computation of (d1, d0) was required as part of computing (d0, d1), the (d1, d0) is returned as the second entry. The second entry is otherwise nullptr. </dd></dl>

</div>
</div>
<a id="aa1a8bb59548f3a120365028ab2e76b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a8bb59548f3a120365028ab2e76b17">&#9670;&nbsp;</a></span>compute_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;, std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, std::vector&lt; std::int32_t &gt; &gt; compute_entities </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mesh entities of given topological dimension by computing entity-to-vertex connectivity (dim, 0), and cell-to-entity connectivity (tdim, dim) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of the entities to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (cell-entity connectivity, entity-vertex connectivity, index map, list of interprocess entities). Interprocess entities lie on the "true" boundary between owned cells of each process. If the entities already exist, then {nullptr, nullptr, nullptr, std::vector()} is returned. </dd></dl>

</div>
</div>
<a id="aeb806bcc85940ea4818196d210d7dff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb806bcc85940ea4818196d210d7dff7">&#9670;&nbsp;</a></span>compute_entity_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::uint8_t &gt;, std::vector&lt; std::uint32_t &gt; &gt; compute_entity_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute (1) facet rotation and reflection data, and (2) cell permutation data. This information is used assemble of (1) facet inetgrals and (2) vector elements. </p>
<ol type="1">
<li><p class="startli">Get the permutation numbers to apply to facets. The permutations are numbered so that:</p><ul>
<li><code>n % 2</code> gives the number of reflections to apply</li>
<li><code>n // 2</code> gives the number of rotations to apply</li>
</ul>
<p class="startli">Each column of the returned array represents a cell, and each row a facet of that cell. This data is used to permute the quadrature point on facet integrals when data from the cells on both sides of the facet is used.</p>
</li>
<li><p class="startli">Get the permutation information about the entities of each cell, relative to a low-to-high ordering. This data is packed so that a 32 bit int is used for each cell. For 2D cells, one bit is used for each edge, to represent whether or not the edge is reversed: the least significant bit is for edge 0, the next for edge 1, etc. For 3D cells, three bits are used for each face, and for each edge: the least significant bit says whether or not face 0 is reflected, the next 2 bits say how many times face 0 is rotated; the next three bits are for face 1, then three for face 2, etc; after all the faces, there is 1 bit for each edge to say whether or not they are reversed.</p>
<p class="startli">For example, if a quadrilateral has cell permutation info <code>....0111</code> then (from right to left):</p><ul>
<li>edge 0 is reflected (1)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is reflected (1)</li>
<li>edge 3 is not permuted (0)</li>
</ul>
<p class="startli">and if a tetrahedron has cell permutation info <code>....011010010101001000</code> then (from right to left):</p><ul>
<li>face 0 is not permuted (000)</li>
<li>face 1 is reflected (001)</li>
<li>face 2 is rotated twice then reflected (101)</li>
<li>face 3 is rotated once (010)</li>
<li>edge 0 is not permuted (0)</li>
<li>edge 1 is reflected (1)</li>
<li>edge 2 is not permuted (0)</li>
<li>edge 3 is reflected (1)</li>
<li>edge 4 is reflected (1)</li>
<li>edge 5 is not permuted (0)</li>
</ul>
<p class="startli">This data is used to correct the direction of vector function on permuted facets.</p>
</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Facet permutation and cells permutations </dd></dl>

</div>
</div>
<a id="ab326ca5634a9a06d712e2dee29ea04b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab326ca5634a9a06d712e2dee29ea04b9">&#9670;&nbsp;</a></span>compute_incident_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_incident_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute incident indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of indices of topological dimension <code>d0</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d0</td><td>Topological dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d1</td><td>Topological dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of entities of topological dimension <code>d1</code> that are incident to entities in <code>entities</code> (topological dimension <code>d0</code>) </dd></dl>

</div>
</div>
<a id="a35e5c5cf87e2225c2f105a5819b97e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e5c5cf87e2225c2f105a5819b97e2c">&#9670;&nbsp;</a></span>compute_midpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; compute_midpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the midpoints for mesh entities of a given dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>The entity midpoints. The shape is <code>(entities.size(), 3)</code> and the storage is row-major. </dd></dl>

</div>
</div>
<a id="a5bf90b06991e3e1dbfe69a536f5366da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf90b06991e3e1dbfe69a536f5366da">&#9670;&nbsp;</a></span>create_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> create_box </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 3 &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 3 &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>celltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">mesh::CellPartitionFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangular prism spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)*(n[2] + 1)</code>. For tetrahedra there will be will be <code>6*n[0]*n[1]*n[2]</code> cells. For hexahedra the number of cells will be <code>n[0]*n[1]*n[2]</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Points of box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function to use for determining the parallel distribution of cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="aff22d3fa3023edcd8cdd5d8550b19484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff22d3fa3023edcd8cdd5d8550b19484">&#9670;&nbsp;</a></span>create_cell_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">mesh::CellPartitionFunction</a> create_cell_partitioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a>&#160;</td>
          <td class="paramname"><em>ghost_mode</em> = <code>mesh::GhostMode::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#a762d023211be837448a62f229e1bc4a8">graph::partition_fn</a> &amp;&#160;</td>
          <td class="paramname"><em>partfn</em> = <code>&amp;<a class="el" href="../../d9/d69/namespacedolfinx_1_1graph.html#ab7912ac9b196655f4fc4189efa96d794">graph::partition_graph</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function that computes destination rank for mesh cells in this rank by applying the default graph partitioner to the dual graph of the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Function that computes the destination ranks for each cell </dd></dl>

</div>
</div>
<a id="a72c3ddb85f803374684b345439d5e686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c3ddb85f803374684b345439d5e686">&#9670;&nbsp;</a></span>create_geometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html">mesh::Geometry</a> create_geometry </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> from input data. </p>
<p>This function should be called after the mesh topology is built. It distributes the 'node' coordinate data to the required <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> process and then creates a <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">mesh::Geometry</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the <a class="el" href="../../d8/dfb/classdolfinx_1_1mesh_1_1Geometry.html" title="Geometry stores the geometry imposed on a mesh.">Geometry</a> on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element that defines the geometry map for each cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>The mesh cells, including higher-order geometry 'nodes' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The node coordinates (row-major, with shape <code>(num_nodes, dim)</code>. The global index of each node is <code>i + rank_offset</code>, where <code>i</code> is the local row index in <code>x</code> and <code>rank_offset</code> is the sum of <code>x</code> rows on all processed with a lower rank than the caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The geometric dimension (1, 2, or 3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Function for re-ordering the degree-of-freedom map associated with the geometry data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a605bf1988871a529c632b64e67739140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605bf1988871a529c632b64e67739140">&#9670;&nbsp;</a></span>create_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> create_interval </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#aff22d3fa3023edcd8cdd5d8550b19484">create_cell_partitioner</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval mesh of the 1D line <code>[a, b]</code>. Given <code>n</code> cells in the axial direction, the total number of intervals will be <code>n</code> and the total number of vertices will be <code>n + 1</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The end points of the interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function to use for determining the parallel distribution of cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh </dd></dl>

</div>
</div>
<a id="a3dd0e66b84417fea9607011f59962590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd0e66b84417fea9607011f59962590">&#9670;&nbsp;</a></span>create_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> create_mesh </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>xshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a38d109d131f3180f43267fcf9fe9c4c4">mesh::GhostMode</a>&#160;</td>
          <td class="paramname"><em>ghost_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mesh using the default partitioner. </p>
<p>This function takes mesh input data that is distributed across processes and creates a <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a>, with the mesh cell distribution determined by the default cell partitioner. The default partitioner is based a graph partitioning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>The cells on the this <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank. Each cell (node in the <code>AdjacencyList</code>) is defined by its 'nodes' (using global indices). For lowest order cells this will be just the cell vertices. For higher-order cells, other cells 'nodes' will be included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The coordinate element that describes the geometric mapping for cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The coordinates of mesh nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xshape</td><td>The shape of <code>x</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>The requested type of cell ghosting/overlap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distributed <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a>. </dd></dl>

</div>
</div>
<a id="a59e9d0c06ead392e0921473ce5d863b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e9d0c06ead392e0921473ce5d863b7">&#9670;&nbsp;</a></span>create_meshtags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">MeshTags</a>&lt;T&gt; dolfinx::mesh::create_meshtags </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html" title="MeshTags associate values with mesh entities.">MeshTags</a> from arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> that the tags are associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of tagged entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Local vertex indices for tagged entities.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Tag values for each entity in <code>entities</code>. The length of <code>values</code> must be equal to number of rows in <code>entities</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entities that do not exist on this rank are ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>entities</code> must not contain duplicate entities. </dd></dl>

</div>
</div>
<a id="a4d0edc2c6282954156661e6de401ca43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0edc2c6282954156661e6de401ca43">&#9670;&nbsp;</a></span>create_rectangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 2 &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>celltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ae047b9fda4fdc9c521b6c1725480a582">CellPartitionFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a>&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>DiagonalType::right</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Two corner points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitioner</td><td>Partitioning function to use for determining the parallel distribution of cells across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a03c143b040987f2f4f7985b15e81eab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c143b040987f2f4f7985b15e81eab0">&#9670;&nbsp;</a></span>create_rectangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> create_rectangle </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 2 &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; std::size_t, 2 &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>celltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a5fb0494804cb9b4baeeff5b9027a8dfd">DiagonalType</a>&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>DiagonalType::right</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">mesh::Mesh</a> over the rectangle spanned by the two points <code>p</code>. The order of the two points is not important in terms of minimum and maximum coordinates. The total number of vertices will be <code>(n[0] + 1)*(n[1] + 1)</code>. For triangles there will be will be <code>2*n[0]*n[1]</code> cells. For quadrilaterals the number of cells will be <code>n[0]*n[1]</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator to build the mesh on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Two corner points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of cells in each direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">celltype</td><td>Cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>Direction of diagonals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html" title="A Mesh consists of a set of connected and numbered mesh topological entities, and geometry data.">Mesh</a> </dd></dl>

</div>
</div>
<a id="a2e6377819f6e59a7182e63dffcae592f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6377819f6e59a7182e63dffcae592f">&#9670;&nbsp;</a></span>create_submesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a>, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt; &gt; create_submesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new mesh consisting of a subset of entities in a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Entity dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of entity indices in <code>mesh</code> to include in the new mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new mesh, and maps from the new mesh entities, vertices, and geometry to the input mesh entities, vertices, and geometry. </dd></dl>

</div>
</div>
<a id="a5df7ee6ead2d5295a73fca44d65d316c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df7ee6ead2d5295a73fca44d65d316c">&#9670;&nbsp;</a></span>create_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> create_topology </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>original_cell_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_owners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed mesh topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator across which the topology is distributed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>The cell topology (list of vertices for each cell) using global indices for the vertices. It contains cells that have been distributed to this rank, e.g. via a graph partitioner. It must also contain all ghost cells via facet, i.e. cells that are on a neighboring process and share a facet with a local cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_cell_index</td><td>The original global index associated with each cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_owners</td><td>The owning rank of each ghost cell (ghost cells are always at the end of the list of <code>cells</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_vertices</td><td>List of vertices on the exterior of the local mesh which may be shared with other processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A distributed mesh topology </dd></dl>

</div>
</div>
<a id="aadacffd7341b5a10571e785d50250918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadacffd7341b5a10571e785d50250918">&#9670;&nbsp;</a></span>entities_to_geometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; entities_to_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the indices in the geometry data for each vertex of the given mesh entities. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be used unless there is no alternative. It may be removed in the future.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Entity indices (local) to compute the vertex geometry indices for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orient</td><td>If true, in 3D, reorients facets to have consistent normal direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices in the geometry array for the entity vertices. The shape is <code>(num_entities, num_vertices_per_entity)</code> and the storage is row-major. The index <code>indices[i, j]</code> is the position in the geometry array of the <code>j</code>-th vertex of the <code>entity[i]</code>. </dd></dl>

</div>
</div>
<a id="aa32dfbd0b82df8d91e09ba654c6abd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32dfbd0b82df8d91e09ba654c6abd77">&#9670;&nbsp;</a></span>entities_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; entities_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get entity indices for entities defined by their vertices. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function may be removed in the future.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>The mesh entities defined by their vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the ith entity in <code>entities</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an entity cannot be found on this rank, -1 is returned as the index. </dd></dl>

</div>
</div>
<a id="abcd805c0f4a1ee1533a6b05417ddcaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd805c0f4a1ee1533a6b05417ddcaa1">&#9670;&nbsp;</a></span>exterior_facet_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; exterior_facet_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the indices of all exterior facets that are owned by the caller. </p>
<p>An exterior facet (co-dimension 1) is one that is connected globally to only one cell of co-dimension 0).</p>
<dl class="section note"><dt>Note</dt><dd>Collective</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted list of owned facet indices that are exterior facets of the mesh. </dd></dl>

</div>
</div>
<a id="aae41357d694f4aa69288c4e9c50d0ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae41357d694f4aa69288c4e9c50d0ad2">&#9670;&nbsp;</a></span>extract_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; extract_topology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract topology from cell data, i.e. extract cell vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_type</td><td>The cell shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The layout of geometry 'degrees-of-freedom' on the reference cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>List of 'nodes' for each cell using global indices. The layout must be consistent with <code>layout</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell topology. The global indices will, in general, have 'gaps' due to mid-side and other higher-order nodes being removed from the input <code>cell</code>. </dd></dl>

</div>
</div>
<a id="abd5b87af3153f98e1b053d94158feed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5b87af3153f98e1b053d94158feed5">&#9670;&nbsp;</a></span>h()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute greatest distance between any two vertices of the mesh entities (<code>h</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh that the entities belong to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices (local to process) of entities to compute <code>h</code> for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest distance between any two vertices, <code>h[i]</code> corresponds to the entity <code>entities[i]</code>. </dd></dl>

</div>
</div>
<a id="ac88526e97d1edbaacb8471c0e9288a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88526e97d1edbaacb8471c0e9288a03">&#9670;&nbsp;</a></span>is_simplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if cell is a simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is the cell type is a simplex </dd></dl>

</div>
</div>
<a id="a0496282ac2613c4448097610b7d90f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0496282ac2613c4448097610b7d90f62">&#9670;&nbsp;</a></span>locate_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; std::int8_t &gt;(std::experimental::mdspan&lt; const double, std::experimental::extents&lt; std::size_t, 3, std::experimental::dynamic_extent &gt;&gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that evaluate to true for the provided geometric marking function. An entity is considered marked if the marker function evaluates true for all of its vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The topological dimension of the entities to be considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>The marking function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices, including any ghost indices (indices local to the process) </dd></dl>

</div>
</div>
<a id="a5791f3002700f19e0393c3eab2a863f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5791f3002700f19e0393c3eab2a863f8">&#9670;&nbsp;</a></span>locate_entities_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; locate_entities_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; std::int8_t &gt;(std::experimental::mdspan&lt; const double, std::experimental::extents&lt; std::size_t, 3, std::experimental::dynamic_extent &gt;&gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute indices of all mesh entities that are attached to an owned boundary facet and evaluate to true for the provided geometric marking function. An entity is considered marked if the marker function evaluates true for all of its vertices. </p>
<dl class="section note"><dt>Note</dt><dd>For vertices and edges, in parallel this function will not necessarily mark all entities that are on the exterior boundary. For example, it is possible for a process to have a vertex that lies on the boundary without any of the attached facets being a boundary facet. When used to find degrees-of-freedom, e.g. using <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60a660b9cb06c6b0e24bee6b6149c00d" title="Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-o...">fem::locate_dofs_topological</a>, the function that uses the data returned by this function must typically perform some parallel communication.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The topological dimension of the entities to be considered. Must be less than the topological dimension of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>The marking function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of marked entity indices (indices local to the process) </dd></dl>

</div>
</div>
<a id="a80294da14ab051e9f8eaf72080a7ee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80294da14ab051e9f8eaf72080a7ee17">&#9670;&nbsp;</a></span>num_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_cell_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number vertices for a cell type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of cell vertices </dd></dl>

</div>
</div>
<a id="ae1f0961be83abe152e146c14c8f8548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0961be83abe152e146c14c8f8548a">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">CellType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cell string type for a cell type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The cell type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type string </dd></dl>

</div>
</div>
<a id="aec82a925447a9da2a086b7c93739ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec82a925447a9da2a086b7c93739ba9c">&#9670;&nbsp;</a></span>to_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#ac3c2cbbef08f3b7ddc3b06c6bd5a2271">mesh::CellType</a> to_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cell type from a cell string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>Cell shape string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cell type </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

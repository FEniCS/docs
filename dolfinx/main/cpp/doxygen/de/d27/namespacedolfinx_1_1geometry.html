<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::geometry Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.8.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../de/d27/namespacedolfinx_1_1geometry.html">geometry</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::geometry Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Geometry data structures and algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6e9a1509ba99e06bb4b855d7f0a84aeb" id="r_a6e9a1509ba99e06bb4b855d7f0a84aeb"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a6e9a1509ba99e06bb4b855d7f0a84aeb"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e9a1509ba99e06bb4b855d7f0a84aeb">compute_distance_gjk</a> (std::span&lt; const T &gt; p, std::span&lt; const T &gt; q)</td></tr>
<tr class="memdesc:a6e9a1509ba99e06bb4b855d7f0a84aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two convex bodies p and q, each defined by a set of points.  <br /></td></tr>
<tr class="separator:a6e9a1509ba99e06bb4b855d7f0a84aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d940af5450d864a8acb9093330d5d31" id="r_a6d940af5450d864a8acb9093330d5d31"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a6d940af5450d864a8acb9093330d5d31"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d940af5450d864a8acb9093330d5d31">shortest_vector</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities, std::span&lt; const T &gt; points)</td></tr>
<tr class="memdesc:a6d940af5450d864a8acb9093330d5d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shortest vector from a mesh entity to a point.  <br /></td></tr>
<tr class="separator:a6d940af5450d864a8acb9093330d5d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ebde91c8a857becbe22ab096f1e940" id="r_a51ebde91c8a857becbe22ab096f1e940"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a51ebde91c8a857becbe22ab096f1e940"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51ebde91c8a857becbe22ab096f1e940">compute_squared_distance_bbox</a> (std::span&lt; const T, 6 &gt; b, std::span&lt; const T, 3 &gt; x)</td></tr>
<tr class="memdesc:a51ebde91c8a857becbe22ab096f1e940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute squared distance between point and bounding box.  <br /></td></tr>
<tr class="separator:a51ebde91c8a857becbe22ab096f1e940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f3829b2339546f6cc63b02e8e3cdd" id="r_a371f3829b2339546f6cc63b02e8e3cdd"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a371f3829b2339546f6cc63b02e8e3cdd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a371f3829b2339546f6cc63b02e8e3cdd">squared_distance</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, int dim, std::span&lt; const std::int32_t &gt; entities, std::span&lt; const T &gt; points)</td></tr>
<tr class="memdesc:a371f3829b2339546f6cc63b02e8e3cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared distance between a point and a mesh entity.  <br /></td></tr>
<tr class="separator:a371f3829b2339546f6cc63b02e8e3cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959bc4c31dca8e4a4e18757c299014e0" id="r_a959bc4c31dca8e4a4e18757c299014e0"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a959bc4c31dca8e4a4e18757c299014e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a959bc4c31dca8e4a4e18757c299014e0">create_midpoint_tree</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, int tdim, std::span&lt; const std::int32_t &gt; entities)</td></tr>
<tr class="memdesc:a959bc4c31dca8e4a4e18757c299014e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bounding box tree for the midpoints of a subset of entities.  <br /></td></tr>
<tr class="separator:a959bc4c31dca8e4a4e18757c299014e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1527656969a2a27f37908b2721a210" id="r_a3b1527656969a2a27f37908b2721a210"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a3b1527656969a2a27f37908b2721a210"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b1527656969a2a27f37908b2721a210">compute_collisions</a> (const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;tree0, const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;tree1)</td></tr>
<tr class="memdesc:a3b1527656969a2a27f37908b2721a210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all collisions between two bounding box trees.  <br /></td></tr>
<tr class="separator:a3b1527656969a2a27f37908b2721a210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae098a182e61a4850db03c308103189c9" id="r_ae098a182e61a4850db03c308103189c9"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:ae098a182e61a4850db03c308103189c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae098a182e61a4850db03c308103189c9">compute_collisions</a> (const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;tree, std::span&lt; const T &gt; points)</td></tr>
<tr class="memdesc:ae098a182e61a4850db03c308103189c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute collisions between points and leaf bounding boxes.  <br /></td></tr>
<tr class="separator:ae098a182e61a4850db03c308103189c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f865ea932e7df7e609dd52c4a7e02b0" id="r_a3f865ea932e7df7e609dd52c4a7e02b0"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a3f865ea932e7df7e609dd52c4a7e02b0"><td class="memTemplItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f865ea932e7df7e609dd52c4a7e02b0">compute_first_colliding_cell</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, std::span&lt; const std::int32_t &gt; cells, std::array&lt; T, 3 &gt; point, T tol)</td></tr>
<tr class="memdesc:a3f865ea932e7df7e609dd52c4a7e02b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of cells, find the first one that collides with a point.  <br /></td></tr>
<tr class="separator:a3f865ea932e7df7e609dd52c4a7e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba39679ca3d1379dac0dd9ca283848d8" id="r_aba39679ca3d1379dac0dd9ca283848d8"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:aba39679ca3d1379dac0dd9ca283848d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba39679ca3d1379dac0dd9ca283848d8">compute_closest_entity</a> (const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;tree, const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;midpoint_tree, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, std::span&lt; const T &gt; points)</td></tr>
<tr class="memdesc:aba39679ca3d1379dac0dd9ca283848d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute closest mesh entity to a point.  <br /></td></tr>
<tr class="separator:aba39679ca3d1379dac0dd9ca283848d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592bcd23f2c31129b4856e3eb9f8f248" id="r_a592bcd23f2c31129b4856e3eb9f8f248"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:a592bcd23f2c31129b4856e3eb9f8f248"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a592bcd23f2c31129b4856e3eb9f8f248">compute_colliding_cells</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;candidate_cells, std::span&lt; const T &gt; points)</td></tr>
<tr class="memdesc:a592bcd23f2c31129b4856e3eb9f8f248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute which cells collide with a point.  <br /></td></tr>
<tr class="separator:a592bcd23f2c31129b4856e3eb9f8f248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcaaf846e453c74450550c0b7f4a360" id="r_aadcaaf846e453c74450550c0b7f4a360"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T&gt; </td></tr>
<tr class="memitem:aadcaaf846e453c74450550c0b7f4a360"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadcaaf846e453c74450550c0b7f4a360">determine_point_ownership</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;mesh, std::span&lt; const T &gt; points, T padding)</td></tr>
<tr class="memdesc:aadcaaf846e453c74450550c0b7f4a360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, determine which process is colliding, using the GJK algorithm on cells to determine collisions.  <br /></td></tr>
<tr class="separator:aadcaaf846e453c74450550c0b7f4a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Geometry data structures and algorithms. </p>
<p>Tools for geometric data structures and operations, e.g. searching. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aba39679ca3d1379dac0dd9ca283848d8" name="aba39679ca3d1379dac0dd9ca283848d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba39679ca3d1379dac0dd9ca283848d8">&#9670;&#160;</a></span>compute_closest_entity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_closest_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>midpoint_tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute closest mesh entity to a point. </p>
<dl class="section note"><dt>Note</dt><dd>Returns a vector filled with index -1 if the bounding box tree is empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>The bounding box tree for the entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">midpoint_tree</td><td>A bounding box tree with the midpoints of all the mesh entities. This is used to accelerate the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The set of points (<code>shape=(num_points, 3)</code>). Storage is row-major. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each point, the index of the closest mesh entity. </dd></dl>

</div>
</div>
<a id="a592bcd23f2c31129b4856e3eb9f8f248" name="a592bcd23f2c31129b4856e3eb9f8f248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592bcd23f2c31129b4856e3eb9f8f248">&#9670;&#160;</a></span>compute_colliding_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; compute_colliding_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate_cells</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute which cells collide with a point. </p>
<dl class="section note"><dt>Note</dt><dd>Uses the GJK algorithm, see <a class="el" href="#a6e9a1509ba99e06bb4b855d7f0a84aeb" title="Compute the distance between two convex bodies p and q, each defined by a set of points.">geometry::compute_distance_gjk</a> for details.</dd>
<dd>
<code>candidate_cells</code> can for instance be found by using <code><a class="el" href="#a3b1527656969a2a27f37908b2721a210" title="Compute all collisions between two bounding box trees.">dolfinx::geometry::compute_collisions</a></code> between a bounding box tree and the set of points.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">candidate_cells</td><td>List of candidate colliding cells for the ith point in <code>points</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Points to check for collision (<code>shape=(num_points, 3)</code>). Storage is row-major. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each point, the cells that collide with the point. </dd></dl>

</div>
</div>
<a id="ae098a182e61a4850db03c308103189c9" name="ae098a182e61a4850db03c308103189c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae098a182e61a4850db03c308103189c9">&#9670;&#160;</a></span>compute_collisions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; compute_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute collisions between points and leaf bounding boxes. </p>
<p>Bounding boxes can overlap, therefore points can collide with more than one box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>The bounding box tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The points (<code>shape=(num_points, 3)</code>). Storage is row-major. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For each point, the bounding box leaves that collide with the point. </dd></dl>

</div>
</div>
<a id="a3b1527656969a2a27f37908b2721a210" name="a3b1527656969a2a27f37908b2721a210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1527656969a2a27f37908b2721a210">&#9670;&#160;</a></span>compute_collisions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; compute_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all collisions between two bounding box trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree0</td><td>First <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree1</td><td>Second <a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of pairs of intersecting box indices from each tree, flattened as a vector of size num_intersections*2 </dd></dl>

</div>
</div>
<a id="a6e9a1509ba99e06bb4b855d7f0a84aeb" name="a6e9a1509ba99e06bb4b855d7f0a84aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9a1509ba99e06bb4b855d7f0a84aeb">&#9670;&#160;</a></span>compute_distance_gjk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; compute_distance_gjk </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two convex bodies p and q, each defined by a set of points. </p>
<p>Uses the Gilbert–Johnson–Keerthi (GJK) distance algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Body 1 list of points, shape (num_points, 3). Row-major storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Body 2 list of points, shape (num_points, 3). Row-major storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shortest vector between bodies </dd></dl>

</div>
</div>
<a id="a3f865ea932e7df7e609dd52c4a7e02b0" name="a3f865ea932e7df7e609dd52c4a7e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f865ea932e7df7e609dd52c4a7e02b0">&#9670;&#160;</a></span>compute_first_colliding_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t compute_first_colliding_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>cells</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>point</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of cells, find the first one that collides with a point. </p>
<p>A point can collide with more than one cell. The first cell detected to collide with the point is returned. If no collision is detected, -1 is returned.</p>
<dl class="section note"><dt>Note</dt><dd><code>cells</code> can for instance be found by using <code><a class="el" href="#a3b1527656969a2a27f37908b2721a210" title="Compute all collisions between two bounding box trees.">dolfinx::geometry::compute_collisions</a></code> between a bounding box tree for the cells of the mesh and the point.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>The candidate cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point (<code>shape=(3,)</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Tolerance for accepting a collision (in the squared distance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local cell index, -1 if not found </dd></dl>

</div>
</div>
<a id="a51ebde91c8a857becbe22ab096f1e940" name="a51ebde91c8a857becbe22ab096f1e940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ebde91c8a857becbe22ab096f1e940">&#9670;&#160;</a></span>compute_squared_distance_bbox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T compute_squared_distance_bbox </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const T, 6 &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T, 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute squared distance between point and bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Bounding box coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shortest distance between the bounding box <code>b</code> and the point <code>x</code>. Returns zero if <code>x</code> is inside box. </dd></dl>

</div>
</div>
<a id="a959bc4c31dca8e4a4e18757c299014e0" name="a959bc4c31dca8e4a4e18757c299014e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959bc4c31dca8e4a4e18757c299014e0">&#9670;&#160;</a></span>create_midpoint_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/ddc/classdolfinx_1_1geometry_1_1BoundingBoxTree.html">BoundingBoxTree</a>&lt; T &gt; create_midpoint_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tdim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bounding box tree for the midpoints of a subset of entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tdim</td><td>The topological dimension of the entity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of local entity indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounding box tree for midpoints of entities </dd></dl>

</div>
</div>
<a id="aadcaaf846e453c74450550c0b7f4a360" name="aadcaaf846e453c74450550c0b7f4a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcaaf846e453c74450550c0b7f4a360">&#9670;&#160;</a></span>determine_point_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::int32_t &gt;, std::vector&lt; std::int32_t &gt;, std::vector&lt; T &gt;, std::vector&lt; std::int32_t &gt; &gt; determine_point_ownership </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points, determine which process is colliding, using the GJK algorithm on cells to determine collisions. </p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo</a></b></dt><dd>This docstring is unclear. Needs fixing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Points to check for collision (<code>shape=(num_points, 3)</code>). Storage is row-major. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>Amount of absolute padding of bounding boxes of the mesh. Each bounding box of the mesh is padded with this amount, to increase the number of candidates, avoiding rounding errors in determining the owner of a point if the point is on the surface of a cell in the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple <code>(src_owner, dest_owner, dest_points, dest_cells)</code>, where src_owner is a list of ranks corresponding to the input points. dest_owner is a list of ranks corresponding to dest_points, the points that this process owns. dest_cells contains the corresponding cell for each entry in dest_points. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>dest_owner</code> is sorted </dd>
<dd>
Returns -1 if no colliding process is found </dd>
<dd>
dest_points is flattened row-major, shape <code>(dest_owner.size(), 3)</code> </dd>
<dd>
Only looks through cells owned by the process </dd>
<dd>
A large padding value can increase the runtime of the function by orders of magnitude, because for non-colliding cells one has to determine the closest cell among all processes with an intersecting bounding box, which is an expensive operation to perform. </dd></dl>

</div>
</div>
<a id="a6d940af5450d864a8acb9093330d5d31" name="a6d940af5450d864a8acb9093330d5d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d940af5450d864a8acb9093330d5d31">&#9670;&#160;</a></span>shortest_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; shortest_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the shortest vector from a mesh entity to a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of the mesh entity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>List of entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Set of points (<code>shape=(num_points, 3)</code>), using row-major storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of vectors (shape=(num_points, 3)) where the ith row is the shortest vector between the ith entity and the ith point. Storage is row-major. </dd></dl>

</div>
</div>
<a id="a371f3829b2339546f6cc63b02e8e3cdd" name="a371f3829b2339546f6cc63b02e8e3cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371f3829b2339546f6cc63b02e8e3cdd">&#9670;&#160;</a></span>squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; squared_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>entities</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the squared distance between a point and a mesh entity. </p>
<p>The distance is computed between the ith input points and the ith input entity.</p>
<dl class="section note"><dt>Note</dt><dd>Uses the GJK algorithm, see <a class="el" href="#a6e9a1509ba99e06bb4b855d7f0a84aeb" title="Compute the distance between two convex bodies p and q, each defined by a set of points.">geometry::compute_distance_gjk</a> for details. </dd>
<dd>
Uses a convex hull approximation of linearized geometry </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh containing the entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The topological dimension of the mesh entities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>The indices of the mesh entities (local to process) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The set points from which to computed the shortest (shape=(num_points, 3)). Storage is row-major. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared shortest distance from points[i] to entities[i] </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>

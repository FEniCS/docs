<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: MatrixCSR&lt; Scalar, Container, ColContainer, RowPtrContainer &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.8.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d6/dfa/namespacedolfinx_1_1la.html">la</a></li><li class="navelem"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d6/d6f/classdolfinx_1_1la_1_1MatrixCSR-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MatrixCSR&lt; Scalar, Container, ColContainer, RowPtrContainer &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Distributed sparse matrix.  
 <a href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dd/d65/MatrixCSR_8h_source.html">MatrixCSR.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae74c256d8fa59319145b92fa944bad9" id="r_aae74c256d8fa59319145b92fa944bad9"><td class="memItemLeft" align="right" valign="top"><a id="aae74c256d8fa59319145b92fa944bad9" name="aae74c256d8fa59319145b92fa944bad9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Scalar</td></tr>
<tr class="memdesc:aae74c256d8fa59319145b92fa944bad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type. <br /></td></tr>
<tr class="separator:aae74c256d8fa59319145b92fa944bad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2014b8eab41918aa55438cb370dd55" id="r_a9c2014b8eab41918aa55438cb370dd55"><td class="memItemLeft" align="right" valign="top"><a id="a9c2014b8eab41918aa55438cb370dd55" name="a9c2014b8eab41918aa55438cb370dd55"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = Container</td></tr>
<tr class="memdesc:a9c2014b8eab41918aa55438cb370dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix entries container type. <br /></td></tr>
<tr class="separator:a9c2014b8eab41918aa55438cb370dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a12155c51f09fb23dc396ed08ecf08" id="r_a57a12155c51f09fb23dc396ed08ecf08"><td class="memItemLeft" align="right" valign="top"><a id="a57a12155c51f09fb23dc396ed08ecf08" name="a57a12155c51f09fb23dc396ed08ecf08"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>column_container_type</b> = ColContainer</td></tr>
<tr class="memdesc:a57a12155c51f09fb23dc396ed08ecf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column index container type. <br /></td></tr>
<tr class="separator:a57a12155c51f09fb23dc396ed08ecf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199aedf0b3d25f4550fdf6e3cdf9baa0" id="r_a199aedf0b3d25f4550fdf6e3cdf9baa0"><td class="memItemLeft" align="right" valign="top"><a id="a199aedf0b3d25f4550fdf6e3cdf9baa0" name="a199aedf0b3d25f4550fdf6e3cdf9baa0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rowptr_container_type</b> = RowPtrContainer</td></tr>
<tr class="memdesc:a199aedf0b3d25f4550fdf6e3cdf9baa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row pointer container type. <br /></td></tr>
<tr class="separator:a199aedf0b3d25f4550fdf6e3cdf9baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af82b24e20208984766017747768330d1" id="r_af82b24e20208984766017747768330d1"><td class="memTemplParams" colspan="2">template&lt;int BS0 = 1, int BS1 = 1&gt; </td></tr>
<tr class="memitem:af82b24e20208984766017747768330d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#af82b24e20208984766017747768330d1">mat_set_values</a> ()</td></tr>
<tr class="memdesc:af82b24e20208984766017747768330d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion functor for setting values in a matrix. It is typically used in finite element assembly functions.  <br /></td></tr>
<tr class="separator:af82b24e20208984766017747768330d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f31ac7eced3e98248e4537b570f1c1" id="r_a29f31ac7eced3e98248e4537b570f1c1"><td class="memTemplParams" colspan="2">template&lt;int BS0 = 1, int BS1 = 1&gt; </td></tr>
<tr class="memitem:a29f31ac7eced3e98248e4537b570f1c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a29f31ac7eced3e98248e4537b570f1c1">mat_add_values</a> ()</td></tr>
<tr class="memdesc:a29f31ac7eced3e98248e4537b570f1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion functor for adding values to a matrix. It is typically used in finite element assembly functions.  <br /></td></tr>
<tr class="separator:a29f31ac7eced3e98248e4537b570f1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab1e7a87e50293d7a36cd75e1db2d8" id="r_a4fab1e7a87e50293d7a36cd75e1db2d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a4fab1e7a87e50293d7a36cd75e1db2d8">MatrixCSR</a> (const <a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">SparsityPattern</a> &amp;p, <a class="el" href="../../d6/dfa/namespacedolfinx_1_1la.html#a95b1e1b5aab4eb54c39e0977036b7eb3">BlockMode</a> mode=BlockMode::compact)</td></tr>
<tr class="memdesc:a4fab1e7a87e50293d7a36cd75e1db2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed matrix.  <br /></td></tr>
<tr class="separator:a4fab1e7a87e50293d7a36cd75e1db2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e45af83ed3e32c3f357e85464670c" id="r_a614e45af83ed3e32c3f357e85464670c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a614e45af83ed3e32c3f357e85464670c">MatrixCSR</a> (<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> &amp;&amp;A)=default</td></tr>
<tr class="memdesc:a614e45af83ed3e32c3f357e85464670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a614e45af83ed3e32c3f357e85464670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdea5bd806d475ad3ca0636c6919aba2" id="r_abdea5bd806d475ad3ca0636c6919aba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#abdea5bd806d475ad3ca0636c6919aba2">set</a> (<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> x)</td></tr>
<tr class="memdesc:abdea5bd806d475ad3ca0636c6919aba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all non-zero local entries to a value including entries in ghost rows.  <br /></td></tr>
<tr class="separator:abdea5bd806d475ad3ca0636c6919aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e569a33c5838c5fb4bedc14ed195300" id="r_a0e569a33c5838c5fb4bedc14ed195300"><td class="memTemplParams" colspan="2">template&lt;int BS0, int BS1&gt; </td></tr>
<tr class="memitem:a0e569a33c5838c5fb4bedc14ed195300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a0e569a33c5838c5fb4bedc14ed195300">set</a> (std::span&lt; const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> &gt; x, std::span&lt; const std::int32_t &gt; rows, std::span&lt; const std::int32_t &gt; <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#abbf3c9be3c7dd289c3e674ac445d9f4e">cols</a>)</td></tr>
<tr class="memdesc:a0e569a33c5838c5fb4bedc14ed195300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values in the matrix.  <br /></td></tr>
<tr class="separator:a0e569a33c5838c5fb4bedc14ed195300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a86261e0064d3ed9ff6b96de35d3d90" id="r_a3a86261e0064d3ed9ff6b96de35d3d90"><td class="memTemplParams" colspan="2">template&lt;int BS0 = 1, int BS1 = 1&gt; </td></tr>
<tr class="memitem:a3a86261e0064d3ed9ff6b96de35d3d90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a3a86261e0064d3ed9ff6b96de35d3d90">add</a> (std::span&lt; const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> &gt; x, std::span&lt; const std::int32_t &gt; rows, std::span&lt; const std::int32_t &gt; <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#abbf3c9be3c7dd289c3e674ac445d9f4e">cols</a>)</td></tr>
<tr class="memdesc:a3a86261e0064d3ed9ff6b96de35d3d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate values in the matrix.  <br /></td></tr>
<tr class="separator:a3a86261e0064d3ed9ff6b96de35d3d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eabebe62656b3b8d9252477e5f61a0" id="r_a44eabebe62656b3b8d9252477e5f61a0"><td class="memItemLeft" align="right" valign="top"><a id="a44eabebe62656b3b8d9252477e5f61a0" name="a44eabebe62656b3b8d9252477e5f61a0"></a>
std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_owned_rows</b> () const</td></tr>
<tr class="memdesc:a44eabebe62656b3b8d9252477e5f61a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of local rows excluding ghost rows. <br /></td></tr>
<tr class="separator:a44eabebe62656b3b8d9252477e5f61a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf00f9c00e0b1fb45f838cccacead71a" id="r_acf00f9c00e0b1fb45f838cccacead71a"><td class="memItemLeft" align="right" valign="top"><a id="acf00f9c00e0b1fb45f838cccacead71a" name="acf00f9c00e0b1fb45f838cccacead71a"></a>
std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_all_rows</b> () const</td></tr>
<tr class="memdesc:acf00f9c00e0b1fb45f838cccacead71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of local rows including ghost rows. <br /></td></tr>
<tr class="separator:acf00f9c00e0b1fb45f838cccacead71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3957be66d50f9a07b0c75016759e181c" id="r_a3957be66d50f9a07b0c75016759e181c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a3957be66d50f9a07b0c75016759e181c">to_dense</a> () const</td></tr>
<tr class="memdesc:a3957be66d50f9a07b0c75016759e181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a dense matrix.  <br /></td></tr>
<tr class="separator:a3957be66d50f9a07b0c75016759e181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f9d7c359047ead5a1de4746a930910" id="r_a76f9d7c359047ead5a1de4746a930910"><td class="memItemLeft" align="right" valign="top"><a id="a76f9d7c359047ead5a1de4746a930910" name="a76f9d7c359047ead5a1de4746a930910"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scatter_rev</b> ()</td></tr>
<tr class="memdesc:a76f9d7c359047ead5a1de4746a930910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer ghost row data to the owning ranks accumulating received values on the owned rows, and zeroing any existing data in ghost rows. This process is analogous to <code>scatter_rev</code> for <code><a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html" title="Distributed vector.">Vector</a></code> except that the values are always accumulated on the owning process. <br /></td></tr>
<tr class="separator:a76f9d7c359047ead5a1de4746a930910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab032c989bf69e8d9a0f54c2bbdcf28ad" id="r_ab032c989bf69e8d9a0f54c2bbdcf28ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ab032c989bf69e8d9a0f54c2bbdcf28ad">scatter_rev_begin</a> ()</td></tr>
<tr class="memdesc:ab032c989bf69e8d9a0f54c2bbdcf28ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned rows.  <br /></td></tr>
<tr class="separator:ab032c989bf69e8d9a0f54c2bbdcf28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef6afb8da364f4f5990e31811348d13" id="r_a1ef6afb8da364f4f5990e31811348d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a1ef6afb8da364f4f5990e31811348d13">scatter_rev_end</a> ()</td></tr>
<tr class="memdesc:a1ef6afb8da364f4f5990e31811348d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">End transfer of ghost row data to owning ranks.  <br /></td></tr>
<tr class="separator:a1ef6afb8da364f4f5990e31811348d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76099c1549db9c057693a2f2fe90b620" id="r_a76099c1549db9c057693a2f2fe90b620"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a76099c1549db9c057693a2f2fe90b620">squared_norm</a> () const</td></tr>
<tr class="memdesc:a76099c1549db9c057693a2f2fe90b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Frobenius norm squared across all processes.  <br /></td></tr>
<tr class="separator:a76099c1549db9c057693a2f2fe90b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7c9f032463aab0dc49ef3a3082ddbb" id="r_a0d7c9f032463aab0dc49ef3a3082ddbb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a0d7c9f032463aab0dc49ef3a3082ddbb">index_map</a> (int dim) const</td></tr>
<tr class="memdesc:a0d7c9f032463aab0dc49ef3a3082ddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index maps for the row and column space.  <br /></td></tr>
<tr class="separator:a0d7c9f032463aab0dc49ef3a3082ddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b38057b0491969b2e775885cb33c69" id="r_a29b38057b0491969b2e775885cb33c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a29b38057b0491969b2e775885cb33c69">values</a> ()</td></tr>
<tr class="memdesc:a29b38057b0491969b2e775885cb33c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local data values.  <br /></td></tr>
<tr class="separator:a29b38057b0491969b2e775885cb33c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c056df0ddfeee3a2cdc95b0d732329" id="r_a03c056df0ddfeee3a2cdc95b0d732329"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a03c056df0ddfeee3a2cdc95b0d732329">values</a> () const</td></tr>
<tr class="memdesc:a03c056df0ddfeee3a2cdc95b0d732329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local values (const version)  <br /></td></tr>
<tr class="separator:a03c056df0ddfeee3a2cdc95b0d732329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f87c20451b1fe7ec61010d6ae1bddf" id="r_ad0f87c20451b1fe7ec61010d6ae1bddf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a199aedf0b3d25f4550fdf6e3cdf9baa0">rowptr_container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ad0f87c20451b1fe7ec61010d6ae1bddf">row_ptr</a> () const</td></tr>
<tr class="memdesc:ad0f87c20451b1fe7ec61010d6ae1bddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local row pointers.  <br /></td></tr>
<tr class="separator:ad0f87c20451b1fe7ec61010d6ae1bddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf3c9be3c7dd289c3e674ac445d9f4e" id="r_abbf3c9be3c7dd289c3e674ac445d9f4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a57a12155c51f09fb23dc396ed08ecf08">column_container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#abbf3c9be3c7dd289c3e674ac445d9f4e">cols</a> () const</td></tr>
<tr class="memdesc:abbf3c9be3c7dd289c3e674ac445d9f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local column indices.  <br /></td></tr>
<tr class="separator:abbf3c9be3c7dd289c3e674ac445d9f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4fa2488d7568e011bd4e738861d0ab" id="r_a0e4fa2488d7568e011bd4e738861d0ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a199aedf0b3d25f4550fdf6e3cdf9baa0">rowptr_container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a0e4fa2488d7568e011bd4e738861d0ab">off_diag_offset</a> () const</td></tr>
<tr class="memdesc:a0e4fa2488d7568e011bd4e738861d0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start of off-diagonal (unowned columns) on each row, allowing the matrix to be split (virtually) into two parts. Operations (such as matrix-vector multiply) between the owned parts of the matrix and vector can then be performed separately from operations on the unowned parts.  <br /></td></tr>
<tr class="separator:a0e4fa2488d7568e011bd4e738861d0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5885105f8558be3508757c934eb606" id="r_acd5885105f8558be3508757c934eb606"><td class="memItemLeft" align="right" valign="top">std::array&lt; int, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#acd5885105f8558be3508757c934eb606">block_size</a> () const</td></tr>
<tr class="memdesc:acd5885105f8558be3508757c934eb606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size.  <br /></td></tr>
<tr class="separator:acd5885105f8558be3508757c934eb606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Scalar, class Container = std::vector&lt;Scalar&gt;, class ColContainer = std::vector&lt;std::int32_t&gt;, class RowPtrContainer = std::vector&lt;std::int64_t&gt;&gt;<br />
class dolfinx::la::MatrixCSR&lt; Scalar, Container, ColContainer, RowPtrContainer &gt;</div><p>Distributed sparse matrix. </p>
<p>The matrix storage format is compressed sparse row. The matrix is partitioned row-wise across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> ranks.</p>
<dl class="section warning"><dt>Warning</dt><dd>Experimental storage of a matrix in CSR format which can be assembled into using the usual DOLFINx assembly routines. Matrix internal data can be accessed for interfacing with other code.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type of matrix entries </td></tr>
    <tr><td class="paramname">Container</td><td>Sequence container type to store matrix entries </td></tr>
    <tr><td class="paramname">ColContainer</td><td>Column index container type </td></tr>
    <tr><td class="paramname">RowPtrContainer</td><td>Row pointer container type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4fab1e7a87e50293d7a36cd75e1db2d8" name="a4fab1e7a87e50293d7a36cd75e1db2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab1e7a87e50293d7a36cd75e1db2d8">&#9670;&#160;</a></span>MatrixCSR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class V , class W , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/dfa/namespacedolfinx_1_1la.html#a95b1e1b5aab4eb54c39e0977036b7eb3">BlockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>BlockMode::compact</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a distributed matrix. </p>
<p>The structure of the matrix depends entirely on the input <code><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html" title="Sparsity pattern data structure that can be used to initialize sparse matrices. After assembly,...">SparsityPattern</a></code>, which must be finalized. The matrix storage is distributed Compressed Sparse Row: the matrix is distributed by row across processes, and on each process, there is a list of column indices and matrix entries for each row stored. This exactly matches the layout of the <code><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html" title="Sparsity pattern data structure that can be used to initialize sparse matrices. After assembly,...">SparsityPattern</a></code>. There is some overlap of matrix rows between processes to allow for independent Finite Element assembly, after which, the ghost rows should be sent to the row owning processes by calling <code><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a76f9d7c359047ead5a1de4746a930910" title="Transfer ghost row data to the owning ranks accumulating received values on the owned rows,...">scatter_rev()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The block size of the matrix is given by the block size of the input <code><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html" title="Sparsity pattern data structure that can be used to initialize sparse matrices. After assembly,...">SparsityPattern</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The sparsity pattern which describes the parallel distribution and the non-zero structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Block mode. When the block size is greater than one, the storage can be "compact" where each matrix entry refers to a block of data (stored row major), or "expanded" where each matrix entry is individual. In the "expanded" case, the sparsity is expanded for every entry in the block, and the block size of the matrix is set to (1, 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614e45af83ed3e32c3f357e85464670c" name="a614e45af83ed3e32c3f357e85464670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614e45af83ed3e32c3f357e85464670c">&#9670;&#160;</a></span>MatrixCSR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a>&lt; Scalar, Container, ColContainer, RowPtrContainer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000008">Todo:</a></b></dt><dd>Check handling of MPI_Request </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a86261e0064d3ed9ff6b96de35d3d90" name="a3a86261e0064d3ed9ff6b96de35d3d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a86261e0064d3ed9ff6b96de35d3d90">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;int BS0 = 1, int BS1 = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate values in the matrix. </p>
<dl class="section note"><dt>Note</dt><dd>Only entries included in the sparsity pattern used to initialize the matrix can be accumulated into. </dd>
<dd>
All indices are local to the calling <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank and entries may go into ghost rows. </dd>
<dd>
Use <code>scatter_rev</code> after all entries have been added to send ghost rows to owners. Adding more entries after <code>scatter_rev</code> is allowed, but another call to <code>scatter_rev</code> will then be required.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BS0</td><td>Row block size of data </td></tr>
    <tr><td class="paramname">BS1</td><td>Column block size of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The <code>m</code> by <code>n</code> dense block of values (row-major) to add to the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row indices of <code>x</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>The column indices of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd5885105f8558be3508757c934eb606" name="acd5885105f8558be3508757c934eb606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5885105f8558be3508757c934eb606">&#9670;&#160;</a></span>block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; int, 2 &gt; block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block size. </p>
<dl class="section return"><dt>Returns</dt><dd>block sizes for rows and columns </dd></dl>

</div>
</div>
<a id="abbf3c9be3c7dd289c3e674ac445d9f4e" name="abbf3c9be3c7dd289c3e674ac445d9f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf3c9be3c7dd289c3e674ac445d9f4e">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a57a12155c51f09fb23dc396ed08ecf08">column_container_type</a> &amp; cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local column indices. </p>
<dl class="section note"><dt>Note</dt><dd>Includes columns in ghost rows </dd></dl>

</div>
</div>
<a id="a0d7c9f032463aab0dc49ef3a3082ddbb" name="a0d7c9f032463aab0dc49ef3a3082ddbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7c9f032463aab0dc49ef3a3082ddbb">&#9670;&#160;</a></span>index_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt; index_map </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index maps for the row and column space. </p>
<p>The row IndexMap contains ghost entries for rows which may be inserted into and the column IndexMap contains all local and ghost columns that may exist in the owned rows.</p>
<dl class="section return"><dt>Returns</dt><dd>Row (0) or column (1) index maps </dd></dl>

</div>
</div>
<a id="a29f31ac7eced3e98248e4537b570f1c1" name="a29f31ac7eced3e98248e4537b570f1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f31ac7eced3e98248e4537b570f1c1">&#9670;&#160;</a></span>mat_add_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;int BS0 = 1, int BS1 = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mat_add_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion functor for adding values to a matrix. It is typically used in finite element assembly functions. </p>
<p>Create a function to add values to a <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html" title="Distributed sparse matrix.">MatrixCSR</a>. The function signature is <code>int mat_add_fn(std::span&lt;const std::int32_t rows, std::span&lt;const std::int32_t cols, std::span&lt;const value_type&gt; data)</code>. The rows and columns use process local indexing, and the given rows and columns must pre-exist in the sparsity pattern of the matrix. Insertion into "ghost" rows (in the ghost region of the row <code>IndexMap</code>) is permitted, so long as there are correct entries in the sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>Using rows or columns which are not in the sparsity will result in undefined behaviour (or an assert failure in Debug mode).</dd>
<dd>
Matrix block size may be (1, 1) or (BS0, BS1) </dd>
<dd>
Data block size may be (1, 1) or (BS0, BS1)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BS0</td><td>Row block size of data for insertion </td></tr>
    <tr><td class="paramname">BS1</td><td>Column block size of data for insertion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function for inserting values into <code>A</code> </dd></dl>

</div>
</div>
<a id="af82b24e20208984766017747768330d1" name="af82b24e20208984766017747768330d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82b24e20208984766017747768330d1">&#9670;&#160;</a></span>mat_set_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;int BS0 = 1, int BS1 = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mat_set_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion functor for setting values in a matrix. It is typically used in finite element assembly functions. </p>
<p>Create a function to set values in a <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html" title="Distributed sparse matrix.">MatrixCSR</a>. The function signature is <code>int mat_set_fn(std::span&lt;const std::int32_t rows, std::span&lt;const std::int32_t cols, std::span&lt;const value_type&gt; data)</code>. The rows and columns use process local indexing, and the given rows and columns must pre-exist in the sparsity pattern of the matrix. Insertion into "ghost" rows (in the ghost region of the row <code>IndexMap</code>) is permitted, so long as there are correct entries in the sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>Using rows or columns which are not in the sparsity will result in undefined behaviour (or an assert failure in Debug mode).</dd>
<dd>
Matrix block size may be (1, 1) or (BS0, BS1) </dd>
<dd>
Data block size may be (1, 1) or (BS0, BS1)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BS0</td><td>Row block size of data for insertion </td></tr>
    <tr><td class="paramname">BS1</td><td>Column block size of data for insertion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function for inserting values into <code>A</code> </dd></dl>

</div>
</div>
<a id="a0e4fa2488d7568e011bd4e738861d0ab" name="a0e4fa2488d7568e011bd4e738861d0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4fa2488d7568e011bd4e738861d0ab">&#9670;&#160;</a></span>off_diag_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a199aedf0b3d25f4550fdf6e3cdf9baa0">rowptr_container_type</a> &amp; off_diag_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the start of off-diagonal (unowned columns) on each row, allowing the matrix to be split (virtually) into two parts. Operations (such as matrix-vector multiply) between the owned parts of the matrix and vector can then be performed separately from operations on the unowned parts. </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost rows, which should be truncated manually if not required. </dd></dl>

</div>
</div>
<a id="ad0f87c20451b1fe7ec61010d6ae1bddf" name="ad0f87c20451b1fe7ec61010d6ae1bddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f87c20451b1fe7ec61010d6ae1bddf">&#9670;&#160;</a></span>row_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a199aedf0b3d25f4550fdf6e3cdf9baa0">rowptr_container_type</a> &amp; row_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local row pointers. </p>
<dl class="section note"><dt>Note</dt><dd>Includes pointers to ghost rows </dd></dl>

</div>
</div>
<a id="ab032c989bf69e8d9a0f54c2bbdcf28ad" name="ab032c989bf69e8d9a0f54c2bbdcf28ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab032c989bf69e8d9a0f54c2bbdcf28ad">&#9670;&#160;</a></span>scatter_rev_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V , typename W , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned rows. </p>
<dl class="section note"><dt>Note</dt><dd>Calls to this function must be followed by <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a1ef6afb8da364f4f5990e31811348d13" title="End transfer of ghost row data to owning ranks.">MatrixCSR::scatter_rev_end()</a>. Between the two calls matrix values must not be changed. </dd>
<dd>
This function does not change the matrix data. Data update only occurs with <code><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a1ef6afb8da364f4f5990e31811348d13" title="End transfer of ghost row data to owning ranks.">scatter_rev_end()</a></code>. </dd></dl>

</div>
</div>
<a id="a1ef6afb8da364f4f5990e31811348d13" name="a1ef6afb8da364f4f5990e31811348d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef6afb8da364f4f5990e31811348d13">&#9670;&#160;</a></span>scatter_rev_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V , typename W , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End transfer of ghost row data to owning ranks. </p>
<dl class="section note"><dt>Note</dt><dd>Must be preceded by <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ab032c989bf69e8d9a0f54c2bbdcf28ad" title="Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned ro...">MatrixCSR::scatter_rev_begin()</a>. </dd>
<dd>
Matrix data received from other processes will be accumulated into locally owned rows, and ghost rows will be zeroed. </dd></dl>

</div>
</div>
<a id="a0e569a33c5838c5fb4bedc14ed195300" name="a0e569a33c5838c5fb4bedc14ed195300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e569a33c5838c5fb4bedc14ed195300">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;int BS0, int BS1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set values in the matrix. </p>
<dl class="section note"><dt>Note</dt><dd>Only entries included in the sparsity pattern used to initialize the matrix can be set. </dd>
<dd>
All indices are local to the calling <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank and entries cannot be set in ghost rows. </dd>
<dd>
This should be called after <code>scatter_rev</code>. Using before <code>scatter_rev</code> will set the values correctly, but incoming values may get added to them during a subsequent reverse scatter operation. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BS0</td><td>Data row block size </td></tr>
    <tr><td class="paramname">BS1</td><td>Data column block size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The <code>m</code> by <code>n</code> dense block of values (row-major) to set in the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row indices of <code>x</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>The column indices of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdea5bd806d475ad3ca0636c6919aba2" name="abdea5bd806d475ad3ca0636c6919aba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdea5bd806d475ad3ca0636c6919aba2">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">value_type</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all non-zero local entries to a value including entries in ghost rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set non-zero matrix entries to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76099c1549db9c057693a2f2fe90b620" name="a76099c1549db9c057693a2f2fe90b620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76099c1549db9c057693a2f2fe90b620">&#9670;&#160;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V , typename W , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double squared_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Frobenius norm squared across all processes. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> Collective </dd></dl>

</div>
</div>
<a id="a3957be66d50f9a07b0c75016759e181c" name="a3957be66d50f9a07b0c75016759e181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3957be66d50f9a07b0c75016759e181c">&#9670;&#160;</a></span>to_dense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V , typename W , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a>&lt; U, V, W, X &gt;<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aae74c256d8fa59319145b92fa944bad9">::value_type</a> &gt; to_dense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to a dense matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This function is typically used for debugging and not used in production </dd>
<dd>
Ghost rows are also returned, and these can be truncated manually by using <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a44eabebe62656b3b8d9252477e5f61a0" title="Number of local rows excluding ghost rows.">num_owned_rows()</a> if required. </dd>
<dd>
If the block size is greater than 1, the entries are expanded. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Dense copy of the part of the matrix on the calling rank. Storage is row-major. </dd></dl>

</div>
</div>
<a id="a29b38057b0491969b2e775885cb33c69" name="a29b38057b0491969b2e775885cb33c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b38057b0491969b2e775885cb33c69">&#9670;&#160;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp; values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local data values. </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost values </dd></dl>

</div>
</div>
<a id="a03c056df0ddfeee3a2cdc95b0d732329" name="a03c056df0ddfeee3a2cdc95b0d732329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c056df0ddfeee3a2cdc95b0d732329">&#9670;&#160;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , class Container  = std::vector&lt;Scalar&gt;, class ColContainer  = std::vector&lt;std::int32_t&gt;, class RowPtrContainer  = std::vector&lt;std::int64_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp; values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local values (const version) </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost values </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/la/<a class="el" href="../../dd/d65/MatrixCSR_8h_source.html">MatrixCSR.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

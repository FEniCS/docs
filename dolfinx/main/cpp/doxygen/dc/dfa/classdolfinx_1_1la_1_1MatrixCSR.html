<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: MatrixCSR&lt; T, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.7.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d6/dfa/namespacedolfinx_1_1la.html">la</a></li><li class="navelem"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d6/d6f/classdolfinx_1_1la_1_1MatrixCSR-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MatrixCSR&lt; T, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Distributed sparse matrix.  
 <a href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dd/d65/MatrixCSR_8h_source.html">MatrixCSR.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb9ded5f49336ae503bb9f2035ea902b"><td class="memItemLeft" align="right" valign="top"><a id="afb9ded5f49336ae503bb9f2035ea902b" name="afb9ded5f49336ae503bb9f2035ea902b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="memdesc:afb9ded5f49336ae503bb9f2035ea902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type. <br /></td></tr>
<tr class="separator:afb9ded5f49336ae503bb9f2035ea902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9340a5b56dce81fa182aee8c64e363"><td class="memItemLeft" align="right" valign="top"><a id="a1b9340a5b56dce81fa182aee8c64e363" name="a1b9340a5b56dce81fa182aee8c64e363"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="memdesc:a1b9340a5b56dce81fa182aee8c64e363"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator type. <br /></td></tr>
<tr class="separator:a1b9340a5b56dce81fa182aee8c64e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0122cde4e6ee6a21928af1994f06f66c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a0122cde4e6ee6a21928af1994f06f66c">mat_set_values</a> ()</td></tr>
<tr class="memdesc:a0122cde4e6ee6a21928af1994f06f66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion functor for setting values in matrix. It is typically used in finite element assembly functions.  <br /></td></tr>
<tr class="separator:a0122cde4e6ee6a21928af1994f06f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbde419f8ce7d7e23605a845fcc696e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a5dbde419f8ce7d7e23605a845fcc696e">mat_add_values</a> ()</td></tr>
<tr class="memdesc:a5dbde419f8ce7d7e23605a845fcc696e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion functor for accumulating values in matrix. It is typically used in finite element assembly functions.  <br /></td></tr>
<tr class="separator:a5dbde419f8ce7d7e23605a845fcc696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f3341b5533ec8f8d50c0ff8707605"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a481f3341b5533ec8f8d50c0ff8707605">MatrixCSR</a> (const <a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">SparsityPattern</a> &amp;p, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a481f3341b5533ec8f8d50c0ff8707605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed matrix.  <br /></td></tr>
<tr class="separator:a481f3341b5533ec8f8d50c0ff8707605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e45af83ed3e32c3f357e85464670c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a614e45af83ed3e32c3f357e85464670c">MatrixCSR</a> (<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> &amp;&amp;A)=default</td></tr>
<tr class="memdesc:a614e45af83ed3e32c3f357e85464670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a614e45af83ed3e32c3f357e85464670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8283383ce14c37fb393fecb1530834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a5e8283383ce14c37fb393fecb1530834">set</a> (T x)</td></tr>
<tr class="memdesc:a5e8283383ce14c37fb393fecb1530834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all non-zero local entries to a value including entries in ghost rows.  <br /></td></tr>
<tr class="separator:a5e8283383ce14c37fb393fecb1530834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068ec4dededc8d1111791664e86a9611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a068ec4dededc8d1111791664e86a9611">set</a> (const std::span&lt; const T &gt; &amp;x, const std::span&lt; const std::int32_t &gt; &amp;rows, const std::span&lt; const std::int32_t &gt; &amp;<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a3b89fe4290e0ec81c5c20825483f5981">cols</a>)</td></tr>
<tr class="memdesc:a068ec4dededc8d1111791664e86a9611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values in the matrix.  <br /></td></tr>
<tr class="separator:a068ec4dededc8d1111791664e86a9611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68f0dcdc2989b062b2925979975ea04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ab68f0dcdc2989b062b2925979975ea04">add</a> (const std::span&lt; const T &gt; &amp;x, const std::span&lt; const std::int32_t &gt; &amp;rows, const std::span&lt; const std::int32_t &gt; &amp;<a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a3b89fe4290e0ec81c5c20825483f5981">cols</a>)</td></tr>
<tr class="memdesc:ab68f0dcdc2989b062b2925979975ea04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate values in the matrix.  <br /></td></tr>
<tr class="separator:ab68f0dcdc2989b062b2925979975ea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eabebe62656b3b8d9252477e5f61a0"><td class="memItemLeft" align="right" valign="top"><a id="a44eabebe62656b3b8d9252477e5f61a0" name="a44eabebe62656b3b8d9252477e5f61a0"></a>
std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_owned_rows</b> () const</td></tr>
<tr class="memdesc:a44eabebe62656b3b8d9252477e5f61a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of local rows excluding ghost rows. <br /></td></tr>
<tr class="separator:a44eabebe62656b3b8d9252477e5f61a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf00f9c00e0b1fb45f838cccacead71a"><td class="memItemLeft" align="right" valign="top"><a id="acf00f9c00e0b1fb45f838cccacead71a" name="acf00f9c00e0b1fb45f838cccacead71a"></a>
std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_all_rows</b> () const</td></tr>
<tr class="memdesc:acf00f9c00e0b1fb45f838cccacead71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of local rows including ghost rows. <br /></td></tr>
<tr class="separator:acf00f9c00e0b1fb45f838cccacead71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9561da90e14656e222a4239a948398"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a4a9561da90e14656e222a4239a948398">to_dense</a> () const</td></tr>
<tr class="memdesc:a4a9561da90e14656e222a4239a948398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a dense matrix.  <br /></td></tr>
<tr class="separator:a4a9561da90e14656e222a4239a948398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d626626eee0bc4ade146973f6abb1c"><td class="memItemLeft" align="right" valign="top"><a id="a32d626626eee0bc4ade146973f6abb1c" name="a32d626626eee0bc4ade146973f6abb1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finalize</b> ()</td></tr>
<tr class="memdesc:a32d626626eee0bc4ade146973f6abb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer ghost row data to the owning ranks accumulating received values on the owned rows, and zeroing any existing data in ghost rows. <br /></td></tr>
<tr class="separator:a32d626626eee0bc4ade146973f6abb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4bb51e89de11041513ca6db1674553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#afc4bb51e89de11041513ca6db1674553">finalize_begin</a> ()</td></tr>
<tr class="memdesc:afc4bb51e89de11041513ca6db1674553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned rows.  <br /></td></tr>
<tr class="separator:afc4bb51e89de11041513ca6db1674553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6827c4c2178bb6db4467f1e8ec90fe1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a6827c4c2178bb6db4467f1e8ec90fe1f">finalize_end</a> ()</td></tr>
<tr class="memdesc:a6827c4c2178bb6db4467f1e8ec90fe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End transfer of ghost row data to owning ranks.  <br /></td></tr>
<tr class="separator:a6827c4c2178bb6db4467f1e8ec90fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad880e77a4acc38171b0abc7df27e0066"><td class="memItemLeft" align="right" valign="top"><a id="ad880e77a4acc38171b0abc7df27e0066" name="ad880e77a4acc38171b0abc7df27e0066"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>norm_squared</b> () const</td></tr>
<tr class="memdesc:ad880e77a4acc38171b0abc7df27e0066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Frobenius norm squared. <br /></td></tr>
<tr class="separator:ad880e77a4acc38171b0abc7df27e0066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad626c211a01e3f610c850748e268f02e"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ad626c211a01e3f610c850748e268f02e">index_maps</a> () const</td></tr>
<tr class="memdesc:ad626c211a01e3f610c850748e268f02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index maps for the row and column space. The row IndexMap contains ghost entries for rows which may be inserted into and the column IndexMap contains all local and ghost columns that may exist in the owned rows.  <br /></td></tr>
<tr class="separator:ad626c211a01e3f610c850748e268f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb1d7039493fa54923a8279c204b7dc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#aefb1d7039493fa54923a8279c204b7dc">values</a> ()</td></tr>
<tr class="memdesc:aefb1d7039493fa54923a8279c204b7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local data values.  <br /></td></tr>
<tr class="separator:aefb1d7039493fa54923a8279c204b7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972f73298a1fa9b68ef530c8fcf8f92"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a4972f73298a1fa9b68ef530c8fcf8f92">values</a> () const</td></tr>
<tr class="memdesc:a4972f73298a1fa9b68ef530c8fcf8f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local values (const version)  <br /></td></tr>
<tr class="separator:a4972f73298a1fa9b68ef530c8fcf8f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92f6907b8fa134292008e58036fe5d2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#ad92f6907b8fa134292008e58036fe5d2">row_ptr</a> () const</td></tr>
<tr class="memdesc:ad92f6907b8fa134292008e58036fe5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local row pointers.  <br /></td></tr>
<tr class="separator:ad92f6907b8fa134292008e58036fe5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b89fe4290e0ec81c5c20825483f5981"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a3b89fe4290e0ec81c5c20825483f5981">cols</a> () const</td></tr>
<tr class="memdesc:a3b89fe4290e0ec81c5c20825483f5981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local column indices.  <br /></td></tr>
<tr class="separator:a3b89fe4290e0ec81c5c20825483f5981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfff9293dda28454f23871bb9276a518"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#abfff9293dda28454f23871bb9276a518">off_diag_offset</a> () const</td></tr>
<tr class="memdesc:abfff9293dda28454f23871bb9276a518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start of off-diagonal (unowned columns) on each row, allowing the matrix to be split (virtually) into two parts. Operations (such as matrix-vector multiply) between the owned parts of the matrix and vector can then be performed separately from operations on the unowned parts.  <br /></td></tr>
<tr class="separator:abfff9293dda28454f23871bb9276a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, class Allocator = std::allocator&lt;T&gt;&gt;<br />
class dolfinx::la::MatrixCSR&lt; T, Allocator &gt;</div><p>Distributed sparse matrix. </p>
<p>The matrix storage format is compressed sparse row. The matrix is partitioned row-wise across <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type for the matrix </td></tr>
    <tr><td class="paramname">Allocator</td><td>The memory allocator type for the data storage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Highly "experimental" storage of a matrix in CSR format which can be assembled into using the usual dolfinx assembly routines Matrix internal data can be accessed for interfacing with other code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000008">Todo:</a></b></dt><dd>Handle block sizes </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a481f3341b5533ec8f8d50c0ff8707605" name="a481f3341b5533ec8f8d50c0ff8707605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481f3341b5533ec8f8d50c0ff8707605">&#9670;&#160;</a></span>MatrixCSR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a distributed matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The sparsty pattern the describes the parallel distribution and the non-zero structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The memory allocator for the data storafe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614e45af83ed3e32c3f357e85464670c" name="a614e45af83ed3e32c3f357e85464670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614e45af83ed3e32c3f357e85464670c">&#9670;&#160;</a></span>MatrixCSR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html">MatrixCSR</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000010">Todo:</a></b></dt><dd>Check handling of MPI_Request </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab68f0dcdc2989b062b2925979975ea04" name="ab68f0dcdc2989b062b2925979975ea04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68f0dcdc2989b062b2925979975ea04">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate values in the matrix. </p>
<dl class="section note"><dt>Note</dt><dd>Only entries included in the sparsity pattern used to initialize the matrix can be accumulated in to </dd>
<dd>
All indices are local to the calling <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank and entries may go into ghost rows. </dd>
<dd>
Use <code>finalize</code> after all entries have been added to send ghost rows to owners. Adding more entries after <code>finalize</code> is allowed, but another call to <code>finalize</code> will then be required. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The <code>m</code> by <code>n</code> dense block of values (row-major) to add to the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row indices of <code>x</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>The column indices of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b89fe4290e0ec81c5c20825483f5981" name="a3b89fe4290e0ec81c5c20825483f5981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b89fe4290e0ec81c5c20825483f5981">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::int32_t &gt; &amp; cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local column indices. </p>
<dl class="section note"><dt>Note</dt><dd>Includes columns in ghost rows </dd></dl>

</div>
</div>
<a id="afc4bb51e89de11041513ca6db1674553" name="afc4bb51e89de11041513ca6db1674553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4bb51e89de11041513ca6db1674553">&#9670;&#160;</a></span>finalize_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void finalize_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned rows. </p>
<dl class="section note"><dt>Note</dt><dd>Calls to this function must be followed by <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a6827c4c2178bb6db4467f1e8ec90fe1f" title="End transfer of ghost row data to owning ranks.">MatrixCSR::finalize_end()</a>. Between the two calls matrix values must not be changed. </dd>
<dd>
This function does not change the matrix data. Data update only occurs with <code><a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a6827c4c2178bb6db4467f1e8ec90fe1f" title="End transfer of ghost row data to owning ranks.">finalize_end()</a></code>. </dd></dl>

</div>
</div>
<a id="a6827c4c2178bb6db4467f1e8ec90fe1f" name="a6827c4c2178bb6db4467f1e8ec90fe1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6827c4c2178bb6db4467f1e8ec90fe1f">&#9670;&#160;</a></span>finalize_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void finalize_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End transfer of ghost row data to owning ranks. </p>
<dl class="section note"><dt>Note</dt><dd>Must be preceded by <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#afc4bb51e89de11041513ca6db1674553" title="Begin transfer of ghost row data to owning ranks, where it will be accumulated into existing owned ro...">MatrixCSR::finalize_begin()</a> </dd>
<dd>
Matrix data received from other processes will be accumulated into locally owned rows, and ghost rows will be zeroed. </dd></dl>

</div>
</div>
<a id="ad626c211a01e3f610c850748e268f02e" name="ad626c211a01e3f610c850748e268f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad626c211a01e3f610c850748e268f02e">&#9670;&#160;</a></span>index_maps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, 2 &gt; &amp; index_maps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index maps for the row and column space. The row IndexMap contains ghost entries for rows which may be inserted into and the column IndexMap contains all local and ghost columns that may exist in the owned rows. </p>
<dl class="section return"><dt>Returns</dt><dd>Row (0) and column (1) index maps </dd></dl>

</div>
</div>
<a id="a5dbde419f8ce7d7e23605a845fcc696e" name="a5dbde419f8ce7d7e23605a845fcc696e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbde419f8ce7d7e23605a845fcc696e">&#9670;&#160;</a></span>mat_add_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mat_add_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion functor for accumulating values in matrix. It is typically used in finite element assembly functions. </p>
<dl class="section return"><dt>Returns</dt><dd>Function for inserting values into <code>A</code> </dd></dl>

</div>
</div>
<a id="a0122cde4e6ee6a21928af1994f06f66c" name="a0122cde4e6ee6a21928af1994f06f66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0122cde4e6ee6a21928af1994f06f66c">&#9670;&#160;</a></span>mat_set_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mat_set_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion functor for setting values in matrix. It is typically used in finite element assembly functions. </p>
<dl class="section return"><dt>Returns</dt><dd>Function for inserting values into <code>A</code> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000009">Todo:</a></b></dt><dd>clarify setting on non-owned entries </dd></dl>

</div>
</div>
<a id="abfff9293dda28454f23871bb9276a518" name="abfff9293dda28454f23871bb9276a518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfff9293dda28454f23871bb9276a518">&#9670;&#160;</a></span>off_diag_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::int32_t &gt; &amp; off_diag_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the start of off-diagonal (unowned columns) on each row, allowing the matrix to be split (virtually) into two parts. Operations (such as matrix-vector multiply) between the owned parts of the matrix and vector can then be performed separately from operations on the unowned parts. </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost rows, which should be truncated manually if not required. </dd></dl>

</div>
</div>
<a id="ad92f6907b8fa134292008e58036fe5d2" name="ad92f6907b8fa134292008e58036fe5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92f6907b8fa134292008e58036fe5d2">&#9670;&#160;</a></span>row_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::int32_t &gt; &amp; row_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local row pointers. </p>
<dl class="section note"><dt>Note</dt><dd>Includes pointers to ghost rows </dd></dl>

</div>
</div>
<a id="a068ec4dededc8d1111791664e86a9611" name="a068ec4dededc8d1111791664e86a9611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068ec4dededc8d1111791664e86a9611">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set values in the matrix. </p>
<dl class="section note"><dt>Note</dt><dd>Only entries included in the sparsity pattern used to initialize the matrix can be set </dd>
<dd>
All indices are local to the calling <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank and entries cannot be set in ghost rows. </dd>
<dd>
This should be called after <code>finalize</code>. Using before <code>finalize</code> will set the values correctly, but incoming values may get added to them during a subsequent finalize operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The <code>m</code> by <code>n</code> dense block of values (row-major) to set in the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row indices of <code>x</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>The column indices of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8283383ce14c37fb393fecb1530834" name="a5e8283383ce14c37fb393fecb1530834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8283383ce14c37fb393fecb1530834">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all non-zero local entries to a value including entries in ghost rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set non-zero matrix entries to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a9561da90e14656e222a4239a948398" name="a4a9561da90e14656e222a4239a948398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9561da90e14656e222a4239a948398">&#9670;&#160;</a></span>to_dense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; to_dense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy to a dense matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This function is typically used for debugging and not used in production </dd>
<dd>
Ghost rows are also returned, and these can be truncated manually by using <a class="el" href="../../dc/dfa/classdolfinx_1_1la_1_1MatrixCSR.html#a44eabebe62656b3b8d9252477e5f61a0" title="Number of local rows excluding ghost rows.">num_owned_rows()</a> if required. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Dense copy of the part of the matrix on the calling rank. Storage is row-major. </dd></dl>

</div>
</div>
<a id="aefb1d7039493fa54923a8279c204b7dc" name="aefb1d7039493fa54923a8279c204b7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb1d7039493fa54923a8279c204b7dc">&#9670;&#160;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local data values. </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost values </dd></dl>

</div>
</div>
<a id="a4972f73298a1fa9b68ef530c8fcf8f92" name="a4972f73298a1fa9b68ef530c8fcf8f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4972f73298a1fa9b68ef530c8fcf8f92">&#9670;&#160;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local values (const version) </p>
<dl class="section note"><dt>Note</dt><dd>Includes ghost values </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/la/<a class="el" href="../../dd/d65/MatrixCSR_8h_source.html">MatrixCSR.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

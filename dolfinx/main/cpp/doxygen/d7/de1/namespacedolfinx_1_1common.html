<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::common Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.10.0.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dolfinx::common Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous classes, functions and types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classdolfinx_1_1common_1_1Scatterer.html">Scatterer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../de/d43/classdolfinx_1_1common_1_1Scatterer.html" title="A Scatterer supports the MPI scattering and gathering of data that is associated with a common::Index...">Scatterer</a> supports the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> scattering and gathering of data that is associated with a <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>.  <a href="../../de/d43/classdolfinx_1_1common_1_1Scatterer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df3/classdolfinx_1_1common_1_1TimeLogger.html">TimeLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time logger maintaining data collected by <a class="el" href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html" title="Timer for measuring and logging elapsed time durations.">Timer</a>, if registered.  <a href="../../db/df3/classdolfinx_1_1common_1_1TimeLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html" title="Timer for measuring and logging elapsed time durations.">Timer</a> for measuring and logging elapsed time durations.  <a href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a85fe08b363fe014c058cdf79d502910f" id="r_a85fe08b363fe014c058cdf79d502910f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85fe08b363fe014c058cdf79d502910f">IndexMapOrder</a> : bool { <a class="el" href="#a85fe08b363fe014c058cdf79d502910faec4875cf2d241556a0965f7237864693">preserve</a> = true
, <a class="el" href="#a85fe08b363fe014c058cdf79d502910fa100b8cad7cf2a56f6df78f171f97a1ec">any</a> = false
 }</td></tr>
<tr class="separator:a85fe08b363fe014c058cdf79d502910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a53546ac2b5250e045e91411cae1b5724" id="r_a53546ac2b5250e045e91411cae1b5724"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53546ac2b5250e045e91411cae1b5724">compute_owned_indices</a> (std::span&lt; const std::int32_t &gt; indices, const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &amp;map)</td></tr>
<tr class="memdesc:a53546ac2b5250e045e91411cae1b5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sorted vector of indices (local numbering, owned or ghost) and an index map, this function returns the indices owned by this process, including indices that might have been in the list of indices on another processes.  <br /></td></tr>
<tr class="separator:a53546ac2b5250e045e91411cae1b5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed477f7f68f03a1a443a50de541cde4a" id="r_aed477f7f68f03a1a443a50de541cde4a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::int64_t, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::vector&lt; std::int64_t &gt; &gt;, std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed477f7f68f03a1a443a50de541cde4a">stack_index_maps</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &gt;, int &gt; &gt; &amp;maps)</td></tr>
<tr class="memdesc:aed477f7f68f03a1a443a50de541cde4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute layout data and ghost indices for a stacked (concatenated) index map, i.e. 'splice' multiple maps into one.  <br /></td></tr>
<tr class="separator:aed477f7f68f03a1a443a50de541cde4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b31acd9ffe456626a8c8b3b4013326" id="r_a29b31acd9ffe456626a8c8b3b4013326"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a>, std::vector&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29b31acd9ffe456626a8c8b3b4013326">create_sub_index_map</a> (const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &amp;imap, std::span&lt; const std::int32_t &gt; indices, <a class="el" href="#a85fe08b363fe014c058cdf79d502910f">IndexMapOrder</a> order=<a class="el" href="#a85fe08b363fe014c058cdf79d502910fa100b8cad7cf2a56f6df78f171f97a1ec">IndexMapOrder::any</a>, bool allow_owner_change=false)</td></tr>
<tr class="memdesc:a29b31acd9ffe456626a8c8b3b4013326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new index map from a subset of indices in an existing index map.  <br /></td></tr>
<tr class="separator:a29b31acd9ffe456626a8c8b3b4013326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4f61eb18edfadf84cdbb81afe141d5" id="r_a3d4f61eb18edfadf84cdbb81afe141d5"><td class="memTemplParams" colspan="2">template&lt;typename U, typename V&gt; </td></tr>
<tr class="memitem:a3d4f61eb18edfadf84cdbb81afe141d5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; typename U::value_type &gt;, std::vector&lt; typename V::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d4f61eb18edfadf84cdbb81afe141d5">sort_unique</a> (const U &amp;indices, const V &amp;values)</td></tr>
<tr class="memdesc:a3d4f61eb18edfadf84cdbb81afe141d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort two arrays based on the values in array <code>indices</code>.  <br /></td></tr>
<tr class="separator:a3d4f61eb18edfadf84cdbb81afe141d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af086d214f48b9dc23d8f2fe30d23c1d8" id="r_af086d214f48b9dc23d8f2fe30d23c1d8"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:af086d214f48b9dc23d8f2fe30d23c1d8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af086d214f48b9dc23d8f2fe30d23c1d8">hash_local</a> (const T &amp;x)</td></tr>
<tr class="memdesc:af086d214f48b9dc23d8f2fe30d23c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash of a given object.  <br /></td></tr>
<tr class="separator:af086d214f48b9dc23d8f2fe30d23c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf02a2803d65dfa4ba932e2a32d69d65" id="r_abf02a2803d65dfa4ba932e2a32d69d65"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:abf02a2803d65dfa4ba932e2a32d69d65"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf02a2803d65dfa4ba932e2a32d69d65">hash_global</a> (MPI_Comm comm, const T &amp;x)</td></tr>
<tr class="memdesc:abf02a2803d65dfa4ba932e2a32d69d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash for a distributed (<a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a>) object.  <br /></td></tr>
<tr class="separator:abf02a2803d65dfa4ba932e2a32d69d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b1778408aad14e1c87c0e0b69c8c89" id="r_af5b1778408aad14e1c87c0e0b69c8c89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5b1778408aad14e1c87c0e0b69c8c89">comm_to_json</a> (const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::tuple&lt; int, std::size_t, std::int8_t &gt;, std::pair&lt; std::int32_t, std::int32_t &gt; &gt; &amp;g)</td></tr>
<tr class="memdesc:af5b1778408aad14e1c87c0e0b69c8c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build communication graph data as a JSON string.  <br /></td></tr>
<tr class="separator:af5b1778408aad14e1c87c0e0b69c8c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous classes, functions and types. </p>
<p>Generic tools.</p>
<p>This namespace provides utility type functions for managing subsystems, convenience classes and library-wide typedefs. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a85fe08b363fe014c058cdf79d502910f" name="a85fe08b363fe014c058cdf79d502910f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fe08b363fe014c058cdf79d502910f">&#9670;&#160;</a></span>IndexMapOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a85fe08b363fe014c058cdf79d502910f">IndexMapOrder</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enum to control preservation of ghost index ordering in sub-IndexMaps. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85fe08b363fe014c058cdf79d502910faec4875cf2d241556a0965f7237864693" name="a85fe08b363fe014c058cdf79d502910faec4875cf2d241556a0965f7237864693"></a>preserve&#160;</td><td class="fielddoc"><p>Preserve the ordering of ghost indices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85fe08b363fe014c058cdf79d502910fa100b8cad7cf2a56f6df78f171f97a1ec" name="a85fe08b363fe014c058cdf79d502910fa100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>Allow arbitrary ordering of ghost indices in sub-maps. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af5b1778408aad14e1c87c0e0b69c8c89" name="af5b1778408aad14e1c87c0e0b69c8c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b1778408aad14e1c87c0e0b69c8c89">&#9670;&#160;</a></span>comm_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string comm_to_json </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::tuple&lt; int, std::size_t, std::int8_t &gt;, std::pair&lt; std::int32_t, std::int32_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build communication graph data as a JSON string. </p>
<p>The data string can be decoded (loaded) to create a Python object from which a <a href="https://networkx.org/">NetworkX</a> graph can be constructed.</p>
<p>See ::comm_graph for a description of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Communication graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON string representing the communication graph. Edge data is data volume (<code>weight</code>) and local/remote memory indicator (<code>local==1</code> is an edge to an shared memory process/rank, other wise the target node is a remote memory rank). </dd></dl>

</div>
</div>
<a id="a53546ac2b5250e045e91411cae1b5724" name="a53546ac2b5250e045e91411cae1b5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53546ac2b5250e045e91411cae1b5724">&#9670;&#160;</a></span>compute_owned_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; compute_owned_indices </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a sorted vector of indices (local numbering, owned or ghost) and an index map, this function returns the indices owned by this process, including indices that might have been in the list of indices on another processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The index map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices owned by the calling process </dd></dl>

</div>
</div>
<a id="a29b31acd9ffe456626a8c8b3b4013326" name="a29b31acd9ffe456626a8c8b3b4013326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b31acd9ffe456626a8c8b3b4013326">&#9670;&#160;</a></span>create_sub_index_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a>, std::vector&lt; std::int32_t &gt; &gt; create_sub_index_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>imap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a85fe08b363fe014c058cdf79d502910f">IndexMapOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a85fe08b363fe014c058cdf79d502910fa100b8cad7cf2a56f6df78f171f97a1ec">IndexMapOrder::any</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_owner_change</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new index map from a subset of indices in an existing index map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imap</td><td>Parent map to create a new sub-map from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Local indices in <code>imap</code> (owned and ghost) to include in the new index map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Control the order in which ghost indices appear in the new map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_owner_change</td><td>If <code>true</code>, indices that are not included in <code>indices</code> by their owning process can be included in <code>indices</code> by processes that ghost the indices to be included in the new submap. These indices will be owned by one of the sharing processes in the submap. If <code>false</code>, and exception is raised if an index is included by a sharing process and not by the owning process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (i) new index map and (ii) a map from local indices in the submap to local indices in the original (this) map. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indices</code> must be sorted and must not contain duplicates. </dd></dl>

</div>
</div>
<a id="abf02a2803d65dfa4ba932e2a32d69d65" name="abf02a2803d65dfa4ba932e2a32d69d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf02a2803d65dfa4ba932e2a32d69d65">&#9670;&#160;</a></span>hash_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hash_global </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash for a distributed (<a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a>) object. </p>
<p>A hash is computed on each process for the local part of the object. Then, a hash of the std::vector containing each local hash key in rank order is returned.</p>
<dl class="section note"><dt>Note</dt><dd>Collective</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The communicator on which to compute the hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The object to compute a hash of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash values. </dd></dl>

</div>
</div>
<a id="af086d214f48b9dc23d8f2fe30d23c1d8" name="af086d214f48b9dc23d8f2fe30d23c1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af086d214f48b9dc23d8f2fe30d23c1d8">&#9670;&#160;</a></span>hash_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hash_local </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash of a given object. </p>
<p>The hash is computed using Boost container hash (<a href="https://www.boost.org/doc/libs/release/libs/container_hash/">https://www.boost.org/doc/libs/release/libs/container_hash/</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The object to compute a hash of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash values. </dd></dl>

</div>
</div>
<a id="a3d4f61eb18edfadf84cdbb81afe141d5" name="a3d4f61eb18edfadf84cdbb81afe141d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4f61eb18edfadf84cdbb81afe141d5">&#9670;&#160;</a></span>sort_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; typename U::value_type &gt;, std::vector&lt; typename V::value_type &gt; &gt; sort_unique </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort two arrays based on the values in array <code>indices</code>. </p>
<p>Any duplicate indices and the corresponding value are removed. In the case of duplicates, the entry with the smallest value is retained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Array of indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted (indices, values), with sorting based on indices. </dd></dl>

</div>
</div>
<a id="aed477f7f68f03a1a443a50de541cde4a" name="aed477f7f68f03a1a443a50de541cde4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed477f7f68f03a1a443a50de541cde4a">&#9670;&#160;</a></span>stack_index_maps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::int64_t, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::vector&lt; std::int64_t &gt; &gt;, std::vector&lt; std::vector&lt; int &gt; &gt; &gt; stack_index_maps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a> &gt;, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute layout data and ghost indices for a stacked (concatenated) index map, i.e. 'splice' multiple maps into one. </p>
<p>The input maps are concatenated, with indices in <code>maps</code> and owned by the caller remaining owned by the caller. Ghost data is stored at the end of the local range as normal, with the ghosts in blocks in the order of the index maps in <code>maps</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Index maps with a block size are unrolled in the data for the concatenated index map. </dd>
<dd>
Communication is required to compute the new ghost indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maps</td><td>List of (index map, block size) pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (0) global offset of a concatenated map for the calling rank, (1) local offset for the owned indices of each submap in the concatenated map, (2) new indices for the ghosts for each submap, and (3) owner rank of each ghost entry for each submap. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>

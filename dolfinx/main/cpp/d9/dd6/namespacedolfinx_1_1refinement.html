<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::refinement Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFINx
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dolfinx</b></li><li class="navelem"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html">refinement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dolfinx::refinement Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Mesh refinement algorithms.  
<a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:df/dfe/namespacedolfinx_1_1refinement_1_1plaza"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dfe/namespacedolfinx_1_1refinement_1_1plaza.html">plaza</a></td></tr>
<tr class="memdesc:df/dfe/namespacedolfinx_1_1refinement_1_1plaza"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the refinement method described in Plaza and Carey "Local refinement of simplicial grids based on the skeleton" (Applied Numerical Mathematics 32 (2000) 195-218) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8770e9e8ea5709867b73e9f1ec67c7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a8770e9e8ea5709867b73e9f1ec67c7ee">refine</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;mesh, bool redistribute=true)</td></tr>
<tr class="memdesc:a8770e9e8ea5709867b73e9f1ec67c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create uniformly refined mesh.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a8770e9e8ea5709867b73e9f1ec67c7ee">More...</a><br /></td></tr>
<tr class="separator:a8770e9e8ea5709867b73e9f1ec67c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1465af5306387f8cc29a33c19bbbd12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#ae1465af5306387f8cc29a33c19bbbd12">refine</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;mesh, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; std::int8_t &gt; &amp;cell_markers, bool redistribute=true)</td></tr>
<tr class="memdesc:ae1465af5306387f8cc29a33c19bbbd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create locally refined mesh.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#ae1465af5306387f8cc29a33c19bbbd12">More...</a><br /></td></tr>
<tr class="separator:ae1465af5306387f8cc29a33c19bbbd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a800d0e0b439f130a62c0994921512"><td class="memItemLeft" align="right" valign="top">std::pair&lt; MPI_Comm, std::map&lt; std::int32_t, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a85a800d0e0b439f130a62c0994921512">compute_edge_sharing</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a85a800d0e0b439f130a62c0994921512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sharing of edges between processes. The resulting MPI_Comm is over the neighborhood of shared edges, allowing direct communication between peers. The resulting map is from local edge index to the set of neighbors (within the comm) that share that edge.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a85a800d0e0b439f130a62c0994921512">More...</a><br /></td></tr>
<tr class="separator:a85a800d0e0b439f130a62c0994921512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc50e57fade50f00ddb47b38de8ebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#af9cc50e57fade50f00ddb47b38de8ebf">update_logical_edgefunction</a> (const MPI_Comm &amp;neighbor_comm, const std::vector&lt; std::vector&lt; std::int32_t &gt;&gt; &amp;marked_for_update, std::vector&lt; bool &gt; &amp;marked_edges, const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &amp;map_e)</td></tr>
<tr class="memdesc:af9cc50e57fade50f00ddb47b38de8ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer marked edges between processes.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#af9cc50e57fade50f00ddb47b38de8ebf">More...</a><br /></td></tr>
<tr class="separator:af9cc50e57fade50f00ddb47b38de8ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797665b09701ade8bd2803ebe39150a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::map&lt; std::int32_t, std::int64_t &gt;, xt::xtensor&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#ab797665b09701ade8bd2803ebe39150a">create_new_vertices</a> (const MPI_Comm &amp;neighbor_comm, const std::map&lt; std::int32_t, std::vector&lt; std::int32_t &gt;&gt; &amp;shared_edges, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;mesh, const std::vector&lt; bool &gt; &amp;marked_edges)</td></tr>
<tr class="memdesc:ab797665b09701ade8bd2803ebe39150a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new vertex for each marked edge, and create new_vertex_coordinates and global_edge-&gt;new_vertex map. Communicate new vertices with <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> to all affected processes.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#ab797665b09701ade8bd2803ebe39150a">More...</a><br /></td></tr>
<tr class="separator:ab797665b09701ade8bd2803ebe39150a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042b2081bd2897a7d706cacb4ea23cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a042b2081bd2897a7d706cacb4ea23cff">partition</a> (const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;old_mesh, const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;cell_topology, const xt::xtensor&lt; double, 2 &gt; &amp;new_vertex_coordinates, bool redistribute, <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#adafbc0ec5001e833100ae1bfdcd300b3">mesh::GhostMode</a> ghost_mode)</td></tr>
<tr class="memdesc:a042b2081bd2897a7d706cacb4ea23cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use vertex and topology data to partition new mesh across processes.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a042b2081bd2897a7d706cacb4ea23cff">More...</a><br /></td></tr>
<tr class="separator:a042b2081bd2897a7d706cacb4ea23cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b026698f350cf3ec0ef888c51314722"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a3b026698f350cf3ec0ef888c51314722">adjust_indices</a> (const std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt; &amp;index_map, std::int32_t n)</td></tr>
<tr class="memdesc:a3b026698f350cf3ec0ef888c51314722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust indices to account for extra n values on each process This is a utility to help add new topological vertices on each process into the space of the index map.  <a href="../../d9/dd6/namespacedolfinx_1_1refinement.html#a3b026698f350cf3ec0ef888c51314722">More...</a><br /></td></tr>
<tr class="separator:a3b026698f350cf3ec0ef888c51314722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mesh refinement algorithms. </p>
<p>Methods for refining meshes uniformly, or with markers, using edge bisection. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3b026698f350cf3ec0ef888c51314722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b026698f350cf3ec0ef888c51314722">&#9670;&nbsp;</a></span>adjust_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int64_t &gt; dolfinx::refinement::adjust_indices </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust indices to account for extra n values on each process This is a utility to help add new topological vertices on each process into the space of the index map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_map</td><td>Index map for the current mesh vertices </td></tr>
    <tr><td class="paramname">n</td><td>Number of new entries to be accommodated on this process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global indices as if "n" extra values are appended on each process </dd></dl>

</div>
</div>
<a id="a85a800d0e0b439f130a62c0994921512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a800d0e0b439f130a62c0994921512">&#9670;&nbsp;</a></span>compute_edge_sharing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; MPI_Comm, std::map&lt; std::int32_t, std::vector&lt; int &gt; &gt; &gt; dolfinx::refinement::compute_edge_sharing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sharing of edges between processes. The resulting MPI_Comm is over the neighborhood of shared edges, allowing direct communication between peers. The resulting map is from local edge index to the set of neighbors (within the comm) that share that edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of comm and map </dd></dl>

</div>
</div>
<a id="ab797665b09701ade8bd2803ebe39150a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab797665b09701ade8bd2803ebe39150a">&#9670;&nbsp;</a></span>create_new_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::map&lt; std::int32_t, std::int64_t &gt;, xt::xtensor&lt; double, 2 &gt; &gt; dolfinx::refinement::create_new_vertices </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>neighbor_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::int32_t, std::vector&lt; std::int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shared_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new vertex for each marked edge, and create new_vertex_coordinates and global_edge-&gt;new_vertex map. Communicate new vertices with <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> to all affected processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbor_comm</td><td><a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> Communicator for neighborhood </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shared_edges</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Existing mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marked_edges</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge_to_new_vertex map and geometry array </dd></dl>

</div>
</div>
<a id="a042b2081bd2897a7d706cacb4ea23cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042b2081bd2897a7d706cacb4ea23cff">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> dolfinx::refinement::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>old_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_vertex_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>redistribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#adafbc0ec5001e833100ae1bfdcd300b3">mesh::GhostMode</a>&#160;</td>
          <td class="paramname"><em>ghost_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use vertex and topology data to partition new mesh across processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_mesh</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_topology</td><td>Topology of cells, (vertex indices) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_vertex_coordinates</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redistribute</td><td>Call graph partitioner if true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghost_mode</td><td>None or shared_facet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh </dd></dl>

</div>
</div>
<a id="a8770e9e8ea5709867b73e9f1ec67c7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8770e9e8ea5709867b73e9f1ec67c7ee">&#9670;&nbsp;</a></span>refine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> dolfinx::refinement::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>redistribute</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create uniformly refined mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which to build a refined Mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redistribute</td><td>Optional argument to redistribute the refined mesh if mesh is a distributed mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A refined mesh </dd></dl>

</div>
</div>
<a id="ae1465af5306387f8cc29a33c19bbbd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1465af5306387f8cc29a33c19bbbd12">&#9670;&nbsp;</a></span>refine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> dolfinx::refinement::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; std::int8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_markers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>redistribute</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create locally refined mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh from which to build a refined Mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_markers</td><td>A mesh function over integers specifying which cells should be refined (value == 1) (and which should not (any other integer value)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redistribute</td><td>Optional argument to redistribute the refined mesh if mesh is a distributed mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A locally refined mesh </dd></dl>

</div>
</div>
<a id="af9cc50e57fade50f00ddb47b38de8ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cc50e57fade50f00ddb47b38de8ebf">&#9670;&nbsp;</a></span>update_logical_edgefunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::refinement::update_logical_edgefunction </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>neighbor_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_for_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map_e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer marked edges between processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbor_comm</td><td><a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> Communicator for neighborhood </td></tr>
    <tr><td class="paramname">marked_for_update</td><td>Lists of edges to be updates on each neighbor </td></tr>
    <tr><td class="paramname">marked_edges</td><td>Marked edges to be updated </td></tr>
    <tr><td class="paramname">map_e</td><td>IndexMap for edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>

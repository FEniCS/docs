<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::fem Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFINx
   &#160;<span id="projectnumber">0.3.1.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dolfinx</b></li><li class="navelem"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dolfinx::fem Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Finite element method functionality.  
<a href="../../d8/dbf/namespacedolfinx_1_1fem.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html">sparsitybuild</a></td></tr>
<tr class="memdesc:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to build sparsity patterns from degree-of-freedom maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for setting (strong) Dirichlet boundary conditions.  <a href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for variational forms.  <a href="../../df/d02/classdolfinx_1_1fem_1_1Form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant value which can be attached to a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a>. Constants may be scalar (rank 0), vector (rank 1), or tensor valued.  <a href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">CoordinateElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages coordinate mappings for isoparametric cells.  <a href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree-of-freedom map.  <a href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh entity. This class also handles sub-space dofs, which are views into the parent dofs.  <a href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell. This class closely follows the concept of a UFC <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell....">Expression</a>.  <a href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite Element, containing the dof layout on a reference element, and various methods for evaluating and transforming the basis.  <a href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a function \( u_h \) in a finite element function space \( V_h \), given by.  <a href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a finite element function space defined by a mesh, a finite element, and a local-to-global map of the degrees of freedom (dofmap).  <a href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afc30329eb0140cb5f16d715fa4eedd76"><td class="memItemLeft" align="right" valign="top"><a id="afc30329eb0140cb5f16d715fa4eedd76"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a> : std::int8_t { <b>cell</b> = 0
, <b>exterior_facet</b> = 1
, <b>interior_facet</b> = 2
, <b>vertex</b> = 3
 }</td></tr>
<tr class="memdesc:afc30329eb0140cb5f16d715fa4eedd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of integral. <br /></td></tr>
<tr class="separator:afc30329eb0140cb5f16d715fa4eedd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea7f29b20e88c60ed9098eece047eb6f"><td class="memTemplParams" colspan="2"><a id="aea7f29b20e88c60ed9098eece047eb6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea7f29b20e88c60ed9098eece047eb6f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">dolfinx::fem::IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aea7f29b20e88c60ed9098eece047eb6f">make_coefficients_span</a> (const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt;&gt; &amp;coeffs)</td></tr>
<tr class="memdesc:aea7f29b20e88c60ed9098eece047eb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the std::vectors of coefficients in the coefficient map into xtl::spans. <br /></td></tr>
<tr class="separator:aea7f29b20e88c60ed9098eece047eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d6f1e1c3dd48089cba92ea7b4ce48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea9d6f1e1c3dd48089cba92ea7b4ce48"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aea9d6f1e1c3dd48089cba92ea7b4ce48">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;M, const xtl::span&lt; const T &gt; &amp;constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;coefficients)</td></tr>
<tr class="memdesc:aea9d6f1e1c3dd48089cba92ea7b4ce48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar. The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aea9d6f1e1c3dd48089cba92ea7b4ce48">More...</a><br /></td></tr>
<tr class="separator:aea9d6f1e1c3dd48089cba92ea7b4ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1bf9501710367c63159980f429bda3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a1bf9501710367c63159980f429bda3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a1bf9501710367c63159980f429bda3">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a7a1bf9501710367c63159980f429bda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a1bf9501710367c63159980f429bda3">More...</a><br /></td></tr>
<tr class="separator:a7a1bf9501710367c63159980f429bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37f8600c9f1eff0d550872fd1a1d6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab37f8600c9f1eff0d550872fd1a1d6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aab37f8600c9f1eff0d550872fd1a1d6a">assemble_vector</a> (xtl::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;L, const xtl::span&lt; const T &gt; &amp;constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;coefficients)</td></tr>
<tr class="memdesc:aab37f8600c9f1eff0d550872fd1a1d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector, The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aab37f8600c9f1eff0d550872fd1a1d6a">More...</a><br /></td></tr>
<tr class="separator:aab37f8600c9f1eff0d550872fd1a1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49626b25e5a7804b776b0fb59529bc4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49626b25e5a7804b776b0fb59529bc4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a49626b25e5a7804b776b0fb59529bc4a">assemble_vector</a> (xtl::span&lt; T &gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;L)</td></tr>
<tr class="memdesc:a49626b25e5a7804b776b0fb59529bc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into a vector.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a49626b25e5a7804b776b0fb59529bc4a">More...</a><br /></td></tr>
<tr class="separator:a49626b25e5a7804b776b0fb59529bc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fc3c8fb15d06a35682db45835c04aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60fc3c8fb15d06a35682db45835c04aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60fc3c8fb15d06a35682db45835c04aa">apply_lifting</a> (xtl::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;a, const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;constants, const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt;&gt; &amp;coeffs, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a60fc3c8fb15d06a35682db45835c04aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60fc3c8fb15d06a35682db45835c04aa">More...</a><br /></td></tr>
<tr class="separator:a60fc3c8fb15d06a35682db45835c04aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3418f00b84aa9095bf3c60af46e428d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3418f00b84aa9095bf3c60af46e428d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3418f00b84aa9095bf3c60af46e428d2">apply_lifting</a> (xtl::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a3418f00b84aa9095bf3c60af46e428d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3418f00b84aa9095bf3c60af46e428d2">More...</a><br /></td></tr>
<tr class="separator:a3418f00b84aa9095bf3c60af46e428d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53b6fdc8b65e75d1411934059311fbf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad53b6fdc8b65e75d1411934059311fbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad53b6fdc8b65e75d1411934059311fbf">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const xtl::span&lt; const T &gt; &amp;constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs)</td></tr>
<tr class="memdesc:ad53b6fdc8b65e75d1411934059311fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad53b6fdc8b65e75d1411934059311fbf">More...</a><br /></td></tr>
<tr class="separator:ad53b6fdc8b65e75d1411934059311fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3a1fadafb513e38d9176835746c6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60d3a1fadafb513e38d9176835746c6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60d3a1fadafb513e38d9176835746c6b">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs)</td></tr>
<tr class="memdesc:a60d3a1fadafb513e38d9176835746c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60d3a1fadafb513e38d9176835746c6b">More...</a><br /></td></tr>
<tr class="separator:a60d3a1fadafb513e38d9176835746c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2630d5f9c2aae574d3b8d275145c97c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2630d5f9c2aae574d3b8d275145c97c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa2630d5f9c2aae574d3b8d275145c97c">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const xtl::span&lt; const T &gt; &amp;constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;coefficients, const std::vector&lt; bool &gt; &amp;dof_marker0, const std::vector&lt; bool &gt; &amp;dof_marker1)</td></tr>
<tr class="memdesc:aa2630d5f9c2aae574d3b8d275145c97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa2630d5f9c2aae574d3b8d275145c97c">More...</a><br /></td></tr>
<tr class="separator:aa2630d5f9c2aae574d3b8d275145c97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf99ae072832072ed604cae6520c1e78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf99ae072832072ed604cae6520c1e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#abf99ae072832072ed604cae6520c1e78">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const std::vector&lt; bool &gt; &amp;dof_marker0, const std::vector&lt; bool &gt; &amp;dof_marker1)</td></tr>
<tr class="memdesc:abf99ae072832072ed604cae6520c1e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#abf99ae072832072ed604cae6520c1e78">More...</a><br /></td></tr>
<tr class="separator:abf99ae072832072ed604cae6520c1e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24596a7f233417b3af5cc471e5ffe8be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24596a7f233417b3af5cc471e5ffe8be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a24596a7f233417b3af5cc471e5ffe8be">set_diagonal</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;set_fn, const xtl::span&lt; const std::int32_t &gt; &amp;rows, T diagonal=1.0)</td></tr>
<tr class="memdesc:a24596a7f233417b3af5cc471e5ffe8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of a matrix for specified rows. It is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a24596a7f233417b3af5cc471e5ffe8be">More...</a><br /></td></tr>
<tr class="separator:a24596a7f233417b3af5cc471e5ffe8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c70dfe8f4deae9a68eb13cc9b9bcb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1c70dfe8f4deae9a68eb13cc9b9bcb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac1c70dfe8f4deae9a68eb13cc9b9bcb2">set_diagonal</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;set_fn, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, T diagonal=1.0)</td></tr>
<tr class="memdesc:ac1c70dfe8f4deae9a68eb13cc9b9bcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ac1c70dfe8f4deae9a68eb13cc9b9bcb2">More...</a><br /></td></tr>
<tr class="separator:ac1c70dfe8f4deae9a68eb13cc9b9bcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add975f1a917a766ec8beec3bb0a4ee2d"><td class="memTemplParams" colspan="2"><a id="add975f1a917a766ec8beec3bb0a4ee2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add975f1a917a766ec8beec3bb0a4ee2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#add975f1a917a766ec8beec3bb0a4ee2d">set_bc</a> (xtl::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, const xtl::span&lt; const T &gt; &amp;x0, double scale=1.0)</td></tr>
<tr class="memdesc:add975f1a917a766ec8beec3bb0a4ee2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the vector, multiplied by 'scale'. The vectors b and x0 must have the same local size. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:add975f1a917a766ec8beec3bb0a4ee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7741794a8c818a22f8e30cf5a35cbbd1"><td class="memTemplParams" colspan="2"><a id="a7741794a8c818a22f8e30cf5a35cbbd1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7741794a8c818a22f8e30cf5a35cbbd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7741794a8c818a22f8e30cf5a35cbbd1">set_bc</a> (xtl::span&lt; T &gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, double scale=1.0)</td></tr>
<tr class="memdesc:a7741794a8c818a22f8e30cf5a35cbbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the vector, multiplied by 'scale'. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a7741794a8c818a22f8e30cf5a35cbbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e018fa82764bea50b1c7eef6563e9f"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab2e018fa82764bea50b1c7eef6563e9f">locate_dofs_topological</a> (const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;V, int dim, const xtl::span&lt; const std::int32_t &gt; &amp;entities, bool remote=true)</td></tr>
<tr class="memdesc:ab2e018fa82764bea50b1c7eef6563e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab2e018fa82764bea50b1c7eef6563e9f">More...</a><br /></td></tr>
<tr class="separator:ab2e018fa82764bea50b1c7eef6563e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a095252c57d5f95f4ee760f8c31c71"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab6a095252c57d5f95f4ee760f8c31c71">locate_dofs_topological</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, int dim, const xtl::span&lt; const std::int32_t &gt; &amp;entities, bool remote=true)</td></tr>
<tr class="memdesc:ab6a095252c57d5f95f4ee760f8c31c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab6a095252c57d5f95f4ee760f8c31c71">More...</a><br /></td></tr>
<tr class="separator:ab6a095252c57d5f95f4ee760f8c31c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1950835d7d07f817807433f2b01df8"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#acb1950835d7d07f817807433f2b01df8">locate_dofs_geometrical</a> (const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;V, const std::function&lt; xt::xtensor&lt; bool, 1 &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;marker_fn)</td></tr>
<tr class="memdesc:acb1950835d7d07f817807433f2b01df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds degrees of freedom whose geometric coordinate is true for the provided marking function.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#acb1950835d7d07f817807433f2b01df8">More...</a><br /></td></tr>
<tr class="separator:acb1950835d7d07f817807433f2b01df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777fae8f0a61d67bec38f742b495a78a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a777fae8f0a61d67bec38f742b495a78a">locate_dofs_geometrical</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, const std::function&lt; xt::xtensor&lt; bool, 1 &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;marker_fn)</td></tr>
<tr class="memdesc:a777fae8f0a61d67bec38f742b495a78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds degrees of freedom whose geometric coordinate is true for the provided marking function.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a777fae8f0a61d67bec38f742b495a78a">More...</a><br /></td></tr>
<tr class="separator:a777fae8f0a61d67bec38f742b495a78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50efc1fce5638e32eb2918517169b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a50efc1fce5638e32eb2918517169b2">create_sparsity_discrete_gradient</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V0, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V1)</td></tr>
<tr class="separator:a7a50efc1fce5638e32eb2918517169b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539464f3bb32d9f0cb203f1680fa43d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6539464f3bb32d9f0cb203f1680fa43d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6539464f3bb32d9f0cb203f1680fa43d">assemble_discrete_gradient</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_set, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V0, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V1)</td></tr>
<tr class="separator:a6539464f3bb32d9f0cb203f1680fa43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9517bafb7a6c87aa8e8906d483564934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9517bafb7a6c87aa8e8906d483564934">transpose_dofmap</a> (const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;dofmap, std::int32_t num_cells)</td></tr>
<tr class="memdesc:a9517bafb7a6c87aa8e8906d483564934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9517bafb7a6c87aa8e8906d483564934">More...</a><br /></td></tr>
<tr class="separator:a9517bafb7a6c87aa8e8906d483564934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568019b8dc7049d6ab68db4de94a03df"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a568019b8dc7049d6ab68db4de94a03df">build_dofmap_data</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;element_dof_layout, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn)</td></tr>
<tr class="memdesc:a568019b8dc7049d6ab68db4de94a03df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build dofmap data for an element on a mesh topology.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a568019b8dc7049d6ab68db4de94a03df">More...</a><br /></td></tr>
<tr class="separator:a568019b8dc7049d6ab68db4de94a03df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt; &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa3f56a7d7c65eb949973e8d75ae0c57b">common_function_spaces</a> (const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt;, 2 &gt;&gt;&gt; &amp;V)</td></tr>
<tr class="memdesc:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa3f56a7d7c65eb949973e8d75ae0c57b">More...</a><br /></td></tr>
<tr class="separator:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd0b30d0fa6e4703dda3f383f996ef1"><td class="memItemLeft" align="right" valign="top">xt::xtensor&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1">interpolation_coords</a> (const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a> &amp;element, const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;mesh, const xtl::span&lt; const std::int32_t &gt; &amp;cells)</td></tr>
<tr class="memdesc:afdd0b30d0fa6e4703dda3f383f996ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite elemenet space.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1">More...</a><br /></td></tr>
<tr class="separator:afdd0b30d0fa6e4703dda3f383f996ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a494521aa3ee38038c3ba75068aab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a923a494521aa3ee38038c3ba75068aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a923a494521aa3ee38038c3ba75068aab">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const std::function&lt; xt::xarray&lt; T &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;f, const xt::xtensor&lt; double, 2 &gt; &amp;x, const xtl::span&lt; const std::int32_t &gt; &amp;cells)</td></tr>
<tr class="memdesc:a923a494521aa3ee38038c3ba75068aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an expression in a finite element space.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a923a494521aa3ee38038c3ba75068aab">More...</a><br /></td></tr>
<tr class="separator:a923a494521aa3ee38038c3ba75068aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7973ff1373796301742418646957bba6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7973ff1373796301742418646957bba6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7973ff1373796301742418646957bba6">interpolate_c</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const std::function&lt; void(xt::xarray&lt; T &gt; &amp;, const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;f, const xt::xtensor&lt; double, 2 &gt; &amp;x, const xtl::span&lt; const std::int32_t &gt; &amp;cells)</td></tr>
<tr class="memdesc:a7973ff1373796301742418646957bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an expression f(x)  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7973ff1373796301742418646957bba6">More...</a><br /></td></tr>
<tr class="separator:a7973ff1373796301742418646957bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab586fb783800561657947349543c7b97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab586fb783800561657947349543c7b97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab586fb783800561657947349543c7b97">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ab586fb783800561657947349543c7b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> to another on the same mesh.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab586fb783800561657947349543c7b97">More...</a><br /></td></tr>
<tr class="separator:ab586fb783800561657947349543c7b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff58ad3b83346acac128fd187bfe7026"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aff58ad3b83346acac128fd187bfe7026">create_matrix</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;a, const std::string &amp;type=std::string())</td></tr>
<tr class="memdesc:aff58ad3b83346acac128fd187bfe7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aff58ad3b83346acac128fd187bfe7026">More...</a><br /></td></tr>
<tr class="separator:aff58ad3b83346acac128fd187bfe7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26e890498285d9fed8dc340afe4ae2b"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad26e890498285d9fed8dc340afe4ae2b">create_matrix_block</a> (const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; * &gt;&gt; &amp;a, const std::string &amp;type=std::string())</td></tr>
<tr class="memdesc:ad26e890498285d9fed8dc340afe4ae2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a monolithic matrix for an array of bilinear forms.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad26e890498285d9fed8dc340afe4ae2b">More...</a><br /></td></tr>
<tr class="separator:ad26e890498285d9fed8dc340afe4ae2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aae0a2af49fec107c0d51924c8b21ff"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9aae0a2af49fec107c0d51924c8b21ff">create_matrix_nest</a> (const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; * &gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;types)</td></tr>
<tr class="memdesc:a9aae0a2af49fec107c0d51924c8b21ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create nested (MatNest) matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9aae0a2af49fec107c0d51924c8b21ff">More...</a><br /></td></tr>
<tr class="separator:a9aae0a2af49fec107c0d51924c8b21ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5caf913e817b349649243db0450ae2"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5a5caf913e817b349649243db0450ae2">create_vector_block</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:a5a5caf913e817b349649243db0450ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise monolithic vector. Vector is not zeroed.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5a5caf913e817b349649243db0450ae2">More...</a><br /></td></tr>
<tr class="separator:a5a5caf913e817b349649243db0450ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb98ee97de5ced5e4f3a2a0ce07fa074"><td class="memItemLeft" align="right" valign="top"><a id="adb98ee97de5ced5e4f3a2a0ce07fa074"></a>
Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#adb98ee97de5ced5e4f3a2a0ce07fa074">create_vector_nest</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:adb98ee97de5ced5e4f3a2a0ce07fa074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create nested (VecNest) vector. Vector is not zeroed. <br /></td></tr>
<tr class="separator:adb98ee97de5ced5e4f3a2a0ce07fa074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc7e9edd1d757afdd9b49ef773df51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a23cc7e9edd1d757afdd9b49ef773df51">assemble_vector_petsc</a> (Vec b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;L, const xtl::span&lt; const PetscScalar &gt; &amp;constants, const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const PetscScalar &gt;, int &gt;&gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a23cc7e9edd1d757afdd9b49ef773df51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a23cc7e9edd1d757afdd9b49ef773df51">More...</a><br /></td></tr>
<tr class="separator:a23cc7e9edd1d757afdd9b49ef773df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3244047c43f91367032ec2568c613dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3244047c43f91367032ec2568c613dd3">assemble_vector_petsc</a> (Vec b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;L)</td></tr>
<tr class="memdesc:a3244047c43f91367032ec2568c613dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3244047c43f91367032ec2568c613dd3">More...</a><br /></td></tr>
<tr class="separator:a3244047c43f91367032ec2568c613dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51758a09dff53938a0de8641f9df01b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a51758a09dff53938a0de8641f9df01b9">apply_lifting_petsc</a> (Vec b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;a, const std::vector&lt; xtl::span&lt; const PetscScalar &gt;&gt; &amp;constants, const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const PetscScalar &gt;, int &gt;&gt;&gt; &amp;coeffs, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; Vec &gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a51758a09dff53938a0de8641f9df01b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a51758a09dff53938a0de8641f9df01b9">More...</a><br /></td></tr>
<tr class="separator:a51758a09dff53938a0de8641f9df01b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8057875ef52f435031ee4b338923be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8e8057875ef52f435031ee4b338923be">apply_lifting_petsc</a> (Vec b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; Vec &gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a8e8057875ef52f435031ee4b338923be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8e8057875ef52f435031ee4b338923be">More...</a><br /></td></tr>
<tr class="separator:a8e8057875ef52f435031ee4b338923be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="memItemLeft" align="right" valign="top"><a id="a73dd695c33e25c38ded0c8664a2f4d8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a73dd695c33e25c38ded0c8664a2f4d8c">set_bc_petsc</a> (Vec b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt; &amp;bcs, const Vec x0, double scale=1.0)</td></tr>
<tr class="memdesc:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the PETScVector, multiplied by 'scale'. The vectors b and x0 must have the same local size. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee367fc95a901b9c8d53d5c019cb112"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acee367fc95a901b9c8d53d5c019cb112"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#acee367fc95a901b9c8d53d5c019cb112">extract_function_spaces</a> (const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; T &gt; * &gt;&gt; &amp;a)</td></tr>
<tr class="memdesc:acee367fc95a901b9c8d53d5c019cb112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#acee367fc95a901b9c8d53d5c019cb112">More...</a><br /></td></tr>
<tr class="separator:acee367fc95a901b9c8d53d5c019cb112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefced23767b97f6cc040b07627f9522"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afefced23767b97f6cc040b07627f9522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afefced23767b97f6cc040b07627f9522">create_sparsity_pattern</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:afefced23767b97f6cc040b07627f9522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#afefced23767b97f6cc040b07627f9522">More...</a><br /></td></tr>
<tr class="separator:afefced23767b97f6cc040b07627f9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3975a3da77252b493958bf315f5aae"><td class="memItemLeft" align="right" valign="top"><a id="aad3975a3da77252b493958bf315f5aae"></a>
<a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aad3975a3da77252b493958bf315f5aae">create_sparsity_pattern</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> &gt;, 2 &gt; &amp;dofmaps, const std::set&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a> &gt; &amp;integrals)</td></tr>
<tr class="memdesc:aad3975a3da77252b493958bf315f5aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. <br /></td></tr>
<tr class="separator:aad3975a3da77252b493958bf315f5aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a036e445b82a114f05794c73203953e"><td class="memItemLeft" align="right" valign="top"><a id="a5a036e445b82a114f05794c73203953e"></a>
<a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5a036e445b82a114f05794c73203953e">create_element_dof_layout</a> (const ufc_dofmap &amp;dofmap, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a9e741697bed34b75e9564e99feac4367">mesh::CellType</a> cell_type, const std::vector&lt; int &gt; &amp;parent_map={})</td></tr>
<tr class="memdesc:a5a036e445b82a114f05794c73203953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html" title="The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh ent...">ElementDofLayout</a> from a ufc_dofmap. <br /></td></tr>
<tr class="separator:a5a036e445b82a114f05794c73203953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cfa25c0df5b402aff1a26337f4cf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a78cfa25c0df5b402aff1a26337f4cf64">create_dofmap</a> (MPI_Comm comm, const ufc_dofmap &amp;dofmap, <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn, std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">dolfinx::fem::FiniteElement</a> &gt; element)</td></tr>
<tr class="memdesc:a78cfa25c0df5b402aff1a26337f4cf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dof map on mesh from a ufc_dofmap.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a78cfa25c0df5b402aff1a26337f4cf64">More...</a><br /></td></tr>
<tr class="separator:a78cfa25c0df5b402aff1a26337f4cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1922184233dd7810487d11b7a8a041b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad1922184233dd7810487d11b7a8a041b">get_coefficient_names</a> (const ufc_form &amp;ufc_form)</td></tr>
<tr class="memdesc:ad1922184233dd7810487d11b7a8a041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each coefficient in a UFC form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad1922184233dd7810487d11b7a8a041b">More...</a><br /></td></tr>
<tr class="separator:ad1922184233dd7810487d11b7a8a041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aeef8c5d7afb948b36c9c3e73bdf0d57c">get_constant_names</a> (const ufc_form &amp;ufc_form)</td></tr>
<tr class="memdesc:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each constant in a UFC form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aeef8c5d7afb948b36c9c3e73bdf0d57c">More...</a><br /></td></tr>
<tr class="separator:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e81a6709aca5199ecc943520543b80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52e81a6709aca5199ecc943520543b80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a52e81a6709aca5199ecc943520543b80">create_form</a> (const ufc_form &amp;ufc_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:a52e81a6709aca5199ecc943520543b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a52e81a6709aca5199ecc943520543b80">More...</a><br /></td></tr>
<tr class="separator:a52e81a6709aca5199ecc943520543b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aee048b92a2f1d3ab229f04a1e1adad98">create_form</a> (const ufc_form &amp;ufc_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:aee048b92a2f1d3ab229f04a1e1adad98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aee048b92a2f1d3ab229f04a1e1adad98">More...</a><br /></td></tr>
<tr class="separator:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9931df165659ebf9bae1a8374d1ca60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9931df165659ebf9bae1a8374d1ca60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad9931df165659ebf9bae1a8374d1ca60">create_form</a> (ufc_form *(*fptr)(), const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:ad9931df165659ebf9bae1a8374d1ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> using a factory function that returns a pointer to a ufc_form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad9931df165659ebf9bae1a8374d1ca60">More...</a><br /></td></tr>
<tr class="separator:ad9931df165659ebf9bae1a8374d1ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d05edd2f15cbe0ab356602ce9dac9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af4d05edd2f15cbe0ab356602ce9dac9e">create_functionspace</a> (ufc_function_space *(*fptr)(const char *), const std::string &amp;function_name, std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; mesh, const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;reorder_fn=nullptr)</td></tr>
<tr class="memdesc:af4d05edd2f15cbe0ab356602ce9dac9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC data.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#af4d05edd2f15cbe0ab356602ce9dac9e">More...</a><br /></td></tr>
<tr class="separator:af4d05edd2f15cbe0ab356602ce9dac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4150be9e64e2494c43d6bb12de3351b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4150be9e64e2494c43d6bb12de3351b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; T &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af4150be9e64e2494c43d6bb12de3351b">pack_coefficients</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;u, <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">fem::IntegralType</a> integral_type, int id)</td></tr>
<tr class="memdesc:af4150be9e64e2494c43d6bb12de3351b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> u for a given integral type and domain id.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#af4150be9e64e2494c43d6bb12de3351b">More...</a><br /></td></tr>
<tr class="separator:af4150be9e64e2494c43d6bb12de3351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1805acf2c54b0fda3a42225a683d51c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1805acf2c54b0fda3a42225a683d51c3"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; std::vector&lt; T &gt;, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a1805acf2c54b0fda3a42225a683d51c3">pack_coefficients</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a1805acf2c54b0fda3a42225a683d51c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a>.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a1805acf2c54b0fda3a42225a683d51c3">More...</a><br /></td></tr>
<tr class="separator:a1805acf2c54b0fda3a42225a683d51c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58646b5585ad334eecf5d03491be2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf58646b5585ad334eecf5d03491be2f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; T &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aaf58646b5585ad334eecf5d03491be2f">pack_coefficients</a> (const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T &gt; &amp;u, const xtl::span&lt; const std::int32_t &gt; &amp;active_cells)</td></tr>
<tr class="memdesc:aaf58646b5585ad334eecf5d03491be2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of a <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell....">Expression</a> u for a give list of active cells.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aaf58646b5585ad334eecf5d03491be2f">More...</a><br /></td></tr>
<tr class="separator:aaf58646b5585ad334eecf5d03491be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2592f3e164abea8ac0a3999ef2055176"><td class="memTemplParams" colspan="2"><a id="a2592f3e164abea8ac0a3999ef2055176"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2592f3e164abea8ac0a3999ef2055176"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename U::scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2592f3e164abea8ac0a3999ef2055176">pack_constants</a> (const U &amp;u)</td></tr>
<tr class="memdesc:a2592f3e164abea8ac0a3999ef2055176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack constants of u of generic type U ready for assembly. <br /></td></tr>
<tr class="separator:a2592f3e164abea8ac0a3999ef2055176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite element method functionality. </p>
<p>Classes and algorithms for finite element method spaces and operations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3418f00b84aa9095bf3c60af46e428d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3418f00b84aa9095bf3c60af46e428d2">&#9670;&nbsp;</a></span>apply_lifting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting </td>
          <td>(</td>
          <td class="paramtype">xtl::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a60fc3c8fb15d06a35682db45835c04aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fc3c8fb15d06a35682db45835c04aa">&#9670;&nbsp;</a></span>apply_lifting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting </td>
          <td>(</td>
          <td class="paramtype">xtl::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; xtl::span&lt; const T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a8e8057875ef52f435031ee4b338923be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8057875ef52f435031ee4b338923be">&#9670;&nbsp;</a></span>apply_lifting_petsc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a51758a09dff53938a0de8641f9df01b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51758a09dff53938a0de8641f9df01b9">&#9670;&nbsp;</a></span>apply_lifting_petsc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; xtl::span&lt; const PetscScalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const PetscScalar &gt;, int &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a6539464f3bb32d9f0cb203f1680fa43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539464f3bb32d9f0cb203f1680fa43d">&#9670;&nbsp;</a></span>assemble_discrete_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_discrete_gradient </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000006">Todo:</a></b></dt><dd>Improve documentation This function class computes discrete gradient operators (matrices) that map derivatives of finite element functions into other finite element spaces. An example of where discrete gradient operators are required is the creation of algebraic multigrid solvers for H(curl) and H(div) problems.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is highly experimental and likely to change or be replaced or be removed</dd></dl>
<p>Build the discrete gradient operator A that takes a \(w \in H^1\) (P1, nodal Lagrange) to \(v \in H(curl)\) (lowest order Nedelec), i.e. v = Aw. V0 is the H(curl) space, and V1 is the P1 Lagrange space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_set</td><td>A function (or lambda capture) to set values in a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>A H(curl) space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>A P1 Lagrange space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sparsity pattern </dd></dl>

</div>
</div>
<a id="abf99ae072832072ed604cae6520c1e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf99ae072832072ed604cae6520c1e78">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60d3a1fadafb513e38d9176835746c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d3a1fadafb513e38d9176835746c6b">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2630d5f9c2aae574d3b8d275145c97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2630d5f9c2aae574d3b8d275145c97c">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad53b6fdc8b65e75d1411934059311fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53b6fdc8b65e75d1411934059311fbf">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Constants that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficients that appear in <code>a</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a1bf9501710367c63159980f429bda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1bf9501710367c63159980f429bda3">&#9670;&nbsp;</a></span>assemble_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dolfinx::fem::assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. </p>
<dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="aea9d6f1e1c3dd48089cba92ea7b4ce48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d6f1e1c3dd48089cba92ea7b4ce48">&#9670;&nbsp;</a></span>assemble_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dolfinx::fem::assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p>
<dl class="section note"><dt>Note</dt><dd>Caller is responsible for accumulation across processes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>M</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>M</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="a49626b25e5a7804b776b0fb59529bc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49626b25e5a7804b776b0fb59529bc4a">&#9670;&nbsp;</a></span>assemble_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector </td>
          <td>(</td>
          <td class="paramtype">xtl::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab37f8600c9f1eff0d550872fd1a1d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab37f8600c9f1eff0d550872fd1a1d6a">&#9670;&nbsp;</a></span>assemble_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector </td>
          <td>(</td>
          <td class="paramtype">xtl::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const T &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into a vector, The caller supplies the form constants and coefficients for this version, which has efficiency benefits if the data can be re-used for multiple calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>L</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that appear in <code>L</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3244047c43f91367032ec2568c613dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3244047c43f91367032ec2568c613dd3">&#9670;&nbsp;</a></span>assemble_vector_petsc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The PETsc vector to assemble the form into. The vector must already be initialised with the correct size. The process-local contribution of the form is assembled into this vector. It is not zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear form to assemble </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23cc7e9edd1d757afdd9b49ef773df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cc7e9edd1d757afdd9b49ef773df51">&#9670;&nbsp;</a></span>assemble_vector_petsc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int &gt;, std::pair&lt; xtl::span&lt; const PetscScalar &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The PETsc vector to assemble the form into. The vector must already be initialised with the correct size. The process-local contribution of the form is assembled into this vector. It is not zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>The constants that appear in <code>L</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>The coefficients that appear in <code>L</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a568019b8dc7049d6ab68db4de94a03df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568019b8dc7049d6ab68db4de94a03df">&#9670;&nbsp;</a></span>build_dofmap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a>, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; dolfinx::fem::build_dofmap_data </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>element_dof_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build dofmap data for an element on a mesh topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_dof_layout</td><td>The element dof layout for the function space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>Graph reordering function that is applied to the dofmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index map and local to global DOF data for the DOF map </dd></dl>

</div>
</div>
<a id="aa3f56a7d7c65eb949973e8d75ae0c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f56a7d7c65eb949973e8d75ae0c57b">&#9670;&nbsp;</a></span>common_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt; &gt;, 2 &gt; dolfinx::fem::common_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt;, 2 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>Vector function spaces for (0) each row block and (1) each column block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78cfa25c0df5b402aff1a26337f4cf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cfa25c0df5b402aff1a26337f4cf64">&#9670;&nbsp;</a></span>create_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> dolfinx::fem::create_dofmap </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ufc_dofmap &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">dolfinx::fem::FiniteElement</a> &gt;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dof map on mesh from a ufc_dofmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The ufc_dofmap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The finite element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>The graph reordering function called on the dofmap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee048b92a2f1d3ab229f04a1e1adad98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee048b92a2f1d3ab229f04a1e1adad98">&#9670;&nbsp;</a></span>create_form() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>The function spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain makers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain. This is required if the form has no arguments, e.g. a functional </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a52e81a6709aca5199ecc943520543b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e81a6709aca5199ecc943520543b80">&#9670;&nbsp;</a></span>create_form() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>Vector of function spaces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9931df165659ebf9bae1a8374d1ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9931df165659ebf9bae1a8374d1ca60">&#9670;&nbsp;</a></span>create_form() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">ufc_form *(*)()&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> using a factory function that returns a pointer to a ufc_form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td>pointer to a function returning a pointer to ufc_form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>The function spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="af4d05edd2f15cbe0ab356602ce9dac9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d05edd2f15cbe0ab356602ce9dac9e">&#9670;&nbsp;</a></span>create_functionspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> dolfinx::fem::create_functionspace </td>
          <td>(</td>
          <td class="paramtype">ufc_function_space *(*)(const char *)&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reorder_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> Pointer to a ufc_function_space_create function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_name</td><td>Name of a function whose function space to create. <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> name is the name of Python variable for ufl.Coefficient, ufl.TrialFunction or ufl.TestFunction as defined in the UFL file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_fn</td><td>The graph reordering function called on the dofmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created function space </dd></dl>

</div>
</div>
<a id="aff58ad3b83346acac128fd187bfe7026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff58ad3b83346acac128fd187bfe7026">&#9670;&nbsp;</a></span>create_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat dolfinx::fem::create_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The PETSc matrix type to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse matrix with a layout and sparsity that matches the bilinear form. The caller is responsible for destroying the Mat object. </dd></dl>

</div>
</div>
<a id="ad26e890498285d9fed8dc340afe4ae2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26e890498285d9fed8dc340afe4ae2b">&#9670;&nbsp;</a></span>create_matrix_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat dolfinx::fem::create_matrix_block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a monolithic matrix for an array of bilinear forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Rectangular array of bilinear forms. The <code>a(i, j)</code> form will correspond to the <code>(i, j)</code> block in the returned matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of PETSc Mat. If empty the PETSc default is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse matrix with a layout and sparsity that matches the bilinear forms. The caller is responsible for destroying the Mat object. </dd></dl>

</div>
</div>
<a id="a9aae0a2af49fec107c0d51924c8b21ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aae0a2af49fec107c0d51924c8b21ff">&#9670;&nbsp;</a></span>create_matrix_nest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat dolfinx::fem::create_matrix_nest </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create nested (MatNest) matrix. </p>
<p>The caller is responsible for destroying the Mat object </p>

</div>
</div>
<a id="a7a50efc1fce5638e32eb2918517169b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50efc1fce5638e32eb2918517169b2">&#9670;&nbsp;</a></span>create_sparsity_discrete_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> dolfinx::fem::create_sparsity_discrete_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo:</a></b></dt><dd>Improve documentation This function class computes the sparsity pattern for discrete gradient operators (matrices) that map derivatives of finite element functions into other finite element spaces.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is highly experimental and likely to change or be replaced or be removed</dd></dl>
<p>Build the sparsity for the discrete gradient operator A that takes a \(w \in H^1\) (P1, nodal Lagrange) to \(v \in H(curl)\) (lowest order Nedelec), i.e. v = Aw. V0 is the H(curl) space, and V1 is the P1 Lagrange space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>A H(curl) space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>A P1 Lagrange space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sparsity pattern </dd></dl>

</div>
</div>
<a id="afefced23767b97f6cc040b07627f9522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefced23767b97f6cc040b07627f9522">&#9670;&nbsp;</a></span>create_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> dolfinx::fem::create_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding sparsity pattern </dd></dl>

</div>
</div>
<a id="a5a5caf913e817b349649243db0450ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5caf913e817b349649243db0450ae2">&#9670;&nbsp;</a></span>create_vector_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vec dolfinx::fem::create_vector_block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise monolithic vector. Vector is not zeroed. </p>
<p>The caller is responsible for destroying the Mat object </p>

</div>
</div>
<a id="acee367fc95a901b9c8d53d5c019cb112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee367fc95a901b9c8d53d5c019cb112">&#9670;&nbsp;</a></span>extract_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;std::array&lt;std::shared_ptr&lt;const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a>&gt;, 2&gt; &gt; &gt; dolfinx::fem::extract_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; T &gt; * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A rectangular block on bilinear forms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular array of the same shape as <code>a</code> with a pair of function spaces in each array entry. If a form is null, then the returned function space pair is (null, null). </dd></dl>

</div>
</div>
<a id="ad1922184233dd7810487d11b7a8a041b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1922184233dd7810487d11b7a8a041b">&#9670;&nbsp;</a></span>get_coefficient_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dolfinx::fem::get_coefficient_names </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each coefficient in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form return The name of each coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef8c5d7afb948b36c9c3e73bdf0d57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef8c5d7afb948b36c9c3e73bdf0d57c">&#9670;&nbsp;</a></span>get_constant_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dolfinx::fem::get_constant_names </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each constant in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form return The name of each constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab586fb783800561657947349543c7b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab586fb783800561657947349543c7b97">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate from one finite element <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> to another on the same mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The function to be interpolated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a923a494521aa3ee38038c3ba75068aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a494521aa3ee38038c3ba75068aab">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; xt::xarray&lt; T &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an expression in a finite element space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The expression to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which f should be evaluated, as computed by <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. The element used in <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a> should be the same element as associated with u. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh on which to interpolate. Should be the same as the list used when calling <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7973ff1373796301742418646957bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7973ff1373796301742418646957bba6">&#9670;&nbsp;</a></span>interpolate_c()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate_c </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(xt::xarray&lt; T &gt; &amp;, const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xt::xtensor&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an expression f(x) </p>
<dl class="section note"><dt>Note</dt><dd>This interface uses an expression function f that has an in/out argument for the expression values. It is primarily to support C code implementations of the expression, e.g. using Numba. Generally the interface where the expression function is a pure function, i.e. the expression values are the return argument, should be preferred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The expression to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The points at which should be evaluated, as computed by <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh on which to interpolate. Should be the same as the list used when calling <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afdd0b30d0fa6e4703dda3f383f996ef1" title="Compute the evaluation points in the physical space at which an expression should be computed to inte...">fem::interpolation_coords</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdd0b30d0fa6e4703dda3f383f996ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd0b30d0fa6e4703dda3f383f996ef1">&#9670;&nbsp;</a></span>interpolation_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xt::xtensor&lt; double, 2 &gt; dolfinx::fem::interpolation_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">fem::FiniteElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the evaluation points in the physical space at which an expression should be computed to interpolate it in a finite elemenet space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be interpolated into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>Indices of the cells in the mesh to compute interpolation coordinates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates in the physical space at which to evaluate an expression </dd></dl>

</div>
</div>
<a id="a777fae8f0a61d67bec38f742b495a78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777fae8f0a61d67bec38f742b495a78a">&#9670;&nbsp;</a></span>locate_dofs_geometrical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; dolfinx::fem::locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; xt::xtensor&lt; bool, 1 &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees of freedom will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="acb1950835d7d07f817807433f2b01df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1950835d7d07f817807433f2b01df8">&#9670;&nbsp;</a></span>locate_dofs_geometrical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; dolfinx::fem::locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; xt::xtensor&lt; bool, 1 &gt;(const xt::xtensor&lt; double, 2 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space(s) on which degrees of freedom will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the correspinding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="ab6a095252c57d5f95f4ee760f8c31c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a095252c57d5f95f4ee760f8c31c71">&#9670;&nbsp;</a></span>locate_dofs_topological() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::int32_t &gt; dolfinx::fem::locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees-of-freedom (DOFs) will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="ab2e018fa82764bea50b1c7eef6563e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e018fa82764bea50b1c7eef6563e9f">&#9670;&nbsp;</a></span>locate_dofs_topological() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::int32_t &gt;, 2 &gt; dolfinx::fem::locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)spaces on which degrees-of-freedom (DOFs) will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the correspinding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="aaf58646b5585ad334eecf5d03491be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf58646b5585ad334eecf5d03491be2f">&#9670;&nbsp;</a></span>pack_coefficients() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;T&gt;, int&gt; dolfinx::fem::pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell....">Expression</a> u for a give list of active cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell....">Expression</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">active_cells</td><td>A list of active cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of the form (coeffs, cstride) </dd></dl>

</div>
</div>
<a id="a1805acf2c54b0fda3a42225a683d51c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1805acf2c54b0fda3a42225a683d51c3">&#9670;&nbsp;</a></span>pack_coefficients() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;<a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, int&gt;, std::pair&lt;std::vector&lt;T&gt;, int&gt; &gt; dolfinx::fem::pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from a pair of the form (integral_type, domain_id) to a pair of the form (coeffs, cstride) </dd></dl>

</div>
</div>
<a id="af4150be9e64e2494c43d6bb12de3351b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4150be9e64e2494c43d6bb12de3351b">&#9670;&nbsp;</a></span>pack_coefficients() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;T&gt;, int&gt; dolfinx::fem::pack_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">fem::IntegralType</a>&#160;</td>
          <td class="paramname"><em>integral_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack coefficients of a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> u for a given integral type and domain id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">integral_type</td><td>Type of integral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id of the integration domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of the form (coeffs, cstride) </dd></dl>

</div>
</div>
<a id="ac1c70dfe8f4deae9a68eb13cc9b9bcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c70dfe8f4deae9a68eb13cc9b9bcb2">&#9670;&nbsp;</a></span>set_diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::set_diagonal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>set_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space for the rows and columns of the matrix. It is used to extract only the Dirichlet boundary conditions that are define on V or subspaces of V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>The Dirichlet boundary condtions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for rows with a boundary condition applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24596a7f233417b3af5cc471e5ffe8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24596a7f233417b3af5cc471e5ffe8be">&#9670;&nbsp;</a></span>set_diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::set_diagonal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>set_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const xtl::span&lt; const std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to the diagonal of a matrix for specified rows. It is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_fn</td><td>The function for setting values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row blocks, in local indices, for which to add a value to the diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for the specified rows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9517bafb7a6c87aa8e8906d483564934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9517bafb7a6c87aa8e8906d483564934">&#9670;&nbsp;</a></span>transpose_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; dolfinx::fem::transpose_dofmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>num_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index. </p>
<p>If the usual dof map is:</p>
<p>Cell: 0 1 2 3 Global index: [ [0, 3, 5], [3, 2, 4], [4, 3, 2], [2, 1, 0]]</p>
<p>the 'transpose' dof map will be:</p>
<p>Global index: 0 1 2 3 4 5 Unassembled index: [ [0, 11], [10], [4, 8, 9], [1, 3, 7], [5, 6], [2] ]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The standard dof map that for each cell (node) gives the global (process-wise) index of each local (cell-wise) index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>The number of cells (nodes) in <code>dofmap</code> to consider. The first <code>num_cells</code> are used. This is argument is typically used to exclude ghost cell contributions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from global (process-wise) index to positions in an unaassembled array. The links for each node are sorted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

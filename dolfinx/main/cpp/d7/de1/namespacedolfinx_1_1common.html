<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: dolfinx::common Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFINx
   &#160;<span id="projectnumber">0.1.1.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dolfinx</b></li><li class="navelem"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dolfinx::common Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous classes, functions and types.  
<a href="../../d7/de1/namespacedolfinx_1_1common.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d2/dcc/namespacedolfinx_1_1common_1_1subsystem"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dcc/namespacedolfinx_1_1common_1_1subsystem.html">subsystem</a></td></tr>
<tr class="memdesc:d2/dcc/namespacedolfinx_1_1common_1_1subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function in this namesspace are convenience functtions for the initialisation and finalisation of various sub systems, such as <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> and PETSc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the distribution index arrays across processes. An index array is a contiguous collection of N+1 indices [0, 1, . . ., N] that are distributed across M processes. On a given process, the <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html" title="This class represents the distribution index arrays across processes. An index array is a contiguous ...">IndexMap</a> stores a portion of the index set using local indices [0, 1, . . . , n], and a map from the local indices to a unique global index.  <a href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df3/classdolfinx_1_1common_1_1TimeLogger.html">TimeLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html" title="A timer can be used for timing tasks. The basic usage is.">Timer</a> logging.  <a href="../../db/df3/classdolfinx_1_1common_1_1TimeLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddd/classdolfinx_1_1common_1_1TimeLogManager.html">TimeLogManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logger initialisation.  <a href="../../de/ddd/classdolfinx_1_1common_1_1TimeLogManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer can be used for timing tasks. The basic usage is.  <a href="../../d4/d40/classdolfinx_1_1common_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5a/classdolfinx_1_1common_1_1UniqueIdGenerator.html">UniqueIdGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a singleton class that return IDs that are unique in the lifetime of a program.  <a href="../../df/d5a/classdolfinx_1_1common_1_1UniqueIdGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a94d97f920b28f76f8985b704d2794da6"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::int64_t, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::vector&lt; std::int64_t &gt; &gt;, std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#a94d97f920b28f76f8985b704d2794da6">stack_index_maps</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:a94d97f920b28f76f8985b704d2794da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute layout data and ghost indices for a stacked (concatenated) index map, i.e. 'splice' multiple maps into one. Communication is required to compute the new ghost indices.  <a href="../../d7/de1/namespacedolfinx_1_1common.html#a94d97f920b28f76f8985b704d2794da6">More...</a><br /></td></tr>
<tr class="separator:a94d97f920b28f76f8985b704d2794da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed198817f437ba2ec5c76f7c5ccc10c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V &gt; </td></tr>
<tr class="memitem:a9ed198817f437ba2ec5c76f7c5ccc10c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#a9ed198817f437ba2ec5c76f7c5ccc10c">sort_unique</a> (const U &amp;indices, const V &amp;values)</td></tr>
<tr class="memdesc:a9ed198817f437ba2ec5c76f7c5ccc10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort two arrays based on the values in array <code>indices</code>. Any duplicate indices and the corresponding value are removed. In the case of duplicates, the entry with the smallest value is retained.  <a href="../../d7/de1/namespacedolfinx_1_1common.html#a9ed198817f437ba2ec5c76f7c5ccc10c">More...</a><br /></td></tr>
<tr class="separator:a9ed198817f437ba2ec5c76f7c5ccc10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3625530a53fa7854d7d982b72f491631"><td class="memItemLeft" align="right" valign="top"><a id="a3625530a53fa7854d7d982b72f491631"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#a3625530a53fa7854d7d982b72f491631">indent</a> (std::string block)</td></tr>
<tr class="memdesc:a3625530a53fa7854d7d982b72f491631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent string block. <br /></td></tr>
<tr class="separator:a3625530a53fa7854d7d982b72f491631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040ed04cff204bd78aab8f6231382c88"><td class="memTemplParams" colspan="2"><a id="a040ed04cff204bd78aab8f6231382c88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a040ed04cff204bd78aab8f6231382c88"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#a040ed04cff204bd78aab8f6231382c88">container_to_string</a> (const T &amp;x, const int precision, const int linebreak)</td></tr>
<tr class="memdesc:a040ed04cff204bd78aab8f6231382c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a container to string. <br /></td></tr>
<tr class="separator:a040ed04cff204bd78aab8f6231382c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c715f17629d1ccf781b6b7ee70332b"><td class="memTemplParams" colspan="2"><a id="a80c715f17629d1ccf781b6b7ee70332b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a80c715f17629d1ccf781b6b7ee70332b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#a80c715f17629d1ccf781b6b7ee70332b">hash_local</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a80c715f17629d1ccf781b6b7ee70332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hash of a given object. <br /></td></tr>
<tr class="separator:a80c715f17629d1ccf781b6b7ee70332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a128d0fbfb9262e688a9241ac2157c"><td class="memTemplParams" colspan="2"><a id="ac8a128d0fbfb9262e688a9241ac2157c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac8a128d0fbfb9262e688a9241ac2157c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/de1/namespacedolfinx_1_1common.html#ac8a128d0fbfb9262e688a9241ac2157c">hash_global</a> (const MPI_Comm comm, const T &amp;x)</td></tr>
<tr class="memdesc:ac8a128d0fbfb9262e688a9241ac2157c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hash for a distributed (<a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a>) object. A hash is computed on each process, and the hash of the std::vector of all local hash keys is returned. This function is collective. <br /></td></tr>
<tr class="separator:ac8a128d0fbfb9262e688a9241ac2157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous classes, functions and types. </p>
<p>This namespace provides utility type functions for managing subsystems, convenience classes and library-wide typedefs. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9ed198817f437ba2ec5c76f7c5ccc10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed198817f437ba2ec5c76f7c5ccc10c">&#9670;&nbsp;</a></span>sort_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;U, V&gt; dolfinx::common::sort_unique </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort two arrays based on the values in array <code>indices</code>. Any duplicate indices and the corresponding value are removed. In the case of duplicates, the entry with the smallest value is retained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Array of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sorted (indices, values), with sorting based on indices </dd></dl>

</div>
</div>
<a id="a94d97f920b28f76f8985b704d2794da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d97f920b28f76f8985b704d2794da6">&#9670;&nbsp;</a></span>stack_index_maps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::int64_t, std::vector&lt; std::int32_t &gt;, std::vector&lt; std::vector&lt; std::int64_t &gt; &gt;, std::vector&lt; std::vector&lt; int &gt; &gt; &gt; dolfinx::common::stack_index_maps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute layout data and ghost indices for a stacked (concatenated) index map, i.e. 'splice' multiple maps into one. Communication is required to compute the new ghost indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maps</td><td>List of (index map, block size) pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (0) global offset of a stacked map for this rank, (1) local offset for each submap in the stacked map, and (2) new indices for the ghosts for each submap (3) owner rank of each ghost entry for each submap </dd></dl>
<p>Build arrays from old ghost index to composite ghost index for each field</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

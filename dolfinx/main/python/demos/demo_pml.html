

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electromagnetic scattering from a wire with perfectly matched layer condition # noqa &mdash; DOLFINx 0.10.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=15ca63c5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electromagnetic modal analysis for a waveguide" href="demo_half_loaded_waveguide.html" />
    <link rel="prev" title="Electromagnetic scattering from a wire with scattering boundary conditions # noqa" href="demo_scattering_boundary_conditions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DOLFINx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../demos.html">Demos</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#pdes-introductory">PDEs (introductory)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_scattering_boundary_conditions.html">Electromagnetic scattering from a wire with scattering boundary conditions # noqa</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic scattering from a wire with perfectly matched layer condition # noqa</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-problem-definition-and-implementation">Equations, problem definition and implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#post-processing">Post-processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_half_loaded_waveguide.html">Electromagnetic modal analysis for a waveguide</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#pdes-advanced">PDEs (advanced)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#nonlinear-problems">Nonlinear problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#mesh-generation">Mesh generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#interpolation-io-and-visualisation">Interpolation, IO and visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#advanced-iterative-solvers">Advanced iterative solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#user-defined-and-advanced-finite-elements">User-defined and advanced finite elements</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#list-of-all-demos">List of all demos</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_biharmonic.html">Biharmonic equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_cahn-hilliard.html">Cahn-Hilliard equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_stokes.html">Stokes equations using Taylor-Hood elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_elasticity.html">Elasticity using algebraic multigrid</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_gmsh.html">Mesh generation with Gmsh</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_static-condensation.html">Static condensation of linear elasticity</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyvista.html">Visualization with PyVista</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_interpolation-io.html">Interpolation and IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_types.html">Solving PDEs with different scalar (float) types</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_lagrange_variants.html">Variants of Lagrange elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_tnt-elements.html">Creating TNT elements using Basix’s custom element interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_scattering_boundary_conditions.html">Electromagnetic scattering from a wire with scattering boundary conditions # noqa</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic scattering from a wire with perfectly matched layer condition # noqa</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-problem-definition-and-implementation">Equations, problem definition and implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#post-processing">Post-processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_half_loaded_waveguide.html">Electromagnetic modal analysis for a waveguide</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_navier-stokes.html">Divergence conforming discontinuous Galerkin method for the Navier–Stokes equations # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-poisson.html">Mixed formulation of the Poisson equation with a block-preconditioner/solver # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyamg.html">Solve the Poisson and linearised elasticity equations using pyamg</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_hdg.html">HDG scheme for the Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-topology.html">Poisson equation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DOLFINx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../demos.html">Demos</a></li>
      <li class="breadcrumb-item active">Electromagnetic scattering from a wire with perfectly matched layer condition # noqa</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demos/demo_pml.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="electromagnetic-scattering-from-a-wire-with-perfectly-matched-layer-condition-noqa">
<h1>Electromagnetic scattering from a wire with perfectly matched layer condition # noqa<a class="headerlink" href="#electromagnetic-scattering-from-a-wire-with-perfectly-matched-layer-condition-noqa" title="Link to this heading"></a></h1>
<p>Copyright (C) 2022 Michele Castriotta, Igor Baratta, Jørgen S. Dokken</p>
<p>This demo is implemented in three files: one for the mesh generation
with Gmsh, one for the calculation of analytical efficiencies, and one
for the variational forms and the solver. It illustrates how to:</p>
<ul class="simple">
<li><p>Use complex quantities in FEniCSx</p></li>
<li><p>Setup and solve Maxwell’s equations</p></li>
<li><p>Implement (rectangular) perfectly matched layers</p></li>
</ul>
<section id="equations-problem-definition-and-implementation">
<h2>Equations, problem definition and implementation<a class="headerlink" href="#equations-problem-definition-and-implementation" title="Link to this heading"></a></h2>
<p>First, we import the required modules</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>

<span class="k">if</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s2">&quot;petsc4py&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">has_petsc</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires DOLFINx to be compiled with PETSc enabled.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires petsc4py.&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">h2vp</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="n">jvp</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">basix.ufl</span><span class="w"> </span><span class="kn">import</span> <span class="n">element</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_real_type</span><span class="p">,</span> <span class="n">default_scalar_type</span><span class="p">,</span> <span class="n">fem</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearProblem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">gmshio</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">VTXWriter</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires DOLFINx to be configured with adios2.&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">gmsh</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires gmsh to be installed&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pyvista</span>

    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pyvista and pyvistaqt are required to visualise the solution&quot;</span><span class="p">)</span>
    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span>

<span class="c1"># Since we want to solve time-harmonic Maxwell&#39;s equation, we require</span>
<span class="c1"># that the demo is executed with DOLFINx (PETSc) complex mode.</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">default_scalar_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Demo should only be executed with DOLFINx complex mode&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># This file defines the `generate_mesh_wire` function, which is used to</span>
<span class="c1"># generate the mesh used for the PML demo. The mesh is made up by a</span>
<span class="c1"># central circle (the wire), and an external layer (the PML) divided in</span>
<span class="c1"># 4 rectangles and 4 squares at the corners. The `generate_mesh_wire`</span>
<span class="c1"># function takes as input:</span>

<span class="c1"># - `radius_wire`: the radius of the wire</span>
<span class="c1"># - `radius_scatt`: the radius of the circle where scattering efficiency</span>
<span class="c1">#   is calculated</span>
<span class="c1"># - `l_dom`: length of real domain</span>
<span class="c1"># - `l_pml`: length of PML layer</span>
<span class="c1"># - `in_wire_size`: the mesh size at a distance `0.8 * radius_wire` from</span>
<span class="c1">#   the origin</span>
<span class="c1"># - `on_wire_size`: the mesh size on the wire boundary</span>
<span class="c1"># - `scatt_size`: the mesh size on the circle where scattering</span>
<span class="c1">#   efficiency is calculated</span>
<span class="c1"># - `pml_size`: the mesh size on the outer boundary of the PML</span>
<span class="c1"># - `au_tag`: the tag of the physical group representing the wire</span>
<span class="c1"># - `bkg_tag`: the tag of the physical group representing the background</span>
<span class="c1"># - `scatt_tag`: the tag of the physical group representing the boundary</span>
<span class="c1">#   where scattering efficiency is calculated</span>
<span class="c1"># - `pml_tag`: the tag of the physical group representing the PML</span>
<span class="c1">#   (together with pml_tag+1 and pml_tag+2)</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>


<span class="k">def</span><span class="w"> </span><span class="nf">generate_mesh_wire</span><span class="p">(</span>
    <span class="n">radius_wire</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">radius_scatt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">l_dom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">l_pml</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">in_wire_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">on_wire_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">scatt_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">pml_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">au_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bkg_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">scatt_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pml_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1"># A dummy circle for setting a finer mesh</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_wire</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="n">c1</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c1</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="n">c1</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c1</span><span class="p">)</span>

    <span class="n">c2</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_wire</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="n">c2</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c2</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="n">c2</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c2</span><span class="p">)</span>
    <span class="n">wire</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">([(</span><span class="n">dim</span><span class="p">,</span> <span class="n">c2</span><span class="p">)],</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">c1</span><span class="p">)])</span>

    <span class="c1"># A dummy circle for the calculation of the scattering efficiency</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_scatt</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="n">c3</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c3</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="n">c3</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">c3</span><span class="p">)</span>

    <span class="n">r0</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">)</span>
    <span class="n">inclusive_rectangle</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">([(</span><span class="n">dim</span><span class="p">,</span> <span class="n">r0</span><span class="p">)],</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">c3</span><span class="p">)])</span>

    <span class="n">delta_pml</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_pml</span> <span class="o">-</span> <span class="n">l_dom</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">separate_rectangle</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">inclusive_rectangle</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">removeTool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">physical_domain</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">separate_rectangle</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>

    <span class="n">bkg_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">physical_domain</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">separate_rectangle</span><span class="p">)]]</span>

    <span class="n">wire_tags</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">physical_domain</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">separate_rectangle</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">inclusive_rectangle</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">wire</span><span class="p">)]</span>
    <span class="p">]</span>

    <span class="c1"># Corner PMLS</span>
    <span class="n">pml1</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">pml2</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">pml3</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">pml4</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">corner_pmls</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml1</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml2</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml3</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml4</span><span class="p">)]</span>

    <span class="c1"># X pmls</span>
    <span class="n">pml5</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">)</span>
    <span class="n">pml6</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">)</span>
    <span class="n">x_pmls</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml5</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml6</span><span class="p">)]</span>

    <span class="c1"># Y pmls</span>
    <span class="n">pml7</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">pml8</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addRectangle</span><span class="p">(</span><span class="o">-</span><span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">delta_pml</span><span class="p">)</span>
    <span class="n">y_pmls</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml7</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pml8</span><span class="p">)]</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">surface_map</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span><span class="p">,</span> <span class="n">corner_pmls</span> <span class="o">+</span> <span class="n">x_pmls</span> <span class="o">+</span> <span class="n">y_pmls</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

    <span class="n">bkg_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span><span class="p">)]]</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">bkg_group</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">bkg_tag</span><span class="p">)</span>
    <span class="n">wire_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span><span class="p">)]]</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">wire_group</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">au_tag</span><span class="p">)</span>

    <span class="n">corner_group</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span> <span class="o">+</span> <span class="n">corner_pmls</span><span class="p">)]</span>
    <span class="p">]</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">corner_group</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">pml_tag</span><span class="p">)</span>

    <span class="n">x_group</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">[</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span> <span class="o">+</span> <span class="n">corner_pmls</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span> <span class="o">+</span> <span class="n">corner_pmls</span> <span class="o">+</span> <span class="n">x_pmls</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">]</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">x_group</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">pml_tag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">y_group</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">[</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span> <span class="o">+</span> <span class="n">corner_pmls</span> <span class="o">+</span> <span class="n">x_pmls</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">bkg_tags</span> <span class="o">+</span> <span class="n">wire_tags</span> <span class="o">+</span> <span class="n">corner_pmls</span> <span class="o">+</span> <span class="n">x_pmls</span> <span class="o">+</span> <span class="n">y_pmls</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">]</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">y_group</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">pml_tag</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Marker interior surface in bkg group</span>
    <span class="n">boundaries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">bkg_group</span><span class="p">:</span>
        <span class="n">boundary_pairs</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">([(</span><span class="n">dim</span><span class="p">,</span> <span class="n">tag</span><span class="p">)],</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">boundary_pairs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="n">interior_boundary</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">interior_boundary</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">scatt_tag</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">in_wire_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">on_wire_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">scatt_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">pml_size</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span>


<span class="c1"># This file contains a function for the calculation of the</span>
<span class="c1"># absorption, scattering and extinction efficiencies of a wire</span>
<span class="c1"># being hit normally by a TM-polarized electromagnetic wave.</span>
<span class="c1">#</span>
<span class="c1"># The formula are taken from:</span>
<span class="c1"># Milton Kerker, &quot;The Scattering of Light and Other Electromagnetic</span>
<span class="c1"># Radiation&quot;,</span>
<span class="c1"># Chapter 6, Elsevier, 1969.</span>
<span class="c1">#</span>
<span class="c1"># ## Implementation</span>
<span class="c1"># First of all, let&#39;s define the parameters of the problem:</span>
<span class="c1">#</span>
<span class="c1"># - $n = \sqrt{\varepsilon}$: refractive index of the wire,</span>
<span class="c1"># - $n_b$: refractive index of the background medium,</span>
<span class="c1"># - $m = n/n_b$: relative refractive index of the wire,</span>
<span class="c1"># - $\lambda_0$: wavelength of the electromagnetic wave,</span>
<span class="c1"># - $r_w$: radius of the cross-section of the wire,</span>
<span class="c1"># - $\alpha = 2\pi r_w n_b/\lambda_0$.</span>
<span class="c1">#</span>
<span class="c1"># Now, let&#39;s define the $a_\nu$ coefficients as:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># \begin{equation}</span>
<span class="c1"># a_\nu=\frac{J_\nu(\alpha) J_\nu^{\prime}(m \alpha)-m J_\nu(m \alpha)</span>
<span class="c1"># J_\nu^{\prime}(\alpha)}{H_\nu^{(2)}(\alpha) J_\nu^{\prime}(m \alpha)</span>
<span class="c1"># -m J_\nu(m \alpha) H_\nu^{(2){\prime}}(\alpha)}</span>
<span class="c1"># \end{equation}</span>
<span class="c1"># $$</span>
<span class="c1">#</span>
<span class="c1"># where:</span>
<span class="c1"># - $J_\nu(x)$: $\nu$-th order Bessel function of the first kind,</span>
<span class="c1"># - $J_\nu^{\prime}(x)$: first derivative with respect to $x$ of</span>
<span class="c1"># the $\nu$-th order Bessel function of the first kind,</span>
<span class="c1"># - $H_\nu^{(2)}(x)$: $\nu$-th order Hankel function of the second kind,</span>
<span class="c1"># - $H_\nu^{(2){\prime}}(x)$: first derivative with respect to $x$ of</span>
<span class="c1"># the $\nu$-th order Hankel function of the second kind.</span>
<span class="c1">#</span>
<span class="c1"># We can now calculate the scattering, extinction and absorption</span>
<span class="c1"># efficiencies as:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># &amp; q_{\mathrm{sca}}=(2 / \alpha)\left[\left|a_0\right|^{2}</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">incorrectly_encoded_metadata</span><span class="p">:</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="s1">u=1}^{\infty}\left|a_</span><span class="se">\n</span><span class="s1">u</span><span class="se">\r</span><span class="s1">ight|^</span><span class="si">{2}</span><span class="se">\r</span><span class="s1">ight] </span><span class="se">\\</span><span class="s1">&#39;</span>
<span class="p">:</span><span class="n">title</span><span class="p">:</span> <span class="mi">2</span> \<span class="n">sum_</span>

<span class="c1"># &amp; q_{\mathrm{ext}}=(2 / \alpha) \operatorname{Re}\left[ a_0</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">incorrectly_encoded_metadata</span><span class="p">:</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="s1">u=1}^{\infty} a_</span><span class="se">\n</span><span class="s1">u</span><span class="se">\r</span><span class="s1">ight] </span><span class="se">\\</span><span class="s1">&#39;</span>
<span class="p">:</span><span class="n">title</span><span class="p">:</span> <span class="mi">2</span> \<span class="n">sum_</span>

<span class="c1"># &amp; q_{\mathrm{abs}} = q_{\mathrm{ext}} - q_{\mathrm{sca}}</span>
<span class="c1"># $$</span>


<span class="c1"># The functions that we import from `scipy.special` correspond to:</span>
<span class="c1">#</span>
<span class="c1"># - `jv(nu, x)` ⟷ $J_\nu(x)$,</span>
<span class="c1"># - `jvp(nu, x, 1)` ⟷ $J_\nu^{\prime}(x)$,</span>
<span class="c1"># - `hankel2(nu, x)` ⟷ $H_\nu^{(2)}(x)$,</span>
<span class="c1"># - `h2vp(nu, x, 1)` ⟷ $H_\nu^{(2){\prime}}(x)$.</span>
<span class="c1">#</span>
<span class="c1"># Next, we define a function for calculating the analytical efficiencies</span>
<span class="c1"># in Python. The inputs of the function are:</span>
<span class="c1">#</span>
<span class="c1"># - `eps` ⟷ $\varepsilon$,</span>
<span class="c1"># - `n_bkg` ⟷ $n_b$,</span>
<span class="c1"># - `wl0` ⟷ $\lambda_0$,</span>
<span class="c1"># - `radius_wire` ⟷ $r_w$.</span>
<span class="c1">#</span>
<span class="c1"># We also define a nested function for the calculation of $a_l$. For the</span>
<span class="c1"># final calculation of the efficiencies, the summation over the different</span>
<span class="c1"># orders of the Bessel functions is truncated at $\nu=50$.</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">J_nu_alpha</span> <span class="o">=</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">J_nu_malpha</span> <span class="o">=</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">J_nu_alpha_p</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">J_nu_malpha_p</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">H_nu_alpha</span> <span class="o">=</span> <span class="n">hankel2</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">H_nu_alpha_p</span> <span class="o">=</span> <span class="n">h2vp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">a_nu_num</span> <span class="o">=</span> <span class="n">J_nu_alpha</span> <span class="o">*</span> <span class="n">J_nu_malpha_p</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">J_nu_malpha</span> <span class="o">*</span> <span class="n">J_nu_alpha_p</span>
    <span class="n">a_nu_den</span> <span class="o">=</span> <span class="n">H_nu_alpha</span> <span class="o">*</span> <span class="n">J_nu_malpha_p</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">J_nu_malpha</span> <span class="o">*</span> <span class="n">H_nu_alpha_p</span>
    <span class="k">return</span> <span class="n">a_nu_num</span> <span class="o">/</span> <span class="n">a_nu_den</span>


<span class="k">def</span><span class="w"> </span><span class="nf">calculate_analytical_efficiencies</span><span class="p">(</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">wl0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius_wire</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">num_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_bkg</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_wire</span> <span class="o">/</span> <span class="n">wl0</span> <span class="o">*</span> <span class="n">n_bkg</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">alpha</span>
    <span class="n">q_ext</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="n">q_sca</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">q_ext</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
        <span class="n">q_sca</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">q_ext</span> <span class="o">-</span> <span class="n">q_sca</span><span class="p">,</span> <span class="n">q_sca</span><span class="p">,</span> <span class="n">q_ext</span>


<span class="c1"># Now, let&#39;s consider an infinite metallic wire immersed in a background</span>
<span class="c1"># medium (e.g. vacuum or water). Let&#39;s now consider the plane cutting</span>
<span class="c1"># the wire perpendicularly to its axis at a generic point. Such plane</span>
<span class="c1"># $\Omega=\Omega_{m} \cup\Omega_{b}$ is formed by the cross-section of</span>
<span class="c1"># the wire $\Omega_m$ and the background medium $\Omega_{b}$ surrounding</span>
<span class="c1"># the wire. We limit the background medium with a squared perfectly</span>
<span class="c1"># matched layer (or shortly PML), which will act as an absorber for</span>
<span class="c1"># outgoing scattered waves.</span>
<span class="c1">#</span>
<span class="c1"># The goal of this demo is to calculate the electric field</span>
<span class="c1"># $\mathbf{E}_s$ scattered by the wire when a background wave</span>
<span class="c1"># $\mathbf{E}_b$ impinges on it. We will consider a background plane</span>
<span class="c1"># wave at $\lambda_0$ wavelength, which can be written analytically as:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># \mathbf{E}_b = \exp(\mathbf{k}\cdot\mathbf{r})\hat{\mathbf{u}}_p</span>
<span class="c1"># $$</span>
<span class="c1">#</span>
<span class="c1"># with $\mathbf{k} = \frac{2\pi}{\lambda_0}n_b\hat{\mathbf{u}}_k$ being</span>
<span class="c1"># the wavevector of the plane wave, pointing along the propagation</span>
<span class="c1"># direction, with $\hat{\mathbf{u}}_p$ being the polarization direction,</span>
<span class="c1"># and with $\mathbf{r}$ being a point in $\Omega$. We will only consider</span>
<span class="c1"># $\hat{\mathbf{u}}_k$ and $\hat{\mathbf{u}}_p$ with components</span>
<span class="c1"># belonging to the $\Omega$ domain and perpendicular to each other, i.e.</span>
<span class="c1"># $\hat{\mathbf{u}}_k \perp \hat{\mathbf{u}}_p$ (transversality</span>
<span class="c1"># condition of plane waves). Using a Cartesian coordinate system for</span>
<span class="c1"># $\Omega$, and by defining $k_x = n_bk_0\cos\theta$ and $k_y =</span>
<span class="c1"># n_bk_0\sin\theta$, with $\theta$ being the angle defined by the</span>
<span class="c1"># propagation direction $\hat{\mathbf{u}}_k$ and the horizontal axis</span>
<span class="c1"># $\hat{\mathbf{u}}_x$, we have:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># \mathbf{E}_b = -\sin\theta e^{j (k_xx+k_yy)}\hat{\mathbf{u}}_x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">incorrectly_encoded_metadata</span><span class="p">:</span> <span class="s1">&#39;{j (k_xx+k_yy)}\hat{\mathbf</span><span class="si">{u}</span><span class="s1">}_y&#39;</span>
<span class="p">:</span><span class="n">title</span><span class="p">:</span> \<span class="n">cos</span>\<span class="n">theta</span> <span class="n">e</span><span class="o">^</span>

<span class="c1"># $$</span>
<span class="c1">#</span>
<span class="c1"># The function `background_field` below implements this analytical</span>
<span class="c1"># formula:</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">background_field</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_b</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]):</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="n">n_b</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">ky</span> <span class="o">=</span> <span class="n">n_b</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">kx</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ky</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>
</pre></div>
</div>
<p>For convenience, we define the <span class="math notranslate nohighlight">\(\nabla\times\)</span> operator for a 2D vector</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">curl_2d</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p>Let’s now see how we can implement PMLs for our problem. PMLs are
artificial layers surrounding the real domain that gradually absorb
waves impinging them. Mathematically, we can use a complex coordinate
transformation of this kind to obtain this absorption:</p>
<div class="math notranslate nohighlight">
\[
x^\prime= x\left\{1+j\frac{\alpha}{k_0}\left[\frac{|x|-l_{dom}/2}
{(l_{pml}/2 - l_{dom}/2)^2}\right] \right\}
\]</div>
<p>with <span class="math notranslate nohighlight">\(l_{dom}\)</span> and <span class="math notranslate nohighlight">\(l_{pml}\)</span> being the lengths of the domain without
and with PML, respectively, and with <span class="math notranslate nohighlight">\(\alpha\)</span> being a parameter that
tunes the absorption within the PML (the bigger the <span class="math notranslate nohighlight">\(\alpha\)</span>, the
faster the absorption). In DOLFINx, we can define this coordinate
transformation in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">indexed</span><span class="o">.</span><span class="n">Indexed</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">algebra</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">l_pml</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We use the following domain specific parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Constants</span>
<span class="n">epsilon_0</span> <span class="o">=</span> <span class="mf">8.8541878128</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">12</span>
<span class="n">mu_0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">7</span>

<span class="c1"># Radius of the wire and of the boundary of the domain</span>
<span class="n">radius_wire</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">l_dom</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="n">radius_scatt</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">l_dom</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">l_pml</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># The smaller the mesh_factor, the finer is the mesh</span>
<span class="n">mesh_factor</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Mesh size inside the wire</span>
<span class="n">in_wire_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">6e-3</span>

<span class="c1"># Mesh size at the boundary of the wire</span>
<span class="n">on_wire_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">3.0e-3</span>

<span class="c1"># Mesh size in the background</span>
<span class="n">scatt_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">15.0e-3</span>

<span class="c1"># Mesh size at the boundary</span>
<span class="n">pml_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">15.0e-3</span>

<span class="c1"># Tags for the subdomains</span>
<span class="n">au_tag</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">bkg_tag</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">scatt_tag</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">pml_tag</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>We generate the mesh using GMSH and convert it to a
<code class="docutils literal notranslate"><span class="pre">dolfinx.mesh.Mesh</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="k">if</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">generate_mesh_wire</span><span class="p">(</span>
        <span class="n">radius_wire</span><span class="p">,</span>
        <span class="n">radius_scatt</span><span class="p">,</span>
        <span class="n">l_dom</span><span class="p">,</span>
        <span class="n">l_pml</span><span class="p">,</span>
        <span class="n">in_wire_size</span><span class="p">,</span>
        <span class="n">on_wire_size</span><span class="p">,</span>
        <span class="n">scatt_size</span><span class="p">,</span>
        <span class="n">pml_size</span><span class="p">,</span>
        <span class="n">au_tag</span><span class="p">,</span>
        <span class="n">bkg_tag</span><span class="p">,</span>
        <span class="n">scatt_tag</span><span class="p">,</span>
        <span class="n">pml_tag</span><span class="p">,</span>
    <span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">partitioner</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">create_cell_partitioner</span><span class="p">(</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">GhostMode</span><span class="o">.</span><span class="n">shared_facet</span><span class="p">)</span>

<span class="n">mesh_data</span> <span class="o">=</span> <span class="n">gmshio</span><span class="o">.</span><span class="n">model_to_mesh</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gdim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="n">partitioner</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Cell tags are missing&quot;</span>
<span class="k">assert</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">facet_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Facet tags are missing&quot;</span>

<span class="n">gmsh</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
<span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
</pre></div>
</div>
<p>We visualize the mesh and subdomains with
<a class="reference external" href="https://docs.pyvista.org/">PyVista</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tdim</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
<span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
    <span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">geometry</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
    <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
    <span class="n">num_local_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">index_map</span><span class="p">(</span><span class="n">tdim</span><span class="p">)</span><span class="o">.</span><span class="n">size_local</span>
    <span class="n">grid</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s2">&quot;Marker&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">values</span><span class="p">[</span>
        <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="n">num_local_cells</span>
    <span class="p">]</span>
    <span class="n">grid</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Marker&quot;</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
        <span class="n">figure</span> <span class="o">=</span> <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;wire_mesh_pml.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">])</span>
</pre></div>
</div>
<p>We observe five different subdomains: one for the gold wire
(<code class="docutils literal notranslate"><span class="pre">au_tag</span></code>), one for the background medium (<code class="docutils literal notranslate"><span class="pre">bkg_tag</span></code>), one for the PML
corners (<code class="docutils literal notranslate"><span class="pre">pml_tag</span></code>), one for the PML rectangles along <span class="math notranslate nohighlight">\(x\)</span> (<code class="docutils literal notranslate"><span class="pre">pml_tag</span> <span class="pre">+</span> <span class="pre">1</span></code>), and one for the PML rectangles along <span class="math notranslate nohighlight">\(y\)</span> (<code class="docutils literal notranslate"><span class="pre">pml_tag</span> <span class="pre">+</span> <span class="pre">2</span></code>). These
different PML regions have different coordinate transformation, as
specified here below:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\text{PML}_\text{corners} \rightarrow \mathbf{r}^\prime &amp;= (x^\prime,
  y^\prime) \\
\text{PML}_\text{rectangles along x} \rightarrow
  \mathbf{r}^\prime &amp;= (x^\prime, y) \\
\text{PML}_\text{rectangles along y} \rightarrow
  \mathbf{r}^\prime &amp;= (x, y^\prime).
\end{align}
\end{split}\]</div>
<p>Now we define some other problem specific parameters:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wl0</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># Wavelength of the background field</span>
<span class="n">n_bkg</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Background refractive index</span>
<span class="n">eps_bkg</span> <span class="o">=</span> <span class="n">n_bkg</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Background relative permittivity</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wl0</span>  <span class="c1"># Wavevector of the background field</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Angle of incidence of the background field</span>
</pre></div>
</div>
<p>We use a degree 3
<a class="reference external" href="https://defelement.org/elements/nedelec1.html">Nedelec (first kind)</a>
element to represent the electric field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">degree</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">curl_el</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;N1curl&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">basix_cell</span><span class="p">(),</span> <span class="n">degree</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">default_real_type</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">curl_el</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we interpolate <span class="math notranslate nohighlight">\(\mathbf{E}_b\)</span> into the function space <span class="math notranslate nohighlight">\(V\)</span>,
define our trial and test function, and the integration domains:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Eb</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">background_field</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">k0</span><span class="p">)</span>
<span class="n">Eb</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c1"># Definition of Trial and Test functions</span>
<span class="n">Es</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Definition of 3d fields</span>
<span class="n">Es_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">Es</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Es</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">v_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Measures for subdomains</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;dx&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="p">)</span>
<span class="n">dDom</span> <span class="o">=</span> <span class="n">dx</span><span class="p">((</span><span class="n">au_tag</span><span class="p">,</span> <span class="n">bkg_tag</span><span class="p">))</span>
<span class="n">dPml_xy</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">pml_tag</span><span class="p">)</span>
<span class="n">dPml_x</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">pml_tag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dPml_y</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">pml_tag</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s now define the relative permittivity <span class="math notranslate nohighlight">\(\varepsilon_m\)</span> of the gold
wire at <span class="math notranslate nohighlight">\(400nm\)</span> (data taken from <a class="reference external" href="https://doi.org/10.1103/PhysRevB.86.235147"><em>Olmon et al.
2012</em></a> , and for a quick
reference have a look at <a class="reference external" href="https://refractiveindex.info/?shelf=main&amp;amp;book=Au&amp;amp;page=Olmon-sc">refractiveindex.info</a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition of relative permittivity for Au @400nm</span>
<span class="n">eps_au</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0782</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">5.8089</span>
</pre></div>
</div>
<p>We can now define a space function for the permittivity <span class="math notranslate nohighlight">\(\varepsilon\)</span>
that takes the value <span class="math notranslate nohighlight">\(\varepsilon_m\)</span> for cells inside the wire, while
it takes the value of the background permittivity <span class="math notranslate nohighlight">\(\varepsilon_b\)</span> in
the background region:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">eps</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="n">au_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">au_tag</span><span class="p">)</span>
<span class="n">bkg_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">bkg_tag</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">au_cells</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">au_cells</span><span class="p">,</span> <span class="n">eps_au</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">bkg_cells</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">bkg_cells</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we need to define our weak form in DOLFINx. Let’s write the PML
weak form first. As a first step, we can define our new complex
coordinates as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># PML corners</span>
<span class="n">xy_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">(</span>
    <span class="p">(</span><span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">),</span> <span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">))</span>
<span class="p">)</span>

<span class="c1"># PML rectangles along x</span>
<span class="n">x_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># PML rectangles along y</span>
<span class="n">y_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pml_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">l_dom</span><span class="p">,</span> <span class="n">l_pml</span><span class="p">)))</span>
</pre></div>
</div>
<p>We can then express this coordinate systems as a material
transformation within the PML region. In other words, the PML region
can be interpreted as a material having, in general, anisotropic,
inhomogeneous and complex permittivity
<span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}_{pml}\)</span> and permeability
<span class="math notranslate nohighlight">\(\boldsymbol{\mu}_{pml}\)</span>. To do this, we need to calculate the
Jacobian of the coordinate transformation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{J}=\mathbf{A}^{-1}= \nabla\boldsymbol{x}^
\prime(\boldsymbol{x}) =
\left[\begin{array}{ccc}
\frac{\partial x^{\prime}}{\partial x} &amp;
\frac{\partial y^{\prime}}{\partial x} &amp;
\frac{\partial z^{\prime}}{\partial x} \\
\frac{\partial x^{\prime}}{\partial y} &amp;
\frac{\partial y^{\prime}}{\partial y} &amp;
\frac{\partial z^{\prime}}{\partial y} \\
\frac{\partial x^{\prime}}{\partial z} &amp;
\frac{\partial y^{\prime}}{\partial z} &amp;
\frac{\partial z^{\prime}}{\partial z}
\end{array}\right]=\left[\begin{array}{ccc}
\frac{\partial x^{\prime}}{\partial x} &amp; 0 &amp; 0 \\
0 &amp; \frac{\partial y^{\prime}}{\partial y} &amp; 0 \\
0 &amp; 0 &amp; \frac{\partial z^{\prime}}{\partial z}
\end{array}\right]=\left[\begin{array}{ccc}
J_{11} &amp; 0 &amp; 0 \\
0 &amp; J_{22} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]
\end{split}\]</div>
<p>Then, our <span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}_{pml}\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{\mu}_{pml}\)</span> can be calculated with the following formula,
from <a class="reference external" href="https://www.tandfonline.com/doi/abs/10.1080/09500349608232782">Ward &amp; Pendry, 1996</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
{\boldsymbol{\varepsilon}_{pml}} &amp;=
A^{-1} \mathbf{A} {\boldsymbol{\varepsilon}_b}\mathbf{A}^{T},\\
{\boldsymbol{\mu}_{pml}} &amp;=
A^{-1} \mathbf{A} {\boldsymbol{\mu}_b}\mathbf{A}^{T},
\end{align}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(A^{-1}=\operatorname{det}(\mathbf{J})\)</span>.</p>
<p>We use <code class="docutils literal notranslate"><span class="pre">ufl.grad</span></code> to calculate the Jacobian of our coordinate
transformation for the different PML regions, and then we can
implement this Jacobian for calculating
<span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}_{pml}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_{pml}\)</span>. The
here below function named <code class="docutils literal notranslate"><span class="pre">create_eps_mu()</span></code> serves this purpose:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>

<span class="k">def</span><span class="w"> </span><span class="nf">create_eps_mu</span><span class="p">(</span>
    <span class="n">pml</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">tensors</span><span class="o">.</span><span class="n">ListTensor</span><span class="p">,</span>
    <span class="n">eps_bkg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">tensors</span><span class="o">.</span><span class="n">ListTensor</span><span class="p">],</span>
    <span class="n">mu_bkg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">tensors</span><span class="o">.</span><span class="n">ListTensor</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">tensors</span><span class="o">.</span><span class="n">ComponentTensor</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">tensors</span><span class="o">.</span><span class="n">ComponentTensor</span><span class="p">]:</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">pml</span><span class="p">)</span>

    <span class="c1"># Transform the 2x2 Jacobian into a 3x3 matrix.</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(((</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">eps_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">eps_bkg</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">mu_pml</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">mu_bkg</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps_pml</span><span class="p">,</span> <span class="n">mu_pml</span>


<span class="n">eps_x</span><span class="p">,</span> <span class="n">mu_x</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">x_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">eps_y</span><span class="p">,</span> <span class="n">mu_y</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">y_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">eps_xy</span><span class="p">,</span> <span class="n">mu_xy</span> <span class="o">=</span> <span class="n">create_eps_mu</span><span class="p">(</span><span class="n">xy_pml</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The final weak form in the PML region is:</p>
<div class="math notranslate nohighlight">
\[
\int_{\Omega_{pml}}\left[\boldsymbol{\mu}^{-1}_{pml} \nabla \times
\mathbf{E} \right]\cdot \nabla \times \bar{\mathbf{v}}-k_{0}^{2}
\left[\boldsymbol{\varepsilon}_{pml} \mathbf{E} \right]\cdot
\bar{\mathbf{v}}~ d x=0,
\]</div>
<p>while in the rest of the domain is:</p>
<div class="math notranslate nohighlight">
\[
\int_{\Omega_m\cup\Omega_b}-(\nabla \times \mathbf{E}_s)
\cdot (\nabla \times \bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2}
\mathbf{E}_s \cdot \bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}
-\varepsilon_b\right)\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x.
= 0.
\]</div>
<p>Let’s solve this equation in DOLFINx:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition of the weak form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span>
    <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Es</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">eps_bkg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Eb</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_x</span>
    <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_y</span>
    <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mu_xy</span><span class="p">)</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dPml_xy</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">eps_x</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_x</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">eps_y</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_y</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">eps_xy</span> <span class="o">*</span> <span class="n">Es_3d</span><span class="p">,</span> <span class="n">v_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">dPml_xy</span>
<span class="p">)</span>

<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># For factorisation prefer MUMPS, then superlu_dist, then default</span>
<span class="n">sys</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Sys</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
<span class="n">use_superlu</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">IntType</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">hasExternalPackage</span><span class="p">(</span><span class="s2">&quot;mumps&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_superlu</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
    <span class="n">mat_factor_backend</span> <span class="o">=</span> <span class="s2">&quot;mumps&quot;</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">hasExternalPackage</span><span class="p">(</span><span class="s2">&quot;superlu_dist&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="n">mat_factor_backend</span> <span class="o">=</span> <span class="s2">&quot;superlu_dist&quot;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This demo requires a parallel LU solver.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat_factor_backend</span> <span class="o">=</span> <span class="s2">&quot;petsc&quot;</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">L</span><span class="p">,</span>
    <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">petsc_options_prefix</span><span class="o">=</span><span class="s2">&quot;demo_pml_&quot;</span><span class="p">,</span>
    <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pc_factor_mat_solver_type&quot;</span><span class="p">:</span> <span class="n">mat_factor_backend</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">)</span>
<span class="n">Esh</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">convergence_reason</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Esh</span><span class="p">,</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">convergence_reason</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Let’s now save the solution in a <code class="docutils literal notranslate"><span class="pre">bp</span></code>-file. In order to do so, we need
to interpolate our solution discretized with Nedelec elements into a
compatible discontinuous Lagrange space.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gdim</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">dim</span>
<span class="n">V_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="p">(</span><span class="n">gdim</span><span class="p">,)))</span>
<span class="n">Esh_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
<span class="n">Esh_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Esh</span><span class="p">)</span>

<span class="k">with</span> <span class="n">VTXWriter</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="s2">&quot;Esh.bp&quot;</span><span class="p">,</span> <span class="n">Esh_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">vtx</span><span class="p">:</span>
    <span class="n">vtx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information about saving and visualizing vector fields
discretized with Nedelec elements, check <a class="reference external" href="https://docs.fenicsproject.org/dolfinx/main/python/demos/demo_interpolation-io.html">this</a>
DOLFINx demo.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
    <span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
    <span class="n">V_grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span><span class="p">)</span>
    <span class="n">Esh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">Esh_values</span><span class="p">[:,</span> <span class="p">:</span><span class="n">tdim</span><span class="p">]</span> <span class="o">=</span> <span class="n">Esh_dg</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tdim</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="n">V_grid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Esh_values</span>

    <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">&quot;magnitude&quot;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">V_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">link_views</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;Esh.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">])</span>
</pre></div>
</div>
<p>Next we can calculate the total electric field
<span class="math notranslate nohighlight">\(\mathbf{E}=\mathbf{E}_s+\mathbf{E}_b\)</span> and save it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">E</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Eb</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">Esh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span>

<span class="n">E_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
<span class="n">E_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

<span class="k">with</span> <span class="n">VTXWriter</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="s2">&quot;E.bp&quot;</span><span class="p">,</span> <span class="n">E_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">vtx</span><span class="p">:</span>
    <span class="n">vtx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="post-processing">
<h2>Post-processing<a class="headerlink" href="#post-processing" title="Link to this heading"></a></h2>
<p>To validate the formulation we calculate the absorption, scattering
and extinction efficiencies, which are quantities that define how much
light is absorbed and scattered by the wire. First of all, we
calculate the analytical efficiencies with the
<code class="docutils literal notranslate"><span class="pre">calculate_analytical_efficiencies</span></code> function defined in a separate
file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">q_abs_analyt</span><span class="p">,</span> <span class="n">q_sca_analyt</span><span class="p">,</span> <span class="n">q_ext_analyt</span> <span class="o">=</span> <span class="n">calculate_analytical_efficiencies</span><span class="p">(</span>
    <span class="n">eps_au</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">wl0</span><span class="p">,</span> <span class="n">radius_wire</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We calculate the numerical efficiencies in the same way as done in
<code class="docutils literal notranslate"><span class="pre">demo_scattering_boundary_conditions.py</span></code>, with the only difference
that now the scattering efficiency needs to be calculated over an
inner facet, and therefore it requires a slightly different approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Vacuum impedance</span>
<span class="n">Z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu_0</span> <span class="o">/</span> <span class="n">epsilon_0</span><span class="p">)</span>

<span class="c1"># Magnetic field H</span>
<span class="n">Hsh_3d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Esh</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span><span class="p">)</span>

<span class="n">Esh_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">Esh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Esh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">E_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Intensity of the electromagnetic fields I0 = 0.5*E0**2/Z0</span>
<span class="c1"># E0 = np.sqrt(ax**2 + ay**2) = 1, see background_electric_field</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">Z0</span>

<span class="c1"># Geometrical cross section of the wire</span>
<span class="n">gcs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_wire</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">n_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Create a marker for the integration boundary for the scattering</span>
<span class="c1"># efficiency</span>
<span class="n">marker</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="n">scatt_facets</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">facet_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">scatt_tag</span><span class="p">)</span>
<span class="n">incident_cells</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_incident_entities</span><span class="p">(</span>
    <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">scatt_facets</span><span class="p">,</span> <span class="n">tdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tdim</span>
<span class="p">)</span>

<span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">create_connectivity</span><span class="p">(</span><span class="n">tdim</span><span class="p">,</span> <span class="n">tdim</span><span class="p">)</span>
<span class="n">midpoints</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_midpoints</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">tdim</span><span class="p">,</span> <span class="n">incident_cells</span><span class="p">)</span>
<span class="n">inner_cells</span> <span class="o">=</span> <span class="n">incident_cells</span><span class="p">[(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">radius_scatt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">marker</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">inner_cells</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Quantities for the calculation of efficiencies</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Esh_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Hsh_3d</span><span class="p">)),</span> <span class="n">n_3d</span><span class="p">)</span> <span class="o">*</span> <span class="n">marker</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">eps_au</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">E_3d</span><span class="p">,</span> <span class="n">E_3d</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">*</span> <span class="n">n_bkg</span><span class="p">)</span>

<span class="c1"># Define integration domain for the wire</span>
<span class="n">dAu</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">au_tag</span><span class="p">)</span>

<span class="c1"># Define integration facet for the scattering efficiency</span>
<span class="n">dS</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;dS&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">facet_tags</span><span class="p">)</span>

<span class="c1"># Normalized absorption efficiency</span>
<span class="n">q_abs_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">Q</span> <span class="o">*</span> <span class="n">dAu</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">gcs</span> <span class="o">*</span> <span class="n">I0</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
<span class="c1"># Sum results from all MPI processes</span>
<span class="n">q_abs_fenics</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_abs_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

<span class="c1"># Normalized scattering efficiency</span>
<span class="n">q_sca_fenics_proc</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">((</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">scatt_tag</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">gcs</span> <span class="o">*</span> <span class="n">I0</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">real</span>

<span class="c1"># Sum results from all MPI processes</span>
<span class="n">q_sca_fenics</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_sca_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

<span class="c1"># Extinction efficiency</span>
<span class="n">q_ext_fenics</span> <span class="o">=</span> <span class="n">q_abs_fenics</span> <span class="o">+</span> <span class="n">q_sca_fenics</span>

<span class="c1"># Error calculation</span>
<span class="n">err_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_abs_analyt</span> <span class="o">-</span> <span class="n">q_abs_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_abs_analyt</span>
<span class="n">err_sca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_sca_analyt</span> <span class="o">-</span> <span class="n">q_sca_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_sca_analyt</span>
<span class="n">err_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_ext_analyt</span> <span class="o">-</span> <span class="n">q_ext_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_ext_analyt</span>

<span class="k">if</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical absorption efficiency is </span><span class="si">{</span><span class="n">q_abs_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical absorption efficiency is </span><span class="si">{</span><span class="n">q_abs_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_abs</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical scattering efficiency is </span><span class="si">{</span><span class="n">q_sca_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical scattering efficiency is </span><span class="si">{</span><span class="n">q_sca_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_sca</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical extinction efficiency is </span><span class="si">{</span><span class="n">q_ext_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical extinction efficiency is </span><span class="si">{</span><span class="n">q_ext_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_ext</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check if errors are smaller than 1%</span>
<span class="k">assert</span> <span class="n">err_abs</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
<span class="c1"># assert err_sca &lt; 0.01</span>
<span class="k">assert</span> <span class="n">err_ext</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="demo_scattering_boundary_conditions.html" class="btn btn-neutral float-left" title="Electromagnetic scattering from a wire with scattering boundary conditions # noqa" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demo_half_loaded_waveguide.html" class="btn btn-neutral float-right" title="Electromagnetic modal analysis for a waveguide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, FEniCS Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
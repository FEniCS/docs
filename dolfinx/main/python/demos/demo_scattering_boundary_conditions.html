

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electromagnetic scattering from a wire with scattering boundary conditions &mdash; DOLFINx 0.10.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=15ca63c5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electromagnetic scattering from a wire with perfectly matched layer condition" href="demo_pml.html" />
    <link rel="prev" title="Helmholtz equation" href="demo_helmholtz.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DOLFINx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../demos.html">Demos</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#pdes-introductory">PDEs (introductory)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic scattering from a wire with scattering boundary conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-problem-definition-and-implementation">Equations, problem definition and implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_pml.html">Electromagnetic scattering from a wire with perfectly matched layer condition</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_half_loaded_waveguide.html">Electromagnetic modal analysis for a waveguide</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#pdes-advanced">PDEs (advanced)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#nonlinear-problems">Nonlinear problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#mesh-generation">Mesh generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#interpolation-io-and-visualisation">Interpolation, IO and visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#advanced-iterative-solvers">Advanced iterative solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#user-defined-and-advanced-finite-elements">User-defined and advanced finite elements</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#list-of-all-demos">List of all demos</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_biharmonic.html">Biharmonic equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_cahn-hilliard.html">Cahn-Hilliard equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_stokes.html">Stokes equations using Taylor-Hood elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_elasticity.html">Elasticity using algebraic multigrid</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_gmsh.html">Mesh generation with Gmsh</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_static-condensation.html">Static condensation of linear elasticity</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyvista.html">Visualization with PyVista</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_interpolation-io.html">Interpolation and IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_types.html">Solving PDEs with different scalar (float) types</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_lagrange_variants.html">Variants of Lagrange elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_tnt-elements.html">Creating TNT elements using Basix’s custom element interface</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic scattering from a wire with scattering boundary conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-problem-definition-and-implementation">Equations, problem definition and implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_pml.html">Electromagnetic scattering from a wire with perfectly matched layer condition</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_half_loaded_waveguide.html">Electromagnetic modal analysis for a waveguide</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_navier-stokes.html">Divergence conforming discontinuous Galerkin method for the Navier–Stokes equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-poisson.html">Mixed formulation of the Poisson equation with a block-preconditioner/solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyamg.html">Solve the Poisson and linearised elasticity equations using pyamg</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_hdg.html">HDG scheme for the Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-topology.html">Poisson equation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DOLFINx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../demos.html">Demos</a></li>
      <li class="breadcrumb-item active">Electromagnetic scattering from a wire with scattering boundary conditions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demos/demo_scattering_boundary_conditions.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="electromagnetic-scattering-from-a-wire-with-scattering-boundary-conditions">
<h1>Electromagnetic scattering from a wire with scattering boundary conditions<a class="headerlink" href="#electromagnetic-scattering-from-a-wire-with-scattering-boundary-conditions" title="Link to this heading"></a></h1>
<p>Copyright (C) 2022 Michele Castriotta, Igor Baratta, Jørgen S. Dokken</p>
<p>This demo is implemented in two files: one for the mesh generation
with gmsh, and one for the variational forms and the solver. It
illustrates how to:</p>
<ul class="simple">
<li><p>Use complex quantities in FEniCSx</p></li>
<li><p>Setup and solve Maxwell’s equations</p></li>
<li><p>Implement Scattering Boundary Conditions</p></li>
</ul>
<section id="equations-problem-definition-and-implementation">
<h2>Equations, problem definition and implementation<a class="headerlink" href="#equations-problem-definition-and-implementation" title="Link to this heading"></a></h2>
<p>First of all, let’s import the modules that will be used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">if</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s2">&quot;petsc4py&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">has_petsc</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires DOLFINx to be compiled with PETSc enabled.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span>

    <span class="k">if</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">IntType</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="ow">and</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This solver fails with PETSc and 64-bit integers becaude of memory errors in MUMPS.&quot;</span><span class="p">)</span>
        <span class="c1"># Note: when PETSc.IntType == np.int32, superlu_dist is used rather</span>
        <span class="c1"># than MUMPS and does not trigger memory failures.</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires petsc4py.&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">h2vp</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="n">jvp</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">basix.ufl</span><span class="w"> </span><span class="kn">import</span> <span class="n">element</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_real_type</span><span class="p">,</span> <span class="n">default_scalar_type</span><span class="p">,</span> <span class="n">fem</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearProblem</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">gmsh</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This demo requires gmsh to be installed&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pyvista</span>

    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pyvista and pyvistaqt are required to visualise the solution&quot;</span><span class="p">)</span>
    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>This file defines the <code class="docutils literal notranslate"><span class="pre">generate_mesh_wire</span></code> function, which is used to
generate the mesh used for scattering boundary conditions demo. The
mesh is made up by a central circle representing the wire, and an
external circle, which represents the external boundary of our domain,
where scattering boundary conditions are applied. The
<code class="docutils literal notranslate"><span class="pre">generate_mesh_wire</span></code> function takes as input:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">radius_wire</span></code>: the radius of the wire</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radius_dom</span></code>: the radius of the external boundary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">in_wire_size</span></code>: the mesh size at a distance <code class="docutils literal notranslate"><span class="pre">0.8</span> <span class="pre">*</span> <span class="pre">radius_wire</span></code> from
the origin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_wire_size</span></code>: the mesh size on the wire boundary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bkg_size</span></code>: the mesh size at a distance <code class="docutils literal notranslate"><span class="pre">0.9</span> <span class="pre">*</span> <span class="pre">radius_dom</span></code> from the
origin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boundary_size</span></code>: the mesh size on the external boundary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">au_tag</span></code>: the tag of the physical group representing the wire</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bkg_tag</span></code>: the tag of the physical group representing the background</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boundary_tag</span></code>: the tag of the physical group representing the
boundary</p></li>
</ul>
<p>In particular, <code class="docutils literal notranslate"><span class="pre">bkg_size</span></code> and <code class="docutils literal notranslate"><span class="pre">boundary_size</span></code> are necessary to set a
finer mesh on the external boundary (to improve the accuracy of the
scattering efficiency calculation) while keenp.ping a coarser size over
the rest of the domain.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_mesh_wire</span><span class="p">(</span>
    <span class="n">radius_wire</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">radius_dom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">in_wire_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">on_wire_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">bkg_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">boundary_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">au_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bkg_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">boundary_tag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;wire&quot;</span><span class="p">)</span>

    <span class="c1"># A dummy boundary is added for setting a finer mesh</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_wire</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_wire</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># A dummy boundary is added for setting a finer mesh</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_dom</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCircle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radius_dom</span><span class="p">,</span> <span class="n">angle1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addCurveLoop</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">addPlaneSurface</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">au_tag</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">bkg_tag</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">addPhysicalGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">boundary_tag</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">in_wire_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">on_wire_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">bkg_size</span><span class="p">)</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">setSize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">size</span><span class="o">=</span><span class="n">boundary_size</span><span class="p">)</span>

    <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span>
</pre></div>
</div>
<p>This file contains a function for the calculation of the
absorption, scattering and extinction efficiencies of a wire
being hit normally by a TM-polarized electromagnetic wave.</p>
<p>The formula are taken from:
Milton Kerker, “The Scattering of Light and Other Electromagnetic Radiation”,
Chapter 6, Elsevier, 1969.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h2>
<p>First of all, let’s define the parameters of the problem:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n = \sqrt{\varepsilon}\)</span>: refractive index of the wire,</p></li>
<li><p><span class="math notranslate nohighlight">\(n_b\)</span>: refractive index of the background medium,</p></li>
<li><p><span class="math notranslate nohighlight">\(m = n/n_b\)</span>: relative refractive index of the wire,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda_0\)</span>: wavelength of the electromagnetic wave,</p></li>
<li><p><span class="math notranslate nohighlight">\(r_w\)</span>: radius of the cross-section of the wire,</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha = 2\pi r_w n_b/\lambda_0\)</span>.</p></li>
</ul>
<p>Now, let’s define the <span class="math notranslate nohighlight">\(a_\nu\)</span> coefficients as:</p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
a_\nu=\frac{J_\nu(\alpha) J_\nu^{\prime}(m \alpha)-m J_\nu(m \alpha)
J_\nu^{\prime}(\alpha)}{H_\nu^{(2)}(\alpha) J_\nu^{\prime}(m \alpha)
-m J_\nu(m \alpha) H_\nu^{(2){\prime}}(\alpha)}
\end{equation}
\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(J_\nu(x)\)</span>: <span class="math notranslate nohighlight">\(\nu\)</span>-th order Bessel function of the first kind,</p></li>
<li><p><span class="math notranslate nohighlight">\(J_\nu^{\prime}(x)\)</span>: first derivative with respect to <span class="math notranslate nohighlight">\(x\)</span> of
the <span class="math notranslate nohighlight">\(\nu\)</span>-th order Bessel function of the first kind,</p></li>
<li><p><span class="math notranslate nohighlight">\(H_\nu^{(2)}(x)\)</span>: <span class="math notranslate nohighlight">\(\nu\)</span>-th order Hankel function of the second kind,</p></li>
<li><p><span class="math notranslate nohighlight">\(H_\nu^{(2){\prime}}(x)\)</span>: first derivative with respect to <span class="math notranslate nohighlight">\(x\)</span> of
the <span class="math notranslate nohighlight">\(\nu\)</span>-th order Hankel function of the second kind.</p></li>
</ul>
<p>We can now calculate the scattering, extinction and absorption
efficiencies as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
&amp; q_{\mathrm{sca}}=(2 / \alpha)\left[\left|a_0\right|^{2}
+2 \sum_{\nu=1}^{\infty}\left|a_\nu\right|^{2}\right] \\
&amp; q_{\mathrm{ext}}=(2 / \alpha) \operatorname{Re}\left[ a_0
+2 \sum_{\nu=1}^{\infty} a_\nu\right] \\
&amp; q_{\mathrm{abs}} = q_{\mathrm{ext}} - q_{\mathrm{sca}}
\end{split}\]</div>
<p>The functions that we import from <code class="docutils literal notranslate"><span class="pre">scipy.special</span></code> correspond to:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jv(nu,</span> <span class="pre">x)</span></code> ⟷ <span class="math notranslate nohighlight">\(J_\nu(x)\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvp(nu,</span> <span class="pre">x,</span> <span class="pre">1)</span></code> ⟷ <span class="math notranslate nohighlight">\(J_\nu^{\prime}(x)\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hankel2(nu,</span> <span class="pre">x)</span></code> ⟷ <span class="math notranslate nohighlight">\(H_\nu^{(2)}(x)\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h2vp(nu,</span> <span class="pre">x,</span> <span class="pre">1)</span></code> ⟷ <span class="math notranslate nohighlight">\(H_\nu^{(2){\prime}}(x)\)</span>.</p></li>
</ul>
<p>Next, we define a function for calculating the analytical efficiencies
in Python. The inputs of the function are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eps</span></code> ⟷ <span class="math notranslate nohighlight">\(\varepsilon\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_bkg</span></code> ⟷ <span class="math notranslate nohighlight">\(n_b\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wl0</span></code> ⟷ <span class="math notranslate nohighlight">\(\lambda_0\)</span>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radius_wire</span></code> ⟷ <span class="math notranslate nohighlight">\(r_w\)</span>.</p></li>
</ul>
<p>We also define a nested function for the calculation of <span class="math notranslate nohighlight">\(a_l\)</span>. For the
final calculation of the efficiencies, the summation over the different
orders of the Bessel functions is truncated at <span class="math notranslate nohighlight">\(\nu=50\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">J_nu_alpha</span> <span class="o">=</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">J_nu_malpha</span> <span class="o">=</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">J_nu_alpha_p</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">J_nu_malpha_p</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">H_nu_alpha</span> <span class="o">=</span> <span class="n">hankel2</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">H_nu_alpha_p</span> <span class="o">=</span> <span class="n">h2vp</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">a_nu_num</span> <span class="o">=</span> <span class="n">J_nu_alpha</span> <span class="o">*</span> <span class="n">J_nu_malpha_p</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">J_nu_malpha</span> <span class="o">*</span> <span class="n">J_nu_alpha_p</span>
    <span class="n">a_nu_den</span> <span class="o">=</span> <span class="n">H_nu_alpha</span> <span class="o">*</span> <span class="n">J_nu_malpha_p</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">J_nu_malpha</span> <span class="o">*</span> <span class="n">H_nu_alpha_p</span>
    <span class="k">return</span> <span class="n">a_nu_num</span> <span class="o">/</span> <span class="n">a_nu_den</span>


<span class="k">def</span><span class="w"> </span><span class="nf">calculate_analytical_efficiencies</span><span class="p">(</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">wl0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius_wire</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">num_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_bkg</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_wire</span> <span class="o">/</span> <span class="n">wl0</span> <span class="o">*</span> <span class="n">n_bkg</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">alpha</span>
    <span class="n">q_ext</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="n">q_sca</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">q_ext</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
        <span class="n">q_sca</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">compute_a</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">q_ext</span> <span class="o">-</span> <span class="n">q_sca</span><span class="p">,</span> <span class="n">q_sca</span><span class="p">,</span> <span class="n">q_ext</span>


<span class="c1"># Since we want to solve time-harmonic Maxwell&#39;s equation, we need to</span>
<span class="c1"># solve a complex-valued PDE, and therefore need to use PETSc compiled</span>
<span class="c1"># with complex numbers.</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">default_scalar_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Demo should only be executed with DOLFINx complex mode&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># Now, let&#39;s consider an infinite metallic wire immersed in a background</span>
<span class="c1"># medium (e.g. vacuum or water). Let&#39;s now consider the plane cutting</span>
<span class="c1"># the wire perpendicularly to its axis at a generic point. Such plane</span>
<span class="c1"># $\Omega=\Omega_{m} \cup\Omega_{b}$ is formed by the cross-section of</span>
<span class="c1"># the wire $\Omega_m$ and the background medium $\Omega_{b}$ surrounding</span>
<span class="c1"># the wire. Let&#39;s consider just the portion of this plane delimited by</span>
<span class="c1"># an external circular boundary $\partial \Omega$. We want to calculate</span>
<span class="c1"># the electric field $\mathbf{E}_s$ scattered by the wire when a</span>
<span class="c1"># background wave $\mathbf{E}_b$ impinges on it. We will consider a</span>
<span class="c1"># background plane wave at $\lambda_0$ wavelength, that can be written</span>
<span class="c1"># analytically as:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># \mathbf{E}_b = \exp(\mathbf{k}\cdot\mathbf{r})\hat{\mathbf{u}}_p</span>
<span class="c1"># $$</span>
<span class="c1">#</span>
<span class="c1"># with $\mathbf{k} = \frac{2\pi}{\lambda_0}n_b\hat{\mathbf{u}}_k$ being</span>
<span class="c1"># the wavevector of the plane wave, pointing along the propagation</span>
<span class="c1"># direction, with $\hat{\mathbf{u}}_p$ being the polarization direction,</span>
<span class="c1"># and with $\mathbf{r}$ being a point in $\Omega$. We will only consider</span>
<span class="c1"># $\hat{\mathbf{u}}_k$ and $\hat{\mathbf{u}}_p$ with components</span>
<span class="c1"># belonging to the $\Omega$ domain and perpendicular to each other, i.e.</span>
<span class="c1"># $\hat{\mathbf{u}}_k \perp \hat{\mathbf{u}}_p$ (transversality</span>
<span class="c1"># condition of plane waves). Using a Cartesian coordinate system for</span>
<span class="c1"># $\Omega$, and by defining $k_x = n_bk_0\cos\theta$ and $k_y =</span>
<span class="c1"># n_bk_0\sin\theta$, with $\theta$ being the angle defined by the</span>
<span class="c1"># propagation direction $\hat{\mathbf{u}}_k$ and the horizontal axis</span>
<span class="c1"># $\hat{\mathbf{u}}_x$, we have:</span>
<span class="c1">#</span>
<span class="c1"># $$</span>
<span class="c1"># \mathbf{E}_b = -\sin\theta e^{j (k_xx+k_yy)}\hat{\mathbf{u}}_x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">incorrectly_encoded_metadata</span><span class="p">:</span> <span class="s1">&#39;{j (k_xx+k_yy)}\hat{\mathbf</span><span class="si">{u}</span><span class="s1">}_y&#39;</span>
<span class="p">:</span><span class="n">title</span><span class="p">:</span> \<span class="n">cos</span>\<span class="n">theta</span> <span class="n">e</span><span class="o">^</span>

<span class="c1"># $$</span>
<span class="c1">#</span>
<span class="c1"># The following class implements this functions. The inputs to the</span>
<span class="c1"># function are the angle $\theta$, the background refractive index $n_b$</span>
<span class="c1"># and the vacuum wavevector $k_0$.</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>

<span class="k">class</span><span class="w"> </span><span class="nc">BackgroundElectricField</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k0</span><span class="p">:</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>  <span class="c1"># incident angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span>  <span class="c1"># vacuum wavevector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bkg</span> <span class="o">=</span> <span class="n">n_bkg</span>  <span class="c1"># background refractive index</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]]:</span>
        <span class="n">kx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bkg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">ky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bkg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">kx</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ky</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ax</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">ay</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>
</pre></div>
</div>
<p>The Maxwell’s equation for scattering problems takes the following
form:</p>
<div class="math notranslate nohighlight">
\[
-\nabla \times \nabla \times \mathbf{E}_s+\varepsilon_{r} k_{0}^{2}
\mathbf{E}_s
+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_{b}\right)
\mathbf{E}_{\mathrm{b}}=0 \textrm{ in } \Omega,
\]</div>
<p>where <span class="math notranslate nohighlight">\(k_0 = 2\pi/\lambda_0\)</span> is the vacuum wavevector of the
background field, <span class="math notranslate nohighlight">\(\varepsilon_b\)</span> is the background relative
permittivity and <span class="math notranslate nohighlight">\(\varepsilon_r\)</span> is the relative permittivity as a
function of space, i.e.:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\varepsilon_r = \begin{cases}
\varepsilon_m &amp; \textrm{on }\Omega_m \\
\varepsilon_b &amp; \textrm{on }\Omega_b
\end{cases}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\varepsilon_m\)</span> being the relative permittivity of the metallic
wire. As reference values, we will consider <span class="math notranslate nohighlight">\(\lambda_0 =
400\textrm{nm}\)</span> (violet light), <span class="math notranslate nohighlight">\(\varepsilon_b = 1.33^2\)</span> (relative
permittivity of water), and <span class="math notranslate nohighlight">\(\varepsilon_m = -1.0782 +
5.8089\textrm{j}\)</span> (relative permittivity of gold at <span class="math notranslate nohighlight">\(400\textrm{nm}\)</span>).</p>
<p>To form a well-determined system, we add boundary conditions on
<span class="math notranslate nohighlight">\(\partial \Omega\)</span>. It is common to use scattering boundary conditions
(ref), which make the boundary transparent for <span class="math notranslate nohighlight">\(\mathbf{E}_s\)</span>,
allowing us to restrict the computational boundary to a finite
<span class="math notranslate nohighlight">\(\Omega\)</span> domain. The first-order boundary conditions in the 2D case
take the following form:</p>
<div class="math notranslate nohighlight">
\[\mathbf{n} \times
\nabla \times \mathbf{E}_s+\left(j k_{0}n_b + \frac{1}{2r}
\right) \mathbf{n} \times \mathbf{E}_s
\times \mathbf{n}=0\quad \textrm{ on } \partial \Omega,
\]</div>
<p>with <span class="math notranslate nohighlight">\(n_b = \sqrt{\varepsilon_b}\)</span> being the background refractive
index, <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> being the normal vector to <span class="math notranslate nohighlight">\(\partial \Omega\)</span>, and
<span class="math notranslate nohighlight">\(r = \sqrt{(x-x_s)^2 + (y-y_s)^2}\)</span> being the distance of the <span class="math notranslate nohighlight">\((x, y)\)</span>
point on <span class="math notranslate nohighlight">\(\partial\Omega\)</span> from the wire centered in <span class="math notranslate nohighlight">\((x_s, y_s)\)</span>. We
consider a wired centered at the origin, i.e. <span class="math notranslate nohighlight">\(r =\sqrt{x^2 + y^2}\)</span>.</p>
<p>The radial distance function <span class="math notranslate nohighlight">\(r(x)\)</span> and <span class="math notranslate nohighlight">\(\nabla \times\)</span> operator for a
2D vector (in UFL syntax) is defined below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">radial_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the radial distance from the origin&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ufl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">curl_2d</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the curl of two 2D vectors as a 3D vector&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p>Next we define some mesh specific parameters. Please notice that the
length units are normalized with respect to <span class="math notranslate nohighlight">\(1\mu m\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">epsilon_0</span> <span class="o">=</span> <span class="mf">8.8541878128</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">12</span>
<span class="n">mu_0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">7</span>

<span class="c1"># Radius of the wire and of the boundary of the domain</span>
<span class="n">radius_wire</span> <span class="o">=</span> <span class="mf">0.050</span>
<span class="n">radius_dom</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># The smaller the mesh_factor, the finer is the mesh</span>
<span class="n">mesh_factor</span> <span class="o">=</span> <span class="mf">1.2</span>

<span class="c1"># Mesh size inside the wire</span>
<span class="n">in_wire_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">7.0e-3</span>

<span class="c1"># Mesh size at the boundary of the wire</span>
<span class="n">on_wire_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">3.0e-3</span>

<span class="c1"># Mesh size in the background</span>
<span class="n">bkg_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">60.0e-3</span>

<span class="c1"># Mesh size at the boundary</span>
<span class="n">boundary_size</span> <span class="o">=</span> <span class="n">mesh_factor</span> <span class="o">*</span> <span class="mf">30.0e-3</span>

<span class="c1"># Tags for the subdomains</span>
<span class="n">au_tag</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># gold wire</span>
<span class="n">bkg_tag</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># background</span>
<span class="n">boundary_tag</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># boundary</span>
</pre></div>
</div>
<p>We generate the mesh using GMSH and convert it to a
<code class="docutils literal notranslate"><span class="pre">dolfinx.mesh.Mesh</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="k">if</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">generate_mesh_wire</span><span class="p">(</span>
        <span class="n">radius_wire</span><span class="p">,</span>
        <span class="n">radius_dom</span><span class="p">,</span>
        <span class="n">in_wire_size</span><span class="p">,</span>
        <span class="n">on_wire_size</span><span class="p">,</span>
        <span class="n">bkg_size</span><span class="p">,</span>
        <span class="n">boundary_size</span><span class="p">,</span>
        <span class="n">au_tag</span><span class="p">,</span>
        <span class="n">bkg_tag</span><span class="p">,</span>
        <span class="n">boundary_tag</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mesh_data</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">gmshio</span><span class="o">.</span><span class="n">model_to_mesh</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gdim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Cell tags are missing&quot;</span>
<span class="k">assert</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">facet_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Facet tags are missing&quot;</span>

<span class="n">gmsh</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
<span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
</pre></div>
</div>
<p>The mesh is visualized with <a class="reference external" href="https://docs.pyvista.org/">PyVista</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
    <span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">geometry</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
    <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
    <span class="n">num_local_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">index_map</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">size_local</span>
    <span class="n">grid</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s2">&quot;Marker&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">values</span><span class="p">[</span>
        <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="n">num_local_cells</span>
    <span class="p">]</span>
    <span class="n">grid</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Marker&quot;</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
        <span class="n">figure</span> <span class="o">=</span> <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;wire_mesh.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">8000</span><span class="p">,</span> <span class="mi">8000</span><span class="p">])</span>
</pre></div>
</div>
<p>Now we define some other problem specific parameters:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wl0</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># Wavelength of the background field</span>
<span class="n">n_bkg</span> <span class="o">=</span> <span class="mf">1.33</span>  <span class="c1"># Background refractive index</span>
<span class="n">eps_bkg</span> <span class="o">=</span> <span class="n">n_bkg</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Background relative permittivity</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wl0</span>  <span class="c1"># Wavevector of the background field</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># Angle of incidence of the background field</span>
</pre></div>
</div>
<p>We use a function space consisting of degree 3 <a class="reference external" href="https://defelement.org/elements/nedelec1.html">Nedelec (first
kind)</a> elements to
represent the electric field</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">degree</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">curl_el</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;N1curl&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">basix_cell</span><span class="p">(),</span> <span class="n">degree</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">default_real_type</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">curl_el</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we can interpolate <span class="math notranslate nohighlight">\(\mathbf{E}_b\)</span> into the function space <span class="math notranslate nohighlight">\(V\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">BackgroundElectricField</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">k0</span><span class="p">)</span>
<span class="n">Eb</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">Eb</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">radial_distance</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Create test and trial functions</span>
<span class="n">Es</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Definition of 3d fields for cross and curl operations</span>
<span class="n">Es_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">Es</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Es</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">v_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Measures for subdomains</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;dx&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;ds&quot;</span><span class="p">,</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">facet_tags</span><span class="p">)</span>
<span class="n">dDom</span> <span class="o">=</span> <span class="n">dx</span><span class="p">((</span><span class="n">au_tag</span><span class="p">,</span> <span class="n">bkg_tag</span><span class="p">))</span>
<span class="n">dsbc</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="n">boundary_tag</span><span class="p">)</span>

<span class="c1"># Normal to the boundary</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">n_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>We turn our focus to the permittivity <span class="math notranslate nohighlight">\(\varepsilon\)</span>. First, we define
the relative permittivity <span class="math notranslate nohighlight">\(\varepsilon_m\)</span> of the gold wire at <span class="math notranslate nohighlight">\(400nm\)</span>.
This data can be found in <a class="reference external" href="https://doi.org/10.1103/PhysRevB.86.235147"><em>Olmon et al.
2012</em></a> or at
<a class="reference external" href="https://refractiveindex.info/?shelf=main&amp;amp;book=Au&amp;amp;page=Olmon-sc">refractiveindex.info</a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps_au</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0782</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">5.8089</span>
</pre></div>
</div>
<p>We define a permittivity function <span class="math notranslate nohighlight">\(\varepsilon\)</span> that takes the value
of the gold permittivity <span class="math notranslate nohighlight">\(\varepsilon_m\)</span> for cells inside the wire,
while it takes the value of the background permittivity otherwise:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">eps</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="n">au_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">au_tag</span><span class="p">)</span>
<span class="n">bkg_cells</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">cell_tags</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">bkg_tag</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">au_cells</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">au_cells</span><span class="p">,</span> <span class="n">eps_au</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">bkg_cells</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">bkg_cells</span><span class="p">,</span> <span class="n">eps_bkg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>
</pre></div>
</div>
<p>Next we derive the weak formulation of the Maxwell’s equation plus
with scattering boundary conditions. First, we take the inner products
of the equations with a complex test function <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, and
integrate the terms over the corresponding domains:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \int_{\Omega}-\nabla \times( \nabla \times \mathbf{E}_s) \cdot
\bar{\mathbf{v}}+\varepsilon_{r} k_{0}^{2} \mathbf{E}_s \cdot
\bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_b\right)
\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x \\
+&amp; \int_{\partial \Omega}
(\mathbf{n} \times \nabla \times \mathbf{E}_s) \cdot \bar{\mathbf{v}}
+\left(j n_bk_{0}+\frac{1}{2r}\right) (\mathbf{n} \times \mathbf{E}_s
\times \mathbf{n}) \cdot \bar{\mathbf{v}}~\mathrm{d}s=0
\end{align}
\end{split}\]</div>
<p>By using <span class="math notranslate nohighlight">\((\nabla \times \mathbf{A}) \cdot \mathbf{B}=\mathbf{A}
\cdot(\nabla \times \mathbf{B})+\nabla \cdot(\mathbf{A} \times
\mathbf{B}),\)</span> we can change the first term into:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \int_{\Omega}-\nabla \cdot(\nabla\times\mathbf{E}_s \times
\bar{\mathbf{v}})-\nabla \times \mathbf{E}_s \cdot \nabla
\times\bar{\mathbf{v}}+\varepsilon_{r} k_{0}^{2} \mathbf{E}_s
\cdot \bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_b\right)
\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{dx} \\
+&amp;\int_{\partial \Omega}
(\mathbf{n} \times \nabla \times \mathbf{E}_s) \cdot \bar{\mathbf{v}}
+\left(j n_bk_{0}+\frac{1}{2r}\right) (\mathbf{n} \times \mathbf{E}_s
\times \mathbf{n}) \cdot \bar{\mathbf{v}}~\mathrm{d}s=0,
\end{align}
\end{split}\]</div>
<p>using the divergence theorem
<span class="math notranslate nohighlight">\(\int_\Omega\nabla\cdot\mathbf{F}~\mathrm{d}x = \int_{\partial\Omega}
\mathbf{F}\cdot\mathbf{n}~\mathrm{d}s\)</span>, we can write:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \int_{\Omega}-(\nabla \times \mathbf{E}_s) \cdot (\nabla \times
\bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2} \mathbf{E}_s \cdot
\bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_b\right)
\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x \\
+&amp;\int_{\partial \Omega}
-(\nabla\times\mathbf{E}_s \times \bar{\mathbf{v}})\cdot\mathbf{n}
+ (\mathbf{n} \times \nabla \times \mathbf{E}_s) \cdot \bar{\mathbf{v}}
+\left(j n_bk_{0}+\frac{1}{2r}\right) (\mathbf{n} \times \mathbf{E}_s
\times \mathbf{n}) \cdot \bar{\mathbf{v}}~\mathrm{d}s=0.
\end{align}
\end{split}\]</div>
<p>Cancelling <span class="math notranslate nohighlight">\(-(\nabla\times\mathbf{E}_s \times \bar{\mathbf{V}})
\cdot\mathbf{n}\)</span>  and <span class="math notranslate nohighlight">\(\mathbf{n} \times \nabla \times \mathbf{E}_s
\cdot \bar{\mathbf{V}}\)</span> and rearrange <span class="math notranslate nohighlight">\(\left((\mathbf{n} \times \mathbf{E}_s)
\times \mathbf{n}\right) \cdot \bar{\mathbf{v}}\)</span> to <span class="math notranslate nohighlight">\( (\mathbf{E}_s \times\mathbf{n})
\cdot (\bar{\mathbf{v}} \times \mathbf{n})\)</span> using the triple product rule <span class="math notranslate nohighlight">\(\mathbf{A}
\cdot(\mathbf{B} \times \mathbf{C})=\mathbf{B} \cdot(\mathbf{C} \times
\mathbf{A})=\mathbf{C} \cdot(\mathbf{A} \times \mathbf{B})\)</span>, we get:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \int_{\Omega}-(\nabla \times \mathbf{E}_s) \cdot (\nabla \times
\bar{\mathbf{v}})+\varepsilon_{r} k_{0}^{2} \mathbf{E}_s \cdot
\bar{\mathbf{v}}+k_{0}^{2}\left(\varepsilon_{r}-\varepsilon_b\right)
\mathbf{E}_b \cdot \bar{\mathbf{v}}~\mathrm{d}x \\
+&amp;\int_{\partial \Omega}
\left(j n_bk_{0}+\frac{1}{2r}\right)( \mathbf{n} \times \mathbf{E}_s \times
\mathbf{n}) \cdot \bar{\mathbf{v}} ~\mathrm{d} s = 0.
\end{align}
\end{split}\]</div>
<p>We use the <a class="reference external" href="https://github.com/FEniCS/ufl/">UFL</a> to implement the
residual</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Weak form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span>
    <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">Es</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Es</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">-</span> <span class="n">eps_bkg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">Eb</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dDom</span>
    <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>
    <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Es_3d</span><span class="p">,</span> <span class="n">n_3d</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v_3d</span><span class="p">,</span> <span class="n">n_3d</span><span class="p">))</span>
    <span class="o">*</span> <span class="n">dsbc</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We split the residual into a sesquilinear (lhs) and linear (rhs) form
and solve the problem. We store the scattered field <span class="math notranslate nohighlight">\(\mathbf{E}_s\)</span> as
<code class="docutils literal notranslate"><span class="pre">Esh</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">})</span>
<span class="n">Esh</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>We save the solution as an <a class="reference external" href="https://adios2.readthedocs.io/en/latest/ecosystem/visualization.html">ADIOS2
bp</a>
folder. In order to do so, we need to interpolate our solution
discretized with Nedelec elements into a suitable discontinuous
Lagrange space.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gdim</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">dim</span>
<span class="n">V_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Discontinuous Lagrange&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="p">(</span><span class="n">gdim</span><span class="p">,)))</span>
<span class="n">Esh_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
<span class="n">Esh_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Esh</span><span class="p">)</span>

<span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">VTXWriter</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="s2">&quot;Esh.bp&quot;</span><span class="p">,</span> <span class="n">Esh_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">vtx</span><span class="p">:</span>
    <span class="n">vtx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We visualize the solution using PyVista. For more information about
saving and visualizing vector fields discretized with Nedelec
elements, check <a class="reference external" href="https://docs.fenicsproject.org/dolfinx/main/python/demos/demo_interpolation-io.html">this</a>
DOLFINx demo.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
    <span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
    <span class="n">V_grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span><span class="p">)</span>
    <span class="n">Esh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">Esh_values</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">Esh_dg</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
    <span class="p">)</span><span class="o">.</span><span class="n">real</span>

    <span class="n">V_grid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Esh_values</span>

    <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">&quot;magnitude&quot;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">V_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">link_views</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;Esh.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">800</span><span class="p">])</span>
</pre></div>
</div>
<p>Next we can calculate the total electric field
<span class="math notranslate nohighlight">\(\mathbf{E}=\mathbf{E}_s+\mathbf{E}_b\)</span> and save it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">E</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Eb</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">Esh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span>
<span class="n">E_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
<span class="n">E_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">VTXWriter</span><span class="p">(</span><span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="s2">&quot;E.bp&quot;</span><span class="p">,</span> <span class="n">E_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">vtx</span><span class="p">:</span>
    <span class="n">vtx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We validate our numerical solution by computing the absorption,
scattering and extinction efficiencies, which are quantities that
define how much light is absorbed and scattered by the wire. First of
all, we calculate the analytical efficiencies with the
<code class="docutils literal notranslate"><span class="pre">calculate_analytical_efficiencies</span></code> function defined in a separate
file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculation of analytical efficiencies</span>
<span class="n">q_abs_analyt</span><span class="p">,</span> <span class="n">q_sca_analyt</span><span class="p">,</span> <span class="n">q_ext_analyt</span> <span class="o">=</span> <span class="n">calculate_analytical_efficiencies</span><span class="p">(</span>
    <span class="n">eps_au</span><span class="p">,</span> <span class="n">n_bkg</span><span class="p">,</span> <span class="n">wl0</span><span class="p">,</span> <span class="n">radius_wire</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we can calculate the numerical efficiencies. The formula for the
absorption, scattering and extinction are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; Q_{abs} = \operatorname{Re}\left(\int_{\Omega_{m}} \frac{1}{2}
  \frac{\operatorname{Im}(\varepsilon_m)k_0}{Z_0n_b}
  \mathbf{E}\cdot\hat{\mathbf{E}}dx\right) \\
&amp; Q_{sca} = \operatorname{Re}\left(\int_{\partial\Omega} \frac{1}{2}
  \left(\mathbf{E}_s\times\bar{\mathbf{H}}_s\right)
  \cdot\mathbf{n}ds\right)\\ \\
&amp; Q_{ext} = Q_{abs} + Q_{sca},
\end{align}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(Z_0 = \sqrt{\frac{\mu_0}{\varepsilon_0}}\)</span> being the vacuum
impedance, and <span class="math notranslate nohighlight">\(\mathbf{H}_s =
-j\frac{1}{Z_0k_0n_b}\nabla\times\mathbf{E}_s\)</span> being the scattered
magnetic field. We can then normalize these values over the intensity
of the electromagnetic field <span class="math notranslate nohighlight">\(I_0\)</span> and the geometrical cross section
of the wire, <span class="math notranslate nohighlight">\(\sigma_{gcs} = 2r_w\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; q_{abs} = \frac{Q_{abs}}{I_0\sigma_{gcs}} \\
&amp; q_{sca} = \frac{Q_{sca}}{I_0\sigma_{gcs}} \\
&amp; q_{ext} = q_{abs} + q_{sca}.
\end{align}
\end{split}\]</div>
<p>We can calculate these values in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Vacuum impedance</span>
<span class="n">Z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu_0</span> <span class="o">/</span> <span class="n">epsilon_0</span><span class="p">)</span>

<span class="c1"># Magnetic field H</span>
<span class="n">Hsh_3d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">curl_2d</span><span class="p">(</span><span class="n">Esh</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">n_bkg</span><span class="p">)</span>

<span class="n">Esh_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">Esh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Esh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">E_3d</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_vector</span><span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Intensity of the electromagnetic fields I0 = 0.5*E0**2/Z0 E0 =</span>
<span class="c1"># np.sqrt(ax**2 + ay**2) = 1, see background_electric_field</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">Z0</span>

<span class="c1"># Geometrical cross section of the wire</span>
<span class="n">gcs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_wire</span>

<span class="c1"># Quantities for the calculation of efficiencies</span>
<span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Esh_3d</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Hsh_3d</span><span class="p">)),</span> <span class="n">n_3d</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">eps_au</span><span class="p">)</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">E_3d</span><span class="p">,</span> <span class="n">E_3d</span><span class="p">))</span> <span class="o">/</span> <span class="n">Z0</span> <span class="o">/</span> <span class="n">n_bkg</span>

<span class="c1"># Define integration domain for the wire</span>
<span class="n">dAu</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">au_tag</span><span class="p">)</span>

<span class="c1"># Normalized absorption efficiency</span>
<span class="n">q_abs_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">Q</span> <span class="o">*</span> <span class="n">dAu</span><span class="p">))</span> <span class="o">/</span> <span class="n">gcs</span> <span class="o">/</span> <span class="n">I0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="n">q_abs_fenics</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_abs_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

<span class="c1"># Normalized scattering efficiency</span>
<span class="n">q_sca_fenics_proc</span> <span class="o">=</span> <span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="n">dsbc</span><span class="p">))</span> <span class="o">/</span> <span class="n">gcs</span> <span class="o">/</span> <span class="n">I0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="n">q_sca_fenics</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">q_sca_fenics_proc</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

<span class="c1"># Extinction efficiency</span>
<span class="n">q_ext_fenics</span> <span class="o">=</span> <span class="n">q_abs_fenics</span> <span class="o">+</span> <span class="n">q_sca_fenics</span>

<span class="c1"># Error calculation</span>
<span class="n">err_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_abs_analyt</span> <span class="o">-</span> <span class="n">q_abs_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_abs_analyt</span>
<span class="n">err_sca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_sca_analyt</span> <span class="o">-</span> <span class="n">q_sca_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_sca_analyt</span>
<span class="n">err_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_ext_analyt</span> <span class="o">-</span> <span class="n">q_ext_fenics</span><span class="p">)</span> <span class="o">/</span> <span class="n">q_ext_analyt</span>

<span class="c1"># Check if errors are smaller than 1%</span>
<span class="k">assert</span> <span class="n">err_abs</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
<span class="k">assert</span> <span class="n">err_sca</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
<span class="k">assert</span> <span class="n">err_ext</span> <span class="o">&lt;</span> <span class="mf">0.01</span>

<span class="k">if</span> <span class="n">mesh_data</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical absorption efficiency is </span><span class="si">{</span><span class="n">q_abs_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical absorption efficiency is </span><span class="si">{</span><span class="n">q_abs_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_abs</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical scattering efficiency is </span><span class="si">{</span><span class="n">q_sca_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical scattering efficiency is </span><span class="si">{</span><span class="n">q_sca_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_sca</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The analytical extinction efficiency is </span><span class="si">{</span><span class="n">q_ext_analyt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The numerical extinction efficiency is </span><span class="si">{</span><span class="n">q_ext_fenics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The error is </span><span class="si">{</span><span class="n">err_ext</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="demo_helmholtz.html" class="btn btn-neutral float-left" title="Helmholtz equation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demo_pml.html" class="btn btn-neutral float-right" title="Electromagnetic scattering from a wire with perfectly matched layer condition" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, FEniCS Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
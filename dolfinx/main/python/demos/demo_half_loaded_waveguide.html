

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electromagnetic modal analysis for a waveguide &mdash; DOLFINx 0.10.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=15ca63c5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electromagnetic scattering from a sphere (axisymmetric)" href="demo_axis.html" />
    <link rel="prev" title="Electromagnetic scattering from a wire with perfectly matched layer condition # noqa" href="demo_pml.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DOLFINx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../demos.html">Demos</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#pdes-introductory">PDEs (introductory)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_scattering_boundary_conditions.html">Electromagnetic scattering from a wire with scattering boundary conditions # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pml.html">Electromagnetic scattering from a wire with perfectly matched layer condition # noqa</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic modal analysis for a waveguide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-and-problem-definition">Equations and problem definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analytical-solutions-for-the-half-loaded-waveguide">Analytical solutions for the half-loaded waveguide</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solve-the-problem-in-slepc">Solve the problem in SLEPc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#pdes-advanced">PDEs (advanced)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#nonlinear-problems">Nonlinear problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#mesh-generation">Mesh generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#interpolation-io-and-visualisation">Interpolation, IO and visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#advanced-iterative-solvers">Advanced iterative solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#user-defined-and-advanced-finite-elements">User-defined and advanced finite elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../demos.html#parallel-communication-analysis">Parallel communication analysis</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../demos.html#list-of-all-demos">List of all demos</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="demo_poisson.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_biharmonic.html">Biharmonic equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_cahn-hilliard.html">Cahn-Hilliard equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_stokes.html">Stokes equations using Taylor-Hood elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_elasticity.html">Elasticity using algebraic multigrid</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_gmsh.html">Mesh generation with Gmsh</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_helmholtz.html">Helmholtz equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_static-condensation.html">Static condensation of linear elasticity</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyvista.html">Visualization with PyVista</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_interpolation-io.html">Interpolation and IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_types.html">Solving PDEs with different scalar (float) types</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_lagrange_variants.html">Variants of Lagrange elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_tnt-elements.html">Creating TNT elements using Basix’s custom element interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_scattering_boundary_conditions.html">Electromagnetic scattering from a wire with scattering boundary conditions # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pml.html">Electromagnetic scattering from a wire with perfectly matched layer condition # noqa</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Electromagnetic modal analysis for a waveguide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equations-and-problem-definition">Equations and problem definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analytical-solutions-for-the-half-loaded-waveguide">Analytical solutions for the half-loaded waveguide</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solve-the-problem-in-slepc">Solve the problem in SLEPc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="demo_axis.html">Electromagnetic scattering from a sphere (axisymmetric)</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_navier-stokes.html">Divergence conforming discontinuous Galerkin method for the Navier–Stokes equations # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-poisson.html">Mixed formulation of the Poisson equation with a block-preconditioner/solver # noqa</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_pyamg.html">Solve the Poisson and linearised elasticity equations using pyamg</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_hdg.html">HDG scheme for the Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_mixed-topology.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="demo_comm-pattern.html">Parallel communication pattern analysis</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DOLFINx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../demos.html">Demos</a></li>
      <li class="breadcrumb-item active">Electromagnetic modal analysis for a waveguide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demos/demo_half_loaded_waveguide.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="electromagnetic-modal-analysis-for-a-waveguide">
<h1>Electromagnetic modal analysis for a waveguide<a class="headerlink" href="#electromagnetic-modal-analysis-for-a-waveguide" title="Link to this heading"></a></h1>
<p>Copyright (C) 2022 Michele Castriotta, Igor Baratta, Jørgen S. Dokken</p>
<p>This demo is implemented in two files, one for defining and solving
the eigenvalue problem for a half-loaded electromagnetic waveguide
with perfect electric conducting walls, and one for verifying if the
numerical eigenvalues are consistent with the analytical modes of the
problem.</p>
<p>The demo shows how to:</p>
<ul class="simple">
<li><p>Setup an eigenvalue problem for Maxwell’s equations</p></li>
<li><p>Use SLEPc for solving eigenvalue problems</p></li>
</ul>
<section id="equations-and-problem-definition">
<h2>Equations and problem definition<a class="headerlink" href="#equations-and-problem-definition" title="Link to this heading"></a></h2>
<p>In this demo, we are going to show how to solve the eigenvalue problem
associated with a half-loaded rectangular waveguide with perfect
electric conducting walls.</p>
<p>First of all, let’s import the modules we need for solving the
problem:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">slepc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">SLEPc</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">basix.ufl</span><span class="w"> </span><span class="kn">import</span> <span class="n">element</span><span class="p">,</span> <span class="n">mixed_element</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx</span><span class="w"> </span><span class="kn">import</span> <span class="n">fem</span><span class="p">,</span> <span class="n">plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">assemble_matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">CellType</span><span class="p">,</span> <span class="n">create_rectangle</span><span class="p">,</span> <span class="n">exterior_facet_indices</span><span class="p">,</span> <span class="n">locate_entities</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pyvista</span>

    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pyvista and pyvistaqt are required to visualise the solution&quot;</span><span class="p">)</span>
    <span class="n">have_pyvista</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">IntType</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="ow">and</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This solver fails with PETSc and 64-bit integers because of memory errors in MUMPS.&quot;</span><span class="p">)</span>
    <span class="c1"># Note: when PETSc.IntType == np.int32, superlu_dist is used</span>
    <span class="c1"># rather than MUMPS and does not trigger memory failures.</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">VTXWriter</span>

    <span class="n">has_vtx</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;VTXWriter not available, solution will not be saved.&quot;</span><span class="p">)</span>
    <span class="n">has_vtx</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</section>
<section id="analytical-solutions-for-the-half-loaded-waveguide">
<h2>Analytical solutions for the half-loaded waveguide<a class="headerlink" href="#analytical-solutions-for-the-half-loaded-waveguide" title="Link to this heading"></a></h2>
<p>The analytical solutions for the half-loaded waveguide with perfect
electric conducting walls are described in Harrington’s <em>Time-harmonic
electromagnetic fields</em>. We will skip the full derivation, and we just
mention that the problem can be decoupled into <span class="math notranslate nohighlight">\(\mathrm{TE}_x\)</span> and
<span class="math notranslate nohighlight">\(\mathrm{TM}_x\)</span> modes, and the possible <span class="math notranslate nohighlight">\(k_z\)</span> can be found by solving
a set of transcendental equations, which is shown here below:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\textrm{For TE}_x \textrm{ modes}:
\begin{cases}
&amp;k_{x d}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=k_0^{2}
\varepsilon_{d} \\
&amp;k_{x v}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=k_0^{2}
\varepsilon_{v} \\
&amp; k_{x d} \cot k_{x d} d + k_{x v} \cot \left[k_{x v}(h-d)\right] = 0
\end{cases}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\textrm{For TM}_x \textrm{ modes}:
\begin{cases}
&amp;k_{x d}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=
k_0^{2} \varepsilon_{d} \\
&amp;k_{x v}^{2}+\left(\frac{n \pi}{w}\right)^{2}+k_{z}^{2}=
k_0^{2} \varepsilon_{v} \\
&amp; \frac{k_{x d}}{\varepsilon_{d}} \tan k_{x d} d +
\frac{k_{x v}}{\varepsilon_{v}} \tan \left[k_{x v}(h-d)\right] = 0
\end{cases}
\end{split}\]</div>
<p>with:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\varepsilon_d\rightarrow\)</span> dielectric permittivity</p></li>
<li><p><span class="math notranslate nohighlight">\(\varepsilon_v\rightarrow\)</span> vacuum permittivity</p></li>
<li><p><span class="math notranslate nohighlight">\(w\rightarrow\)</span> total width of the waveguide</p></li>
<li><p><span class="math notranslate nohighlight">\(h\rightarrow\)</span> total height of the waveguide</p></li>
<li><p><span class="math notranslate nohighlight">\(d\rightarrow\)</span> height of the dielectric fraction</p></li>
<li><p><span class="math notranslate nohighlight">\(k_0\rightarrow\)</span> vacuum wavevector</p></li>
<li><p><span class="math notranslate nohighlight">\(k_{xd}\rightarrow\)</span> <span class="math notranslate nohighlight">\(x\)</span> component of the wavevector in the dielectric</p></li>
<li><p><span class="math notranslate nohighlight">\(k_{xv}\rightarrow\)</span> <span class="math notranslate nohighlight">\(x\)</span> component of the wavevector in the vacuum</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{n \pi}{w} = k_y\rightarrow\)</span> <span class="math notranslate nohighlight">\(y\)</span> component of the wavevector
for different <span class="math notranslate nohighlight">\(n\)</span> harmonic numbers (we assume <span class="math notranslate nohighlight">\(n=1\)</span> for the sake of
simplicity)</p></li>
</ul>
<p>Let’s define the set of equations with the <span class="math notranslate nohighlight">\(\tan\)</span> and <span class="math notranslate nohighlight">\(\cot\)</span> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">TMx_condition</span><span class="p">(</span>
    <span class="n">kx_d</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">kx_d</span> <span class="o">/</span> <span class="n">eps_d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_d</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">kx_v</span> <span class="o">/</span> <span class="n">eps_v</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">d</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">TEx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">kx_d</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_d</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">kx_v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">kx_v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">d</span><span class="p">))</span>
</pre></div>
</div>
<p>Then, we can define the <code class="docutils literal notranslate"><span class="pre">verify_mode</span></code> function, to check whether a
certain <span class="math notranslate nohighlight">\(k_z\)</span> satisfy the equations (below a certain threshold). In
other words, we provide a certain <span class="math notranslate nohighlight">\(k_z\)</span>, together with the geometrical
and optical parameters of the waveguide, and <code class="docutils literal notranslate"><span class="pre">verify_mode()</span></code> checks
whether the last equations for the <span class="math notranslate nohighlight">\(\mathrm{TE}_x\)</span> or <span class="math notranslate nohighlight">\(\mathrm{TM}_x\)</span>
modes are close to <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">verify_mode</span><span class="p">(</span>
    <span class="n">kz</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">w</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">lmbd0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">eps_d</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">eps_v</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
    <span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">lmbd0</span>
    <span class="n">ky</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">w</span>  <span class="c1"># we assume n = 1</span>
    <span class="n">kx_d_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps_d</span> <span class="o">-</span> <span class="n">ky</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="n">kz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">kx_d_target</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">k0</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps_d</span> <span class="o">-</span> <span class="n">eps_v</span><span class="p">)</span>
    <span class="n">kx_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">kx_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">f_tm</span> <span class="o">=</span> <span class="n">TMx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">f_te</span> <span class="o">=</span> <span class="n">TEx_condition</span><span class="p">(</span><span class="n">kx_d</span><span class="p">,</span> <span class="n">kx_v</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">f_tm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">f_te</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
</pre></div>
</div>
<p>We now define the domain. It is a rectangular domain with width <span class="math notranslate nohighlight">\(w\)</span>
and height <span class="math notranslate nohighlight">\(h = 0.45w\)</span>, with the dielectric medium filling the
lower-half of the domain, with a height of <span class="math notranslate nohighlight">\(d=0.5h\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.45</span> <span class="o">*</span> <span class="n">w</span>
<span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span>
<span class="n">nx</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">nx</span><span class="p">)</span>

<span class="n">msh</span> <span class="o">=</span> <span class="n">create_rectangle</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">]]),</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">CellType</span><span class="o">.</span><span class="n">quadrilateral</span><span class="p">)</span>
<span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">create_connectivity</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can define the dielectric permittivity <span class="math notranslate nohighlight">\(\varepsilon_r\)</span> over the
domain as <span class="math notranslate nohighlight">\(\varepsilon_r = \varepsilon_v = 1\)</span> in the vacuum, and as
<span class="math notranslate nohighlight">\(\varepsilon_r = \varepsilon_d = 2.45\)</span> in the dielectric:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps_v</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">eps_d</span> <span class="o">=</span> <span class="mf">2.45</span>


<span class="k">def</span><span class="w"> </span><span class="nf">Omega_d</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span>


<span class="k">def</span><span class="w"> </span><span class="nf">Omega_v</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">d</span>


<span class="n">D</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DQ&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">eps</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

<span class="n">cells_v</span> <span class="o">=</span> <span class="n">locate_entities</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">Omega_v</span><span class="p">)</span>
<span class="n">cells_d</span> <span class="o">=</span> <span class="n">locate_entities</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">Omega_d</span><span class="p">)</span>

<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">cells_d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cells_d</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span>
<span class="n">eps</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">cells_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">cells_v</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to find the weak form of our problem, the starting point are
Maxwell’s equation and the perfect electric conductor condition on the
waveguide wall:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp;\nabla \times \frac{1}{\mu_{r}} \nabla \times \mathbf{E}-k_{o}^{2}
\epsilon_{r} \mathbf{E}=0 \quad &amp;\text { in } \Omega\\
&amp;\hat{n}\times\mathbf{E} = 0 &amp;\text { on } \Gamma
\end{align}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(k_0\)</span> and <span class="math notranslate nohighlight">\(\lambda_0 = 2\pi/k_0\)</span> being the wavevector and the
wavelength, which we consider fixed at <span class="math notranslate nohighlight">\(\lambda = h/0.2\)</span>. If we focus
on non-magnetic material only, we can also use <span class="math notranslate nohighlight">\(\mu_r=1\)</span>.</p>
<p>Now we can assume a known dependence on <span class="math notranslate nohighlight">\(z\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{E}(x, y, z)=\left[\mathbf{E}_{t}(x, y)+\hat{z} E_{z}(x, y)\right]
e^{-jk_z z}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{E}_t\)</span> is the component of the electric field transverse
to the waveguide axis, and <span class="math notranslate nohighlight">\(E_z\)</span> is the component  of the electric
field parallel to the waveguide axis, and <span class="math notranslate nohighlight">\(k_z\)</span> represents our complex
propagation constant.</p>
<p>In order to pose the problem as an eigenvalue problem, we need to make
the following substitution:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
&amp; \mathbf{e}_t = k_z\mathbf{E}_t\\
&amp; e_z = -jE_z
\end{align}
\end{split}\]</div>
<p>The final weak form can be written as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
F_{k_z}(\mathbf{e})=\int_{\Omega} &amp;\left(\nabla_{t} \times
\mathbf{e}_{t}\right) \cdot\left(\nabla_{t} \times
\bar{\mathbf{v}}_{t}\right) -k_{o}^{2} \epsilon_{r} \mathbf{e}_{t} \cdot
\bar{\mathbf{v}}_{t} \\
&amp;+k_z^{2}\left[\left(\nabla_{t} e_{z}+\mathbf{e}_{t}\right)
\cdot\left(\nabla_{t} \bar{v}_{z}+\bar{\mathbf{v}}_{t}\right)-k_{o}^{2}
\epsilon_{r} e_{z} \bar{v}_{z}\right] \mathrm{d} x = 0
\end{aligned}
\end{split}\]</div>
<p>Or, in a more compact form, as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[\begin{array}{cc}
A_{t t} &amp; 0 \\
0 &amp; 0
\end{array}\right]\left\{\begin{array}{l}
\mathbf{e}_{t} \\
e_{z}
\end{array}\right\}=-k_z^{2}\left[\begin{array}{ll}
B_{t t} &amp; B_{t z} \\
B_{z t} &amp; B_{z z}
\end{array}\right]\left\{\begin{array}{l}
\mathbf{e}_{t} \\
e_{z}
\end{array}\right\}
\end{split}\]</div>
<p>A problem of this kind is known as a generalized eigenvalue problem,
where our eigenvalues are all the possible <span class="math notranslate nohighlight">\( -k_z^2\)</span>. For further
details about this problem, check Jin’s <em>The Finite Element Method in
Electromagnetics, third edition</em>.</p>
<p>To write the weak form, we need to specify our function space. For
<span class="math notranslate nohighlight">\(\mathbf{e}_t\)</span>, we can use RTCE elements (the equivalent of Nedelec
elements on quadrilateral cells), while for <span class="math notranslate nohighlight">\(e_z\)</span> field we can use
Lagrange elements. This hybrid formulation is implemented with
<code class="docutils literal notranslate"><span class="pre">mixed_element</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">degree</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">RTCE</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;RTCE&quot;</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">basix_cell</span><span class="p">(),</span> <span class="n">degree</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">RealType</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">basix_cell</span><span class="p">(),</span> <span class="n">degree</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">RealType</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="n">mixed_element</span><span class="p">([</span><span class="n">RTCE</span><span class="p">,</span> <span class="n">Q</span><span class="p">]))</span>
</pre></div>
</div>
<p>Now we can define our weak form:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lmbd0</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="mf">0.2</span>
<span class="n">k0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">lmbd0</span>

<span class="n">et</span><span class="p">,</span> <span class="n">ez</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunctions</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">vt</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunctions</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">a_tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">et</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">vt</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">vt</span><span class="p">))</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">b_tt</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">b_tz</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">vz</span><span class="p">))</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">b_zt</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">ez</span><span class="p">),</span> <span class="n">vt</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">b_zz</span> <span class="o">=</span> <span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">ez</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">vz</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ez</span><span class="p">,</span> <span class="n">vz</span><span class="p">))</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">a_tt</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">b_tt</span> <span class="o">+</span> <span class="n">b_tz</span> <span class="o">+</span> <span class="n">b_zt</span> <span class="o">+</span> <span class="n">b_zz</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s add the perfect electric conductor conditions on the waveguide
wall:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bc_facets</span> <span class="o">=</span> <span class="n">exterior_facet_indices</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>
<span class="n">bc_dofs</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">locate_dofs_topological</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bc_facets</span><span class="p">)</span>
<span class="n">u_bc</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">with</span> <span class="n">u_bc</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">petsc_vec</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">loc</span><span class="p">:</span>
    <span class="n">loc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">dirichletbc</span><span class="p">(</span><span class="n">u_bc</span><span class="p">,</span> <span class="n">bc_dofs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="solve-the-problem-in-slepc">
<h2>Solve the problem in SLEPc<a class="headerlink" href="#solve-the-problem-in-slepc" title="Link to this heading"></a></h2>
<p>Now we can solve the problem with SLEPc. First of all, we need to
assemble our <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrices with PETSc in this way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span>
<span class="n">A</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span>
<span class="n">B</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
</pre></div>
</div>
<p>Now, we need to create the eigenvalue problem in SLEPc. Our problem is
a linear eigenvalue problem, that in SLEPc is solved with the <code class="docutils literal notranslate"><span class="pre">EPS</span></code>
module. We can initialize this solver in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
</pre></div>
</div>
<p>We can pass to <code class="docutils literal notranslate"><span class="pre">EPS</span></code> our matrices by using the <code class="docutils literal notranslate"><span class="pre">setOperators</span></code> routine:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>If the matrices in the problem have known properties (e.g.
hermiticity) we can use this information in SLEPc to accelerate the
calculation with the <code class="docutils literal notranslate"><span class="pre">setProblemType</span></code> function. For this problem,
there is no property that can be exploited, and therefore we define it
as a generalized non-Hermitian eigenvalue problem with the
<code class="docutils literal notranslate"><span class="pre">SLEPc.EPS.ProblemType.GNHEP</span></code> object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setProblemType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">ProblemType</span><span class="o">.</span><span class="n">GNHEP</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we need to specify a tolerance for the iterative solver, so that
it knows when to stop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-9</span>
<span class="n">eps</span><span class="o">.</span><span class="n">setTolerances</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we need to set the eigensolver for our problem. SLEPc offers
different built-in algorithms, and also wrappers to external
libraries. Some of these can only solve Hermitian problems and/or
problems with eigenvalues in a certain portion of the spectrum.
However, the choice of the particular method to choose to solve a
problem is a technical discussion that is out of the scope of this
demo, and that is more comprehensively discussed in the <a class="reference external" href="https://slepc.upv.es/documentation/slepc.pdf">SLEPc
documentation</a>. For our
problem, we will use the Krylov-Schur method, which we can set by
calling the <code class="docutils literal notranslate"><span class="pre">setType</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">KRYLOVSCHUR</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to accelerate the calculation of our solutions, we can also
use a so-called <em>spectral transformation</em>, a technique which maps the
original eigenvalues into another position of the spectrum without
affecting the eigenvectors. In our case, we can use the
shift-and-invert transformation with the <code class="docutils literal notranslate"><span class="pre">SLEPc.ST.Type.SINVERT</span></code>
object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get ST context from eps</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">eps</span><span class="o">.</span><span class="n">getST</span><span class="p">()</span>

<span class="c1"># Set shift-and-invert transformation</span>
<span class="n">st</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">ST</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SINVERT</span><span class="p">)</span>
</pre></div>
</div>
<p>The spectral transformation needs a target value for the eigenvalues
we are looking for. Since the eigenvalues for our problem can be
complex numbers, we need to specify whether we are searching for
specific values in the real part, in the imaginary part, or in the
magnitude. In our case, we are interested in propagating modes, and
therefore in real <span class="math notranslate nohighlight">\(k_z\)</span>. For this reason, we can specify with the
<code class="docutils literal notranslate"><span class="pre">setWhichEigenpairs</span></code> function that our target value will refer to the
real part of the eigenvalue, with the <code class="docutils literal notranslate"><span class="pre">SLEPc.EPS.Which.TARGET_REAL</span></code>
object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setWhichEigenpairs</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Which</span><span class="o">.</span><span class="n">TARGET_REAL</span><span class="p">)</span>
</pre></div>
</div>
<p>For specifying the target value, we can use the <code class="docutils literal notranslate"><span class="pre">setTarget</span></code> function.
Even though we cannot know a good target value a priori, we can guess
that <span class="math notranslate nohighlight">\(k_z\)</span> will be quite close to <span class="math notranslate nohighlight">\(k_0\)</span> in value, for instance <span class="math notranslate nohighlight">\(k_z =
0.5k_0^2\)</span>. Therefore, we can set a target value of <span class="math notranslate nohighlight">\(-(0.5k_0^2)\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setTarget</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">k0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Then, we need to define the number of eigenvalues we want to
calculate. We can do this with the <code class="docutils literal notranslate"><span class="pre">setDimensions</span></code> function, where we
specify that we are looking for just one eigenvalue:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">setDimensions</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We can finally solve the problem with the <code class="docutils literal notranslate"><span class="pre">solve</span></code> function. To gain a
deeper insight over the simulation, we also print an output message
from SLEPc by calling the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">errorView</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">eps</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="n">eps</span><span class="o">.</span><span class="n">errorView</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we can get the eigenvalues and eigenvectors calculated by SLEPc
with the following code. We also verify if the numerical <span class="math notranslate nohighlight">\(k_z\)</span> are
consistent with the analytical equations of the half-loaded waveguide
modes, with the <code class="docutils literal notranslate"><span class="pre">verify_mode()</span></code> function defined in
<code class="docutils literal notranslate"><span class="pre">analytical_modes.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save the kz</span>
<span class="n">vals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">eps</span><span class="o">.</span><span class="n">getEigenvalue</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eps</span><span class="o">.</span><span class="n">getConverged</span><span class="p">())]</span>

<span class="c1"># Sort kz by real part</span>
<span class="n">vals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

<span class="n">eh</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">kz_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kz</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
    <span class="c1"># Save eigenvector in eh</span>
    <span class="n">eps</span><span class="o">.</span><span class="n">getEigenpair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">petsc_vec</span><span class="p">)</span>

    <span class="c1"># Compute error for i-th eigenvalue</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">eps</span><span class="o">.</span><span class="n">computeError</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">ErrorType</span><span class="o">.</span><span class="n">RELATIVE</span><span class="p">)</span>

    <span class="c1"># Verify, save and visualize solution</span>
    <span class="k">if</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">kz</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
        <span class="n">kz_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>

        <span class="c1"># Verify if kz is consistent with the analytical equations</span>
        <span class="k">assert</span> <span class="n">verify_mode</span><span class="p">(</span><span class="n">kz</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">lmbd0</span><span class="p">,</span> <span class="n">eps_d</span><span class="p">,</span> <span class="n">eps_v</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eigenvalue: </span><span class="si">{</span><span class="o">-</span><span class="p">(</span><span class="n">kz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kz: </span><span class="si">{</span><span class="n">kz</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kz/k0: </span><span class="si">{</span><span class="n">kz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">k0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">eh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>

        <span class="n">eth</span><span class="p">,</span> <span class="n">ezh</span> <span class="o">=</span> <span class="n">eh</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">eth</span> <span class="o">=</span> <span class="n">eh</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
        <span class="n">ez</span> <span class="o">=</span> <span class="n">eh</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>

        <span class="c1"># Transform eth, ezh into Et and Ez</span>
        <span class="n">eth</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">/</span> <span class="n">kz</span>
        <span class="n">ezh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ezh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

        <span class="n">gdim</span> <span class="o">=</span> <span class="n">msh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">V_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DQ&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="p">(</span><span class="n">gdim</span><span class="p">,)))</span>
        <span class="n">Et_dg</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
        <span class="n">Et_dg</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">eth</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">has_vtx</span><span class="p">:</span>
            <span class="c1"># Save solutions</span>
            <span class="k">with</span> <span class="n">VTXWriter</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sols/Et_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.bp&quot;</span><span class="p">,</span> <span class="n">Et_dg</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">VTXWriter</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sols/Ez_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.bp&quot;</span><span class="p">,</span> <span class="n">ezh</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Visualize solutions with Pyvista</span>
        <span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
            <span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">V_dg</span><span class="p">)</span>
            <span class="n">V_grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span><span class="p">)</span>
            <span class="n">Et_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">Et_values</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">Et_dg</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">V_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
            <span class="p">)</span><span class="o">.</span><span class="n">real</span>

            <span class="n">V_grid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Et_values</span>

            <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">V_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">link_views</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
                <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
                <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;Et.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">have_pyvista</span><span class="p">:</span>
            <span class="n">V_lagr</span><span class="p">,</span> <span class="n">lagr_dofs</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
            <span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">vtk_mesh</span><span class="p">(</span><span class="n">V_lagr</span><span class="p">)</span>
            <span class="n">V_grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">V_cells</span><span class="p">,</span> <span class="n">V_types</span><span class="p">,</span> <span class="n">V_x</span><span class="p">)</span>
            <span class="n">V_grid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ezh</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">lagr_dofs</span><span class="p">]</span>
            <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">V_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">link_views</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
                <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">()</span>
                <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;Ez.png&quot;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="p">[</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="demo_pml.html" class="btn btn-neutral float-left" title="Electromagnetic scattering from a wire with perfectly matched layer condition # noqa" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demo_axis.html" class="btn btn-neutral float-right" title="Electromagnetic scattering from a sphere (axisymmetric)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, FEniCS Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
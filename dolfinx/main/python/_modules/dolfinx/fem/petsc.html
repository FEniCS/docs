

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dolfinx.fem.petsc &mdash; DOLFINx 0.11.0.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-codeautolink.css?v=b2176991" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=cba6a91b"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DOLFINx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../demos.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DOLFINx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../fem.html">dolfinx.fem</a></li>
      <li class="breadcrumb-item active">dolfinx.fem.petsc</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dolfinx.fem.petsc</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2018-2025 Garth N. Wells, Nathan Sime and JÃ¸rgen S. Dokken</span>
<span class="c1">#</span>
<span class="c1"># This file is part of DOLFINx (https://www.fenicsproject.org)</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier:    LGPL-3.0-or-later</span>
<span class="sd">&quot;&quot;&quot;High-level solver classes and functions for assembling PETSc objects.</span>

<span class="sd">Functions in this module generally apply functions in :mod:`dolfinx.fem`</span>
<span class="sd">to PETSc linear algebra objects and handle any PETSc-specific</span>
<span class="sd">preparation.</span>

<span class="sd">Note:</span>
<span class="sd">    The following does not apply to the high-level classes</span>
<span class="sd">    :class:`dolfinx.fem.petsc.LinearProblem`</span>
<span class="sd">    :class:`dolfinx.fem.petsc.NonlinearProblem`.</span>

<span class="sd">    Due to subtle issues in the interaction between petsc4py memory</span>
<span class="sd">    management and the Python garbage collector, it is recommended that</span>
<span class="sd">    the PETSc method ``destroy()`` is called on returned PETSc objects</span>
<span class="sd">    once the object is no longer required. Note that ``destroy()`` is</span>
<span class="sd">    collective over the object&#39;s MPI communicator.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_ctypes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span>

<span class="c1"># ruff: noqa: E402</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx</span>

<span class="k">assert</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">has_petsc4py</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">typing</span> <span class="k">as</span> <span class="n">npt</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx.cpp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_cpp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx.la.petsc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.cpp.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">discrete_curl</span> <span class="k">as</span> <span class="n">_discrete_curl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.cpp.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">discrete_gradient</span> <span class="k">as</span> <span class="n">_discrete_gradient</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.cpp.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolation_matrix</span> <span class="k">as</span> <span class="n">_interpolation_matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegralType</span><span class="p">,</span> <span class="n">pack_coefficients</span><span class="p">,</span> <span class="n">pack_constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.assemble</span><span class="w"> </span><span class="kn">import</span> <span class="n">_assemble_vector_array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.assemble</span><span class="w"> </span><span class="kn">import</span> <span class="n">apply_lifting</span> <span class="k">as</span> <span class="n">_apply_lifting</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.bcs</span><span class="w"> </span><span class="kn">import</span> <span class="n">DirichletBC</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.bcs</span><span class="w"> </span><span class="kn">import</span> <span class="n">bcs_by_block</span> <span class="k">as</span> <span class="n">_bcs_by_block</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.forms</span><span class="w"> </span><span class="kn">import</span> <span class="n">Form</span><span class="p">,</span> <span class="n">derivative_block</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.forms</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_function_spaces</span> <span class="k">as</span> <span class="n">_extract_function_spaces</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.forms</span><span class="w"> </span><span class="kn">import</span> <span class="n">form</span> <span class="k">as</span> <span class="n">_create_form</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.function</span><span class="w"> </span><span class="kn">import</span> <span class="n">Function</span> <span class="k">as</span> <span class="n">_Function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.function</span><span class="w"> </span><span class="kn">import</span> <span class="n">FunctionSpace</span> <span class="k">as</span> <span class="n">_FunctionSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">EntityMap</span> <span class="k">as</span> <span class="n">_EntityMap</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;LinearProblem&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NewtonSolverNonlinearProblem&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NonlinearProblem&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apply_lifting&quot;</span><span class="p">,</span>
    <span class="s2">&quot;assemble_jacobian&quot;</span><span class="p">,</span>
    <span class="s2">&quot;assemble_matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;assemble_residual&quot;</span><span class="p">,</span>
    <span class="s2">&quot;assemble_vector&quot;</span><span class="p">,</span>
    <span class="s2">&quot;assign&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cffi_utils&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_vector&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ctypes_utils&quot;</span><span class="p">,</span>
    <span class="s2">&quot;discrete_curl&quot;</span><span class="p">,</span>
    <span class="s2">&quot;discrete_gradient&quot;</span><span class="p">,</span>
    <span class="s2">&quot;interpolation_matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;numba_utils&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_bc&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1"># -- Vector instantiation -------------------------------------------------</span>


<div class="viewcode-block" id="create_vector">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.create_vector">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_vector</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="n">_FunctionSpace</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_FunctionSpace</span> <span class="o">|</span> <span class="kc">None</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a PETSc vector that is compatible with a linear form(s)</span>
<span class="sd">    or functionspace(s).</span>
<span class="sd">    Three cases are supported:</span>

<span class="sd">    1. For a single space ``V``, if ``kind`` is ``None`` or is</span>
<span class="sd">       ``PETSc.Vec.Type.MPI``, a ghosted PETSc vector which is compatible</span>
<span class="sd">       with ``V`` is created.</span>

<span class="sd">    2. If ``V`` is a sequence of functionspaces and ``kind`` is ``None`` or</span>
<span class="sd">       is ``PETSc.Vec.Type.MPI``, a ghosted PETSc vector which is</span>
<span class="sd">       compatible with ``V`` is created. The created vector ``b``</span>
<span class="sd">       is initialized such that on each MPI process ``b = [b_0, b_1, ...,</span>
<span class="sd">       b_n, b_0g, b_1g, ..., b_ng]``, where ``b_i`` are the entries</span>
<span class="sd">       associated with the &#39;owned&#39; degrees-of-freedom for ``V[i]`` and</span>
<span class="sd">       ``b_ig`` are the &#39;unowned&#39; (ghost) entries for ``V[i]``.</span>

<span class="sd">       For this case, the returned vector has an attribute ``_blocks``</span>
<span class="sd">       that holds the local offsets into ``b`` for the (i) owned and</span>
<span class="sd">       (ii) ghost entries for each ``V_i``. It can be accessed by</span>
<span class="sd">       ``b.getAttr(&quot;_blocks&quot;)``. The offsets can be used to get views</span>
<span class="sd">       into ``b`` for blocks, e.g.::</span>

<span class="sd">           &gt;&gt;&gt; offsets0, offsets1, = b.getAttr(&quot;_blocks&quot;)</span>
<span class="sd">           &gt;&gt;&gt; offsets0</span>
<span class="sd">           (0, 12, 28)</span>
<span class="sd">           &gt;&gt;&gt; offsets1</span>
<span class="sd">           (28, 32, 35)</span>
<span class="sd">           &gt;&gt;&gt; b0_owned = b.array[offsets0[0]:offsets0[1]]</span>
<span class="sd">           &gt;&gt;&gt; b0_ghost = b.array[offsets1[0]:offsets1[1]]</span>
<span class="sd">           &gt;&gt;&gt; b1_owned = b.array[offsets0[1]:offsets0[2]]</span>
<span class="sd">           &gt;&gt;&gt; b1_ghost = b.array[offsets1[1]:offsets1[2]]</span>

<span class="sd">    3. If ``L/V`` is a sequence of linear forms/functionspaces and ``kind``</span>
<span class="sd">       is ``PETSc.Vec.Type.NEST``, a PETSc nested vector (a &#39;nest&#39; of</span>
<span class="sd">       ghosted PETSc vectors) which is compatible with ``L/V`` is created.</span>

<span class="sd">    Args:</span>
<span class="sd">        V: Function space or a sequence of such.</span>
<span class="sd">        kind: PETSc vector type (``VecType``) to create.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A PETSc vector with a layout that is compatible with ``V``. The</span>
<span class="sd">        vector is not initialised to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">_FunctionSpace</span> <span class="o">|</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">FunctionSpace_float32</span> <span class="o">|</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">FunctionSpace_float64</span>
    <span class="p">):</span>
        <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">_V</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_V</span> <span class="ow">in</span> <span class="n">V</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can not create vector for None block.&quot;</span><span class="p">)</span>

    <span class="n">maps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_V</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="n">_V</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">index_map_bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_V</span> <span class="ow">in</span> <span class="n">V</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_vector</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span></div>



<span class="c1"># -- Matrix instantiation -------------------------------------------------</span>


<div class="viewcode-block" id="create_matrix">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.create_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_matrix</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a PETSc matrix that is compatible with the (sequence) of</span>
<span class="sd">    bilinear form(s).</span>

<span class="sd">    Three cases are supported:</span>

<span class="sd">    1. For a single bilinear form, it creates a compatible PETSc matrix</span>
<span class="sd">       of type ``kind``.</span>
<span class="sd">    2. For a rectangular array of bilinear forms, if ``kind`` is</span>
<span class="sd">       ``PETSc.Mat.Type.NEST`` or ``kind`` is an array of PETSc ``Mat``</span>
<span class="sd">       types (with the same shape as ``a``), a matrix of type</span>
<span class="sd">       ``PETSc.Mat.Type.NEST`` is created. The matrix is compatible</span>
<span class="sd">       with the forms ``a``.</span>
<span class="sd">    3. For a rectangular array of bilinear forms, it create a single</span>
<span class="sd">       (non-nested) matrix of type ``kind`` that is compatible with the</span>
<span class="sd">       array of for forms ``a``. If ``kind`` is ``None``, then the</span>
<span class="sd">       matrix is the default type.</span>

<span class="sd">       In this case, the matrix is arranged::</span>

<span class="sd">             A = [a_00 ... a_0n]</span>
<span class="sd">                 [a_10 ... a_1n]</span>
<span class="sd">                 [     ...     ]</span>
<span class="sd">                 [a_m0 ..  a_mn]</span>

<span class="sd">    Args:</span>
<span class="sd">        a: A bilinear form or a nested sequence of bilinear forms.</span>
<span class="sd">        kind: The PETSc matrix type (``MatType``).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A PETSc matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">form</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">form</span><span class="o">.</span><span class="n">_cpp_object</span> <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">arow</span><span class="p">]</span> <span class="k">for</span> <span class="n">arow</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="c1"># Create nest matrix with default types</span>
            <span class="k">return</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_matrix_nest</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># Single &#39;kind&#39; type</span>
                <span class="k">return</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_matrix_block</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Array of &#39;kind&#39; types</span>
                <span class="k">return</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_matrix_nest</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Single form</span>
        <span class="k">return</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_matrix</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span></div>



<span class="c1"># -- Vector assembly ------------------------------------------------------</span>


<div class="viewcode-block" id="assemble_vector">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.assemble_vector">[docs]</a>
<span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble_vector</span><span class="p">(</span>
    <span class="n">L</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">],</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble linear form(s) into a new PETSc vector.</span>

<span class="sd">    Three cases are supported:</span>

<span class="sd">    1. If ``L`` is a single linear form, the form is assembled into a</span>
<span class="sd">       ghosted PETSc vector.</span>

<span class="sd">    2. If ``L`` is a sequence of linear forms and ``kind`` is ``None``</span>
<span class="sd">       or is ``PETSc.Vec.Type.MPI``, the forms are assembled into a</span>
<span class="sd">       vector ``b`` such that ``b = [b_0, b_1, ..., b_n, b_0g, b_1g,</span>
<span class="sd">       ..., b_ng]`` where ``b_i`` are the entries associated with the</span>
<span class="sd">       &#39;owned&#39; degrees-of-freedom for ``L[i]`` and ``b_ig`` are the</span>
<span class="sd">       &#39;unowned&#39; (ghost) entries for ``L[i]``.</span>

<span class="sd">       For this case, the returned vector has an attribute ``_blocks``</span>
<span class="sd">       that holds the local offsets into ``b`` for the (i) owned and</span>
<span class="sd">       (ii) ghost entries for each ``L[i]``. See :func:`create_vector`</span>
<span class="sd">       for a description of the offset blocks.</span>

<span class="sd">    3. If ``L`` is a sequence of linear forms and ``kind`` is</span>
<span class="sd">       ``PETSc.Vec.Type.NEST``, the forms are assembled into a PETSc</span>
<span class="sd">       nested vector ``b`` (a nest of ghosted PETSc vectors) such that</span>
<span class="sd">       ``L[i]`` is assembled into into the ith nested matrix in ``b``.</span>

<span class="sd">    Constant and coefficient data that appear in the forms(s) can be</span>
<span class="sd">    packed outside of this function to avoid re-packing by this</span>
<span class="sd">    function. The functions :func:`dolfinx.fem.pack_constants` and</span>
<span class="sd">    :func:`dolfinx.fem.pack_coefficients` can be used to &#39;pre-pack&#39; the</span>
<span class="sd">    data.</span>

<span class="sd">    Note:</span>
<span class="sd">        The returned vector is not finalised, i.e. ghost values are not</span>
<span class="sd">        accumulated on the owning processes.</span>

<span class="sd">    Args:</span>
<span class="sd">        L: A linear form or sequence of linear forms.</span>
<span class="sd">        constants: Constants appearing in the form. For a single form,</span>
<span class="sd">            ``constants.ndim==1``. For multiple forms, the constants for</span>
<span class="sd">            form ``L[i]`` are  ``constants[i]``.</span>
<span class="sd">        coeffs: Coefficients appearing in the form. For a single form,</span>
<span class="sd">            ``coeffs.shape=(num_cells, n)``. For multiple forms, the</span>
<span class="sd">            coefficients for form ``L[i]`` are  ``coeffs[i]``.</span>
<span class="sd">        kind: PETSc vector type.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An assembled vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_zero_vector</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assemble_vector</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span></div>



<span class="nd">@assemble_vector</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">L</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">],</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble linear form(s) into a PETSc vector.</span>

<span class="sd">    The vector ``b`` must have been initialized with a size/layout that</span>
<span class="sd">    is consistent with the linear form. The vector ``b`` is normally</span>
<span class="sd">    created by :func:`create_vector`.</span>

<span class="sd">    Constants and coefficients that appear in the forms(s) can be passed</span>
<span class="sd">    to avoid re-computation of constants and coefficients. The functions</span>
<span class="sd">    :func:`dolfinx.fem.assemble.pack_constants` and</span>
<span class="sd">    :func:`dolfinx.fem.assemble.pack_coefficients` can be called.</span>

<span class="sd">    Note:</span>
<span class="sd">        The vector is not zeroed before assembly and it is not</span>
<span class="sd">        finalised, i.e. ghost values are not accumulated on the owning</span>
<span class="sd">        processes.</span>

<span class="sd">    Args:</span>
<span class="sd">        b: Vector to assemble the contribution of the linear form into.</span>
<span class="sd">        L: A linear form or sequence of linear forms to assemble into</span>
<span class="sd">            ``b``.</span>
<span class="sd">        constants: Constants appearing in the form. For a single form,</span>
<span class="sd">            ``constants.ndim==1``. For multiple forms, the constants for</span>
<span class="sd">            form ``L[i]`` are  ``constants[i]``.</span>
<span class="sd">        coeffs: Coefficients appearing in the form. For a single form,</span>
<span class="sd">            ``coeffs.shape=(num_cells, n)``. For multiple forms, the</span>
<span class="sd">            coefficients for form ``L[i]`` are  ``coeffs[i]``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Assembled vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide a sequence of forms when assembling a nest vector&quot;</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>  <span class="c1"># type: ignore[list-item]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>  <span class="c1"># type: ignore[list-item]</span>
        <span class="k">for</span> <span class="n">b_sub</span><span class="p">,</span> <span class="n">L_sub</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getNestSubVecs</span><span class="p">(),</span> <span class="n">L</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">b_sub</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">b_local</span><span class="p">:</span>
                <span class="n">_assemble_vector_array</span><span class="p">(</span><span class="n">b_local</span><span class="o">.</span><span class="n">array_w</span><span class="p">,</span> <span class="n">L_sub</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="n">pack_constants</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">pack_coefficients</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>
        <span class="n">offset0</span><span class="p">,</span> <span class="n">offset1</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s2">&quot;_blocks&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">b</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">b_l</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">L_</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">off0</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">offg0</span><span class="p">,</span> <span class="n">offg1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">offset0</span><span class="p">,</span> <span class="n">offset0</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">offset1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>
                <span class="n">bx_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">off1</span> <span class="o">-</span> <span class="n">off0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">offg1</span> <span class="o">-</span> <span class="n">offg0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">_assemble_vector_array</span><span class="p">(</span><span class="n">bx_</span><span class="p">,</span> <span class="n">L_</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">off1</span> <span class="o">-</span> <span class="n">off0</span>
                <span class="n">b_l</span><span class="o">.</span><span class="n">array_w</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bx_</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>
                <span class="n">b_l</span><span class="o">.</span><span class="n">array_w</span><span class="p">[</span><span class="n">offg0</span><span class="p">:</span><span class="n">offg1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bx_</span><span class="p">[</span><span class="n">size</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">b</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">b_local</span><span class="p">:</span>
            <span class="n">_assemble_vector_array</span><span class="p">(</span><span class="n">b_local</span><span class="o">.</span><span class="n">array_w</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="c1"># -- Matrix assembly ------------------------------------------------------</span>
<div class="viewcode-block" id="assemble_matrix">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.assemble_matrix">[docs]</a>
<span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble a bilinear form into a matrix.</span>

<span class="sd">    The following cases are supported:</span>

<span class="sd">    1. If ``a`` is a single bilinear form, the form is assembled</span>
<span class="sd">       into PETSc matrix of type ``kind``.</span>
<span class="sd">    #. If ``a`` is a :math:`m \\times n` rectangular array of forms the</span>
<span class="sd">       forms in ``a`` are assembled into a matrix such that::</span>

<span class="sd">            A = [A_00 ... A_0n]</span>
<span class="sd">                [A_10 ... A_1n]</span>
<span class="sd">                [     ...     ]</span>
<span class="sd">                [A_m0 ..  A_mn]</span>

<span class="sd">       where ``A_ij`` is the matrix associated with the form</span>
<span class="sd">       ``a[i][j]``.</span>

<span class="sd">       a. If ``kind`` is a ``PETSc.Mat.Type`` (other than</span>
<span class="sd">          ``PETSc.Mat.Type.NEST``) or is ``None``, the matrix type is</span>
<span class="sd">          ``kind`` of the default type (if ``kind`` is ``None``).</span>
<span class="sd">       #. If ``kind`` is ``PETSc.Mat.Type.NEST`` or a rectangular array</span>
<span class="sd">          of PETSc matrix types, the returned matrix has type</span>
<span class="sd">          ``PETSc.Mat.Type.NEST``.</span>

<span class="sd">    Rows/columns that are constrained by a Dirichlet boundary condition</span>
<span class="sd">    are zeroed, with the diagonal to set to ``diag``.</span>

<span class="sd">    Constant and coefficient data that appear in the forms(s) can be</span>
<span class="sd">    packed outside of this function to avoid re-packing by this</span>
<span class="sd">    function. The functions :func:`dolfinx.fem.pack_constants` and</span>
<span class="sd">    :func:`dolfinx.fem.pack_coefficients` can be used to &#39;pre-pack&#39; the</span>
<span class="sd">    data.</span>

<span class="sd">    Note:</span>
<span class="sd">        The returned matrix is not &#39;assembled&#39;, i.e. ghost contributions</span>
<span class="sd">        are not accumulated.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Bilinear form(s) to assembled into a matrix.</span>
<span class="sd">        bc: Dirichlet boundary conditions applied to the system.</span>
<span class="sd">        diag: Value to set on the matrix diagonal for Dirichlet</span>
<span class="sd">            boundary condition constrained degrees-of-freedom belonging</span>
<span class="sd">            to the same trial and test space.</span>
<span class="sd">        constants: Constants appearing the in the form.</span>
<span class="sd">        coeffs: Coefficients appearing the in the form.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Matrix representing the bilinear form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
    <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">return</span> <span class="n">A</span></div>



<span class="nd">@assemble_matrix</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble bilinear form into a matrix.</span>

<span class="sd">    The matrix vector ``A`` must have been initialized with a</span>
<span class="sd">    size/layout that is consistent with the bilinear form(s). The PETSc</span>
<span class="sd">    matrix ``A`` is normally created by :func:`create_matrix`.</span>

<span class="sd">    The returned matrix is not finalised, i.e. ghost values are not</span>
<span class="sd">    accumulated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide a sequence of forms when assembling a nest matrix&quot;</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_constants</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_coefficients</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a_row</span><span class="p">,</span> <span class="n">const_row</span><span class="p">,</span> <span class="n">coeff_row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">a_block</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a_row</span><span class="p">,</span> <span class="n">const_row</span><span class="p">,</span> <span class="n">coeff_row</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">a_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Asub</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNestSubMatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">Asub</span><span class="p">,</span> <span class="n">a_block</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
                        <span class="n">row_forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">row_form</span> <span class="k">for</span> <span class="n">row_form</span> <span class="ow">in</span> <span class="n">a_row</span> <span class="k">if</span> <span class="n">row_form</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_forms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">row_forms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">function_space</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Diagonal sub-block (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">) cannot be &#39;None&#39;&quot;</span>
                                <span class="s2">&quot; and have DirichletBC applied.&quot;</span>
                                <span class="s2">&quot; Consider assembling a zero block.&quot;</span>
                            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>  <span class="c1"># Blocked</span>
        <span class="n">consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_constants</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_coefficients</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">_extract_function_spaces</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># the check below is to ensure that a .dofmaps attribute is</span>
            <span class="c1"># available when creating is0 and is1 below</span>
            <span class="n">Vi</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Vi</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">Vsub</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">Vsub</span> <span class="ow">in</span> <span class="n">Vi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot have a entire {&#39;row&#39; if index == 0 else &#39;column&#39;} of a full of None&quot;</span>
                <span class="p">)</span>
        <span class="n">is0</span> <span class="o">=</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_index_sets</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">Vsub</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="n">Vsub</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map_bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">Vsub</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="p">)</span>
        <span class="n">is1</span> <span class="o">=</span> <span class="n">_cpp</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">create_index_sets</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">Vsub</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="n">Vsub</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map_bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">Vsub</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="p">)</span>

        <span class="n">_bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">_cpp_object</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">]</span> <span class="k">if</span> <span class="n">bcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a_sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a_sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Asub</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getLocalSubMatrix</span><span class="p">(</span><span class="n">is0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">is1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span>
                        <span class="n">Asub</span><span class="p">,</span>
                        <span class="n">a_sub</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span>
                        <span class="n">consts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>  <span class="c1"># type: ignore[index]</span>
                        <span class="n">_bcs</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">restoreLocalSubMatrix</span><span class="p">(</span><span class="n">is0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">is1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Asub</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">_bcs</span><span class="p">:</span>
                        <span class="n">row_forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">row_form</span> <span class="k">for</span> <span class="n">row_form</span> <span class="ow">in</span> <span class="n">a_row</span> <span class="k">if</span> <span class="n">row_form</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_forms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">row_forms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">function_space</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Diagonal sub-block (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">) cannot be &#39;None&#39; &quot;</span>
                                <span class="s2">&quot; and have DirichletBC applied.&quot;</span>
                                <span class="s2">&quot; Consider assembling a zero block.&quot;</span>
                            <span class="p">)</span>

        <span class="c1"># Flush to enable switch from add to set in the matrix</span>
        <span class="n">A</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">AssemblyType</span><span class="o">.</span><span class="n">FLUSH</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="c1"># Set diagonal</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a_sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a_sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Asub</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getLocalSubMatrix</span><span class="p">(</span><span class="n">is0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">is1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">a_sub</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">a_sub</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">insert_diagonal</span><span class="p">(</span><span class="n">Asub</span><span class="p">,</span> <span class="n">a_sub</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_bcs</span><span class="p">,</span> <span class="n">diag</span><span class="p">)</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">restoreLocalSubMatrix</span><span class="p">(</span><span class="n">is0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">is1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Asub</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Non-blocked</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="n">pack_constants</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">pack_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="n">_bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">_cpp_object</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">]</span> <span class="k">if</span> <span class="n">bcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">_bcs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">a</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">A</span><span class="o">.</span><span class="n">assemblyBegin</span><span class="p">(</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">AssemblyType</span><span class="o">.</span><span class="n">FLUSH</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">A</span><span class="o">.</span><span class="n">assemblyEnd</span><span class="p">(</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">AssemblyType</span><span class="o">.</span><span class="n">FLUSH</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">_cpp</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">insert_diagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_bcs</span><span class="p">,</span> <span class="n">diag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span>


<span class="c1"># -- Modifiers for Dirichlet conditions -----------------------------------</span>


<div class="viewcode-block" id="apply_lifting">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.apply_lifting">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_lifting</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">IntegralType</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]]</span>
        <span class="o">|</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Modify the right-hand side PETSc vector ``b`` to account for</span>
<span class="sd">    constraints (Dirichlet boundary conitions).</span>

<span class="sd">    See :func:`dolfinx.fem.apply_lifting` for a mathematical</span>
<span class="sd">    descriptions of the lifting operation.</span>

<span class="sd">    Args:</span>
<span class="sd">        b: Vector to modify in-place.</span>
<span class="sd">        a: List of bilinear forms. If ``b`` is not blocked or a nest,</span>
<span class="sd">            then ``a`` is a 1D sequence. If ``b`` is blocked or a nest,</span>
<span class="sd">            then ``a`` is  a 2D array of forms, with the ``a[i]`` forms</span>
<span class="sd">            used to modify the block/nest vector ``b[i]``.</span>
<span class="sd">        bcs: Boundary conditions to apply, which form a 2D array.</span>
<span class="sd">            If ``b`` is nested or blocked then ``bcs[i]`` are the</span>
<span class="sd">            boundary conditions to apply to block/nest ``i``.</span>
<span class="sd">            The function :func:`dolfinx.fem.bcs_by_block` can be</span>
<span class="sd">            used to prepare the 2D array of ``DirichletBC`` objects</span>
<span class="sd">            from the 2D sequence ``a``::</span>

<span class="sd">                bcs1 = fem.bcs_by_block(</span>
<span class="sd">                    fem.extract_function_spaces(a, 1),</span>
<span class="sd">                    bcs</span>
<span class="sd">                )</span>

<span class="sd">            If ``b`` is not blocked or nest, then ``len(bcs)`` must be</span>
<span class="sd">            equal to 1. The function :func:`dolfinx.fem.bcs_by_block`</span>
<span class="sd">            can be used to prepare the 2D array of ``DirichletBC``</span>
<span class="sd">            from the 1D sequence ``a``::</span>

<span class="sd">                bcs1 = fem.bcs_by_block(</span>
<span class="sd">                    fem.extract_function_spaces([a], 1),</span>
<span class="sd">                    bcs</span>
<span class="sd">                )</span>

<span class="sd">        x0: Vector to use in modify ``b`` (see</span>
<span class="sd">            :func:`dolfinx.fem.apply_lifting`). Treated as zero if</span>
<span class="sd">            ``None``.</span>
<span class="sd">        alpha: Scalar parameter in lifting (see</span>
<span class="sd">            :func:`dolfinx.fem.apply_lifting`).</span>
<span class="sd">        constants: Packed constant data appearing in the forms ``a``. If</span>
<span class="sd">            ``None``, the constant data will be packed by the function.</span>
<span class="sd">        coeffs: Packed coefficient data appearing in the forms ``a``. If</span>
<span class="sd">            ``None``, the coefficient data will be packed by the</span>
<span class="sd">            function.</span>

<span class="sd">    Note:</span>
<span class="sd">        Ghost contributions are not accumulated (not sent to owner).</span>
<span class="sd">        Caller is responsible for reverse-scatter to update the ghosts.</span>

<span class="sd">    Note:</span>
<span class="sd">        Boundary condition values are *not* set in ``b`` by this</span>
<span class="sd">        function. Use :func:`dolfinx.fem.DirichletBC.set` to set values</span>
<span class="sd">        in ``b``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span><span class="o">.</span><span class="n">getNestSubVecs</span><span class="p">()</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_constants</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_coefficients</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span> <span class="k">for</span> <span class="n">forms</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="k">for</span> <span class="n">b_sub</span><span class="p">,</span> <span class="n">a_sub</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getNestSubVecs</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="n">const_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined, call-overload]</span>
            <span class="p">)</span>
            <span class="n">apply_lifting</span><span class="p">(</span><span class="n">b_sub</span><span class="p">,</span> <span class="n">a_sub</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">const_</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s2">&quot;_blocks&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">offset0</span><span class="p">,</span> <span class="n">offset1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s2">&quot;_blocks&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="n">xl</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">localForm</span><span class="p">())</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="n">xlocal</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xl</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">],</span> <span class="n">xl</span><span class="p">[</span><span class="n">offg0</span><span class="p">:</span><span class="n">offg1</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">off0</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">offg0</span><span class="p">,</span> <span class="n">offg1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="n">offset0</span><span class="p">,</span> <span class="n">offset0</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">offset1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="p">)</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xlocal</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">offset0</span><span class="p">,</span> <span class="n">offset1</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s2">&quot;_blocks&quot;</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">b</span><span class="o">.</span><span class="n">localForm</span><span class="p">()</span> <span class="k">as</span> <span class="n">b_l</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a_</span><span class="p">,</span> <span class="n">off0</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">offg0</span><span class="p">,</span> <span class="n">offg1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset0</span><span class="p">,</span> <span class="n">offset0</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">offset1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="p">):</span>
                        <span class="n">const</span> <span class="o">=</span> <span class="n">pack_constants</span><span class="p">(</span><span class="n">a_</span><span class="p">)</span> <span class="k">if</span> <span class="n">constants</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># type: ignore[arg-type]</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">pack_coefficients</span><span class="p">(</span><span class="n">a_</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># type: ignore[arg-type, assignment, index]</span>
                        <span class="n">const_</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span>  <span class="c1"># type: ignore[attr-defined]</span>
                            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">const</span>
                        <span class="p">]</span>
                        <span class="n">bx_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">b_l</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">],</span> <span class="n">b_l</span><span class="p">[</span><span class="n">offg0</span><span class="p">:</span><span class="n">offg1</span><span class="p">]))</span>
                        <span class="n">_apply_lifting</span><span class="p">(</span><span class="n">bx_</span><span class="p">,</span> <span class="n">a_</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">xlocal</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">const_</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                        <span class="n">size</span> <span class="o">=</span> <span class="n">off1</span> <span class="o">-</span> <span class="n">off0</span>
                        <span class="n">b_l</span><span class="o">.</span><span class="n">array_w</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bx_</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>
                        <span class="n">b_l</span><span class="o">.</span><span class="n">array_w</span><span class="p">[</span><span class="n">offg0</span><span class="p">:</span><span class="n">offg1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bx_</span><span class="p">[</span><span class="n">size</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">localForm</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x0</span><span class="p">]</span>
                <span class="n">x0_r</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">array_r</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x0</span><span class="p">]</span>
                <span class="n">b_local</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">localForm</span><span class="p">())</span>
                <span class="n">_apply_lifting</span><span class="p">(</span><span class="n">b_local</span><span class="o">.</span><span class="n">array_w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">x0_r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="k">return</span> <span class="n">b</span></div>



<div class="viewcode-block" id="set_bc">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.set_bc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_bc</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]],</span>
    <span class="n">x0</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set constraint (Dirchlet boundary condition) values in an vector.</span>

<span class="sd">    For degrees-of-freedoms that are constrained by a Dirichlet boundary</span>
<span class="sd">    condition, this function sets that degrees-of-freedom to ``alpha *</span>
<span class="sd">    (g - x0)``, where ``g`` is the boundary condition value.</span>

<span class="sd">    Only owned entries in ``b`` (owned by the MPI process) are modified</span>
<span class="sd">    by this function.</span>

<span class="sd">    Args:</span>
<span class="sd">        b: Vector to modify by setting  boundary condition values.</span>
<span class="sd">        bcs: Boundary conditions to apply. If ``b`` is nested or</span>
<span class="sd">            blocked, ``bcs`` is a 2D array and ``bcs[i]`` are the</span>
<span class="sd">            boundary conditions to apply to block/nest ``i``. Otherwise</span>
<span class="sd">            ``bcs`` should be a sequence of ``DirichletBC``\s. For</span>
<span class="sd">            block/nest problems, :func:`dolfinx.fem.bcs_by_block` can be</span>
<span class="sd">            used to prepare the 2D array of ``DirichletBC`` objects.</span>
<span class="sd">        x0: Vector used in the value that constrained entries are set</span>
<span class="sd">            to. If ``None``, ``x0`` is treated as zero.</span>
<span class="sd">        alpha: Scalar value used in the value that constrained entries</span>
<span class="sd">            are set to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">array_r</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
            <span class="n">bc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array_w</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
    <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getNestSubVecs</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span><span class="o">.</span><span class="n">getNestSubVecs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">b_sub</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">x_sub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>  <span class="c1"># type: ignore[assignment, arg-type]</span>
            <span class="n">set_bc</span><span class="p">(</span><span class="n">b_sub</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">x_sub</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># block vector</span>
        <span class="n">offset0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="s2">&quot;_blocks&quot;</span><span class="p">)</span>
        <span class="n">b_array</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getArray</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x_array</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">getArray</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">off0</span><span class="p">,</span> <span class="n">off1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bcs</span><span class="p">,</span> <span class="n">offset0</span><span class="p">,</span> <span class="n">offset0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>  <span class="c1"># type: ignore[assignment]</span>
            <span class="n">x0_sub</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># type: ignore[index]</span>
            <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
                <span class="n">bc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">b_array</span><span class="p">[</span><span class="n">off0</span><span class="p">:</span><span class="n">off1</span><span class="p">],</span> <span class="n">x0_sub</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, union-attr]</span></div>



<span class="c1"># -- High-level interface for KSP ---------------------------------------</span>


<div class="viewcode-block" id="LinearProblem">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.LinearProblem">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearProblem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;High-level class for solving a linear variational problem using</span>
<span class="sd">    a PETSc KSP.</span>

<span class="sd">    Solves problems of the form</span>
<span class="sd">    :math:`a_{ij}(u, v) = f_i(v), i,j=0,\\ldots,N\\</span>
<span class="sd">    \\forall v \\in V` where</span>
<span class="sd">    :math:`u=(u_0,\\ldots,u_N), v=(v_0,\\ldots,v_N)`</span>
<span class="sd">    using PETSc KSP as the linear solver.</span>

<span class="sd">    Note:</span>
<span class="sd">        This high-level class automatically handles PETSc memory</span>
<span class="sd">        management. The user does not need to manually call</span>
<span class="sd">        ``.destroy()`` on returned PETSc objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">Form</span><span class="p">]],</span>
        <span class="n">L</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">Form</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">petsc_options_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">P</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">Form</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">petsc_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">form_compiler_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">jit_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">entity_maps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_EntityMap</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize solver for a linear variational problem.</span>

<span class="sd">        By default, the underlying KSP solver uses PETSc&#39;s default</span>
<span class="sd">        options, usually GMRES + ILU preconditioning. To use the robust</span>
<span class="sd">        combination of LU via MUMPS</span>

<span class="sd">        Example::</span>

<span class="sd">            problem = LinearProblem(a, L, bcs=[bc0, bc1],</span>
<span class="sd">                petsc_options_prefix=&quot;basic_linear_problem&quot;,</span>
<span class="sd">                petsc_options= {</span>
<span class="sd">                  &quot;ksp_type&quot;: &quot;preonly&quot;,</span>
<span class="sd">                  &quot;pc_type&quot;: &quot;lu&quot;,</span>
<span class="sd">                  &quot;pc_factor_mat_solver_type&quot;: &quot;mumps&quot;</span>
<span class="sd">            })</span>

<span class="sd">        This class also supports nested block-structured problems.</span>

<span class="sd">        Example::</span>

<span class="sd">            problem = LinearProblem([[a00, a01], [None, a11]], [L0, L1],</span>
<span class="sd">                bcs=[bc0, bc1], u=[uh0, uh1],</span>
<span class="sd">                kind=&quot;nest&quot;,</span>
<span class="sd">                petsc_options_prefix=&quot;nest_linear_problem&quot;)</span>

<span class="sd">        Every PETSc object created will have a unique options prefix set.</span>
<span class="sd">        We recommend discovering these prefixes dynamically via the</span>
<span class="sd">        petsc4py API rather than hard-coding each prefix value</span>
<span class="sd">        into the programme.</span>

<span class="sd">        Example::</span>

<span class="sd">            ksp_options_prefix = problem.solver.getOptionsPrefix()</span>
<span class="sd">            A_options_prefix = problem.A.getOptionsPrefix()</span>

<span class="sd">        Args:</span>
<span class="sd">            a: Bilinear UFL form or a nested sequence of bilinear</span>
<span class="sd">                forms, the left-hand side of the variational problem.</span>
<span class="sd">            L: Linear UFL form or a sequence of linear forms, the</span>
<span class="sd">                right-hand side of the variational problem.</span>
<span class="sd">            bcs: Sequence of Dirichlet boundary conditions to apply to</span>
<span class="sd">                 the variational problem and the preconditioner matrix.</span>
<span class="sd">            u: Solution function. It is created if not provided.</span>
<span class="sd">            P: Bilinear UFL form or a sequence of sequence of bilinear</span>
<span class="sd">                forms, used as a preconditioner.</span>
<span class="sd">            kind: The PETSc matrix and vector kind. Common choices</span>
<span class="sd">                are ``mpi`` and ``nest``. See</span>
<span class="sd">                :func:`dolfinx.fem.petsc.create_matrix` and</span>
<span class="sd">                :func:`dolfinx.fem.petsc.create_vector` for more</span>
<span class="sd">                information.</span>
<span class="sd">            petsc_options_prefix: Mandatory named argument. Options prefix</span>
<span class="sd">                used as root prefix on all internally created PETSc</span>
<span class="sd">                objects. Typically ends with ``_``. Must be the same on</span>
<span class="sd">                all ranks, and is usually unique within the programme.</span>
<span class="sd">            petsc_options: Options set on the underlying PETSc KSP only.</span>
<span class="sd">                The options must be the same on all ranks. For available</span>
<span class="sd">                choices for the ``petsc_options`` kwarg, see the `PETSc KSP</span>
<span class="sd">                documentation</span>
<span class="sd">                &lt;https://petsc4py.readthedocs.io/en/stable/manual/ksp/&gt;`_.</span>
<span class="sd">                Options on other objects (matrices, vectors) should be set</span>
<span class="sd">                explicitly by the user.</span>
<span class="sd">            form_compiler_options: Options used in FFCx compilation of</span>
<span class="sd">                all forms. Run ``ffcx --help`` at the commandline to see</span>
<span class="sd">                all available options.</span>
<span class="sd">            jit_options: Options used in CFFI JIT compilation of C</span>
<span class="sd">                code generated by FFCx. See ``python/dolfinx/jit.py`` for</span>
<span class="sd">                all available options. Takes priority over all other</span>
<span class="sd">                option values.</span>
<span class="sd">            entity_maps: If any trial functions, test functions, or</span>
<span class="sd">                coefficients in the form are not defined over the same mesh</span>
<span class="sd">                as the integration domain, a corresponding :class:</span>
<span class="sd">                `EntityMap&lt;dolfinx.mesh.EntityMap&gt;` must be provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">a</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
            <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
            <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_L</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">L</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
            <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
            <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">P</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
            <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
            <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">create_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># For nest matrices kind can be a nested list.</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;nest&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span> <span class="k">else</span> <span class="n">kind</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Extract function space for unknown from the right hand</span>
            <span class="c1"># side of the equation.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Function</span><span class="p">(</span><span class="n">Li</span><span class="o">.</span><span class="n">arguments</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">())</span> <span class="k">for</span> <span class="n">Li</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">_Function</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">arguments</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">bcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bcs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">KSP</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">petsc_options_prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PETSc options prefix cannot be empty.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_petsc_options_prefix</span> <span class="o">=</span> <span class="n">petsc_options_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="n">petsc_options_prefix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">A_&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">b_&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">x_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">P_mat_&quot;</span><span class="p">)</span>

        <span class="c1"># Set options on KSP only</span>
        <span class="k">if</span> <span class="n">petsc_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">prefixPush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">getOptionsPrefix</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">petsc_options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">opts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setFromOptions</span><span class="p">()</span>

            <span class="c1"># Tidy up global options</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">petsc_options</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">opts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">opts</span><span class="o">.</span><span class="n">prefixPop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;nest&quot;</span><span class="p">:</span>
            <span class="c1"># Transfer nest IS on self.A to PC of main KSP. This allows</span>
            <span class="c1"># fieldsplit preconditioning to be applied, if desired.</span>
            <span class="n">nest_IS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">getNestISs</span><span class="p">()</span>
            <span class="n">fieldsplit_IS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s1">&#39;f&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">IS</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">IS</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">nest_IS</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">getPC</span><span class="p">()</span><span class="o">.</span><span class="n">setFieldSplitIS</span><span class="p">(</span><span class="o">*</span><span class="n">fieldsplit_IS</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_solver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>

<div class="viewcode-block" id="LinearProblem.solve">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.LinearProblem.solve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve the problem.</span>

<span class="sd">        This method updates the solution ``u`` function(s) stored in the</span>
<span class="sd">        problem instance.</span>

<span class="sd">        Note:</span>
<span class="sd">            The user is responsible for asserting convergence of the KSP</span>
<span class="sd">            solver e.g. ``problem.solver.getConvergedReason() &gt; 0``.</span>
<span class="sd">            Alternatively, pass ``&quot;ksp_error_if_not_converged&quot; : True`` in</span>
<span class="sd">            ``petsc_options`` to raise a ``PETScError`` on failure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The solution function(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Assemble lhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
        <span class="n">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, misc]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>

        <span class="c1"># Assemble preconditioner</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
            <span class="n">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preconditioner</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, misc]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>

        <span class="c1"># Assemble rhs</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_zero_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">assemble_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="c1"># Apply boundary conditions to the rhs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>  <span class="c1"># block or nest</span>
                <span class="n">bcs1</span> <span class="o">=</span> <span class="n">_bcs_by_block</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">apply_lifting</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs1</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                    <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="p">)</span>
                <span class="n">bcs0</span> <span class="o">=</span> <span class="n">_bcs_by_block</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">set_bc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">bcs0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># single form</span>
                <span class="n">apply_lifting</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">])</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                    <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">:</span>
                    <span class="n">bc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">array_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="c1"># Solve linear system and update ghost values in the solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled linear form representing the left-hand side.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled bilinear form representing the right-hand side.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled bilinear form representing the preconditioner.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Left-hand side matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">P_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preconditioner matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right-hand side vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solution vector.</span>

<span class="sd">        Note:</span>
<span class="sd">            The vector does not share memory with the solution</span>
<span class="sd">            function(s) ``u``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">KSP</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The PETSc KSP solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solution function(s).</span>

<span class="sd">        Note:</span>
<span class="sd">            The function(s) do not share memory with the solution</span>
<span class="sd">            vector ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span></div>



<span class="c1"># -- High-level interface for SNES ---------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_assign_block_data</span><span class="p">(</span><span class="n">forms</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">],</span> <span class="n">vec</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">):</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign block data to a PETSc vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        forms: List of forms to extract block data from.</span>
<span class="sd">        vec: PETSc vector to assign block data to.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">maps</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span>
            <span class="n">form</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">form</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dofmaps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_map_bs</span><span class="p">,</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_assign_block_data</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>


<div class="viewcode-block" id="assemble_residual">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.assemble_residual">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble_residual</span><span class="p">(</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">],</span>
    <span class="n">residual</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">],</span>
    <span class="n">jacobian</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">],</span>
    <span class="n">_snes</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">SNES</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the residual at ``x`` into the vector ``b``.</span>

<span class="sd">    A function conforming to the interface expected by ``SNES.setFunction``</span>
<span class="sd">    can be created by fixing the first four arguments, e.g.:</span>

<span class="sd">    Example::</span>

<span class="sd">        snes = PETSc.SNES().create(mesh.comm)</span>
<span class="sd">        assemble_residual = functools.partial(</span>
<span class="sd">            dolfinx.fem.petsc.assemble_residual,</span>
<span class="sd">            u, residual, jacobian, bcs)</span>
<span class="sd">        snes.setFunction(assemble_residual, b)</span>

<span class="sd">    Args:</span>
<span class="sd">        u: Function(s) tied to the solution vector within the residual and</span>
<span class="sd">           Jacobian.</span>
<span class="sd">        residual: Form of the residual. It can be a sequence of forms.</span>
<span class="sd">        jacobian: Form of the Jacobian. It can be a nested sequence of</span>
<span class="sd">            forms.</span>
<span class="sd">        bcs: List of Dirichlet boundary conditions to lift the residual.</span>
<span class="sd">        _snes: The solver instance.</span>
<span class="sd">        x: The vector containing the point to evaluate the residual at.</span>
<span class="sd">        b: Vector to assemble the residual into.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Update input vector before assigning</span>
    <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>

    <span class="c1"># Assign the input vector to the unknowns</span>
    <span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="c1"># Assign block data if block assembly is requested</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">_assign_block_data</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">_assign_block_data</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Assemble the residual</span>
    <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_zero_vector</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">assemble_vector</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">residual</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

    <span class="c1"># Lift vector</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="c1"># Nest and blocked lifting</span>
        <span class="n">bcs1</span> <span class="o">=</span> <span class="n">_bcs_by_block</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="n">apply_lifting</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs1</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">bcs0</span> <span class="o">=</span> <span class="n">_bcs_by_block</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="n">residual</span><span class="p">),</span> <span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="n">set_bc</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bcs0</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Single form lifting</span>
        <span class="n">apply_lifting</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">jacobian</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bcs</span><span class="p">],</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">set_bc</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span></div>



<div class="viewcode-block" id="assemble_jacobian">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.assemble_jacobian">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble_jacobian</span><span class="p">(</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]</span> <span class="o">|</span> <span class="n">_Function</span><span class="p">,</span>
    <span class="n">jacobian</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]],</span>
    <span class="n">preconditioner</span><span class="p">:</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">],</span>
    <span class="n">_snes</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">SNES</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">J</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
    <span class="n">P_mat</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the Jacobian and preconditioner matrices at ``x``</span>
<span class="sd">    into ``J`` and ``P_mat``.</span>

<span class="sd">    A function conforming to the interface expected by ``SNES.setJacobian``</span>
<span class="sd">    can be created by fixing the first four arguments e.g.:</span>

<span class="sd">    Example::</span>

<span class="sd">        snes = PETSc.SNES().create(mesh.comm)</span>
<span class="sd">        assemble_jacobian = functools.partial(</span>
<span class="sd">            dolfinx.fem.petsc.assemble_jacobian,</span>
<span class="sd">            u, jacobian, preconditioner, bcs)</span>
<span class="sd">        snes.setJacobian(assemble_jacobian, A, P_mat)</span>

<span class="sd">    Args:</span>
<span class="sd">        u: Function tied to the solution vector within the residual and</span>
<span class="sd">            jacobian.</span>
<span class="sd">        jacobian: Compiled form of the Jacobian.</span>
<span class="sd">        preconditioner: Compiled form of the preconditioner.</span>
<span class="sd">        bcs: List of Dirichlet boundary conditions to apply to the Jacobian</span>
<span class="sd">             and preconditioner matrices.</span>
<span class="sd">        _snes: The solver instance.</span>
<span class="sd">        x: The vector containing the point to evaluate at.</span>
<span class="sd">        J: Matrix to assemble the Jacobian into.</span>
<span class="sd">        P_mat: Matrix to assemble the preconditioner into.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy existing soultion into the function used in the residual and</span>
    <span class="c1"># Jacobian</span>
    <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
    <span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="c1"># Assemble Jacobian</span>
    <span class="n">J</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
    <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, misc]</span>
    <span class="n">J</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">preconditioner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">P_mat</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
        <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">P_mat</span><span class="p">,</span> <span class="n">preconditioner</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, misc]</span>
        <span class="n">P_mat</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span></div>



<div class="viewcode-block" id="NonlinearProblem">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NonlinearProblem">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NonlinearProblem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;High-level class for solving nonlinear variational problems</span>
<span class="sd">    with PETSc SNES.</span>

<span class="sd">    Solves problems of the form</span>
<span class="sd">    :math:`F_i(u, v) = 0, i=0,\\ldots,N\\ \\forall v \\in V` where</span>
<span class="sd">    :math:`u=(u_0,\\ldots,u_N), v=(v_0,\\ldots,v_N)` using PETSc</span>
<span class="sd">    SNES as the non-linear solver.</span>

<span class="sd">    Note:</span>
<span class="sd">        The deprecated version of this class for use with</span>
<span class="sd">        :class:`dolfinx.nls.petsc.NewtonSolver` has been renamed</span>
<span class="sd">        :class:`dolfinx.fem.petsc.NewtonSolverNonlinearProblem`.</span>

<span class="sd">    Note:</span>
<span class="sd">        This high-level class automatically handles PETSc memory</span>
<span class="sd">        management. The user does not need to manually call</span>
<span class="sd">        ``.destroy()`` on returned PETSc objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">F</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span><span class="p">],</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">petsc_options_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">J</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">P</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">petsc_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">form_compiler_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">jit_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">entity_maps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_EntityMap</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize solver for a nonlinear variational problem.</span>

<span class="sd">        By default, the underlying SNES solver uses PETSc&#39;s default</span>
<span class="sd">        options. To use the robust combination of LU via MUMPS with</span>
<span class="sd">        a backtracking linesearch, pass:</span>

<span class="sd">        Example::</span>

<span class="sd">            petsc_options = {&quot;ksp_type&quot;: &quot;preonly&quot;,</span>
<span class="sd">                             &quot;pc_type&quot;: &quot;lu&quot;,</span>
<span class="sd">                             &quot;pc_factor_mat_solver_type&quot;: &quot;mumps&quot;,</span>
<span class="sd">                             &quot;snes_linesearch_type&quot;: &quot;bt&quot;,</span>
<span class="sd">            }</span>

<span class="sd">        Every PETSc object will have a unique options prefix set. We</span>
<span class="sd">        recommend discovering these prefixes dynamically via the</span>
<span class="sd">        petsc4py API rather than hard-coding each prefix value into</span>
<span class="sd">        the programme.</span>

<span class="sd">        Example::</span>

<span class="sd">            snes_options_prefix = problem.solver.getOptionsPrefix()</span>
<span class="sd">            jacobian_options_prefix = problem.A.getOptionsPrefix()</span>

<span class="sd">        Args:</span>
<span class="sd">            F: UFL form(s) representing the residual :math:`F_i`.</span>
<span class="sd">            u: Function(s) used to define the residual and Jacobian.</span>
<span class="sd">            bcs: Dirichlet boundary conditions.</span>
<span class="sd">            J: UFL form(s) representing the Jacobian</span>
<span class="sd">                :math:`J_{ij} = dF_i/du_j`. If not passed, derived</span>
<span class="sd">                automatically.</span>
<span class="sd">            P: UFL form(s) representing the preconditioner.</span>
<span class="sd">            kind: The PETSc matrix and vector kind. Common choices</span>
<span class="sd">                are ``mpi`` and ``nest``. See</span>
<span class="sd">                :func:`dolfinx.fem.petsc.create_matrix` and</span>
<span class="sd">                :func:`dolfinx.fem.petsc.create_vector` for more</span>
<span class="sd">                information.</span>
<span class="sd">            petsc_options_prefix: Mandatory named argument.</span>
<span class="sd">                Options prefix used as root prefix on all</span>
<span class="sd">                internally created PETSc objects. Typically ends with `_`.</span>
<span class="sd">                Must be the same on all ranks, and is usually unique within</span>
<span class="sd">                the programme.</span>
<span class="sd">            petsc_options: Options set on the underlying PETSc SNES only.</span>
<span class="sd">                The options must be the same on all ranks. For available</span>
<span class="sd">                choices for ``petsc_options``, see the</span>
<span class="sd">                `PETSc SNES documentation</span>
<span class="sd">                &lt;https://petsc4py.readthedocs.io/en/stable/manual/snes/&gt;`_.</span>
<span class="sd">                Options on other objects (matrices, vectors) should be set</span>
<span class="sd">                explicitly by the user.</span>
<span class="sd">            form_compiler_options: Options used in FFCx compilation of all</span>
<span class="sd">                forms. Run ``ffcx --help`` at the command line to see all</span>
<span class="sd">                available options.</span>
<span class="sd">            jit_options: Options used in CFFI JIT compilation of C code</span>
<span class="sd">                generated by FFCx. See ``python/dolfinx/jit.py`` for all</span>
<span class="sd">                available options. Takes priority over all other option</span>
<span class="sd">                values.</span>
<span class="sd">            entity_maps: If any trial functions, test functions, or</span>
<span class="sd">                coefficients in the form are not defined over the same mesh</span>
<span class="sd">                as the integration domain, a corresponding :class:</span>
<span class="sd">                `EntityMap&lt;dolfinx.mesh.EntityMap&gt;` must be provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compile residual and Jacobian forms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_F</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">F</span><span class="p">,</span>
            <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
            <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
            <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">J</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">derivative_block</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_J</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">J</span><span class="p">,</span>
            <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
            <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
            <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
                <span class="n">P</span><span class="p">,</span>
                <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span>
                <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span><span class="p">,</span>
                <span class="n">entity_maps</span><span class="o">=</span><span class="n">entity_maps</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="c1"># Set default values if not supplied</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">bcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bcs</span>

        <span class="c1"># Create PETSc structures for the residual, Jacobian and solution</span>
        <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="c1"># Create PETSc structure for preconditioner if provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span> <span class="o">=</span> <span class="n">create_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Determine the vector kind based on the matrix type</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;nest&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">NEST</span> <span class="k">else</span> <span class="n">kind</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">create_vector</span><span class="p">(</span><span class="n">_extract_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Create the SNES solver and attach the corresponding Jacobian and</span>
        <span class="c1"># residual computation functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snes</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">SNES</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setJacobian</span><span class="p">(</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">assemble_jacobian</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preconditioner</span><span class="p">,</span> <span class="n">bcs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setFunction</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">assemble_residual</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">bcs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">petsc_options_prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PETSc options prefix cannot be empty.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="n">petsc_options_prefix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">A_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">P_mat_&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">b_&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">setOptionsPrefix</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">petsc_options_prefix</span><span class="si">}</span><span class="s2">x_&quot;</span><span class="p">)</span>

        <span class="c1"># Set options for SNES only</span>
        <span class="k">if</span> <span class="n">petsc_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">prefixPush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">getOptionsPrefix</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">petsc_options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">opts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">setFromOptions</span><span class="p">()</span>

            <span class="c1"># Tidy up global options</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">petsc_options</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">opts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">opts</span><span class="o">.</span><span class="n">prefixPop</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;nest&quot;</span><span class="p">:</span>
            <span class="c1"># Transfer nest IS on self.P_mat to PC of main KSP. This allows</span>
            <span class="c1"># fieldsplit preconditioning to be applied, if desired.</span>
            <span class="n">nest_IS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_mat</span><span class="o">.</span><span class="n">getNestISs</span><span class="p">()</span>
            <span class="n">fieldsplit_IS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s1">&#39;f&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">IS</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">IS</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">nest_IS</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">getKSP</span><span class="p">()</span><span class="o">.</span><span class="n">getPC</span><span class="p">()</span><span class="o">.</span><span class="n">setFieldSplitIS</span><span class="p">(</span><span class="o">*</span><span class="n">fieldsplit_IS</span><span class="p">)</span>

<div class="viewcode-block" id="NonlinearProblem.solve">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NonlinearProblem.solve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve the problem.</span>

<span class="sd">        This method updates the solution ``u`` function(s) stored in the</span>
<span class="sd">        problem instance.</span>

<span class="sd">        Note:</span>
<span class="sd">            The user is responsible for asserting convergence of the SNES</span>
<span class="sd">            solver e.g. ``assert problem.solver.getConvergedReason() &gt; 0``.</span>
<span class="sd">            Alternatively, pass ``&quot;snes_error_if_not_converged&quot;: True`` and</span>
<span class="sd">            ``&quot;ksp_error_if_not_converged&quot; : True`` in ``petsc_options`` to</span>
<span class="sd">            raise a ``PETScError`` on failure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The solution function(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy current iterate into the work array.</span>
        <span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Solve problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_ghost_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="c1"># Copy solution back to function</span>
        <span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_snes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled residual.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_F</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">J</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled Jacobian.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_J</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Form</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled preconditioner.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preconditioner</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Jacobian matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">P_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preconditioner matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Residual vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solution vector.</span>

<span class="sd">        Note:</span>
<span class="sd">            The vector does not share memory with the</span>
<span class="sd">            solution function(s) ``u``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">SNES</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The SNES solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solution function(s).</span>

<span class="sd">        Note:</span>
<span class="sd">            The function(s) do not share memory with the solution</span>
<span class="sd">            vector ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span></div>



<span class="c1"># -- Deprecated non-linear problem class for NewtonSolver -----------------</span>


<div class="viewcode-block" id="NewtonSolverNonlinearProblem">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NewtonSolverNonlinearProblem">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NewtonSolverNonlinearProblem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;(Deprecated) Nonlinear problem class for solving nonlinear</span>
<span class="sd">    problems using :class:`dolfinx.nls.petsc.NewtonSolver`.</span>

<span class="sd">    Solves problems of the form :math:`F(u, v) = 0 \\ \\forall v \\in V`</span>
<span class="sd">    using PETSc as the linear algebra backend.</span>

<span class="sd">    Note:</span>
<span class="sd">        This class is deprecated in favour of</span>
<span class="sd">        :class:`dolfinx.fem.petsc.NonlinearProblem`, a high level</span>
<span class="sd">        interface to SNES.</span>

<span class="sd">    Note:</span>
<span class="sd">        This class was previously called</span>
<span class="sd">        ``dolfinx.fem.petsc.NonlinearProblem``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">F</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">_Function</span><span class="p">,</span>
        <span class="n">bcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DirichletBC</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">J</span><span class="p">:</span> <span class="n">ufl</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">Form</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">form_compiler_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">jit_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize solver for solving a non-linear problem using</span>
<span class="sd">        Newton&#39;s method`.</span>

<span class="sd">        Args:</span>
<span class="sd">            F: The PDE residual F(u, v).</span>
<span class="sd">            u: The unknown.</span>
<span class="sd">            bcs: List of Dirichlet boundary conditions.</span>
<span class="sd">            J: UFL representation of the Jacobian (optional)</span>
<span class="sd">            form_compiler_options: Options used in FFCx</span>
<span class="sd">                compilation of this form. Run ``ffcx --help`` at the</span>
<span class="sd">                command line to see all available options.</span>
<span class="sd">            jit_options: Options used in CFFI JIT compilation of C</span>
<span class="sd">                code generated by FFCx. See ``python/dolfinx/jit.py``</span>
<span class="sd">                for all available options. Takes priority over all other</span>
<span class="sd">                option values.</span>

<span class="sd">        Example::</span>

<span class="sd">            problem = NonlinearProblem(F, u, [bc0, bc1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;dolfinx.nls.petsc.NewtonSolver is deprecated. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Use dolfinx.fem.petsc.NonlinearProblem, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;a high level interface to PETSc SNES, instead.&quot;</span>
            <span class="p">),</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_L</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">F</span><span class="p">,</span> <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span> <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span>
        <span class="p">)</span>

        <span class="c1"># Create the Jacobian matrix, dF/du</span>
        <span class="k">if</span> <span class="n">J</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span>
            <span class="n">du</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">_create_form</span><span class="p">(</span>
            <span class="n">J</span><span class="p">,</span> <span class="n">form_compiler_options</span><span class="o">=</span><span class="n">form_compiler_options</span><span class="p">,</span> <span class="n">jit_options</span><span class="o">=</span><span class="n">jit_options</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="o">=</span> <span class="n">bcs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled linear form (the residual form).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Form</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The compiled bilinear form (the Jacobian form).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>

<div class="viewcode-block" id="NewtonSolverNonlinearProblem.form">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NewtonSolverNonlinearProblem.form">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is called before the residual or Jacobian is</span>
<span class="sd">        computed. This is usually used to update ghost values.</span>

<span class="sd">        Args:</span>
<span class="sd">           x: The vector containing the latest solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="o">.</span><span class="n">ghostUpdate</span><span class="p">(</span><span class="n">addv</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">INSERT</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span></div>


<div class="viewcode-block" id="NewtonSolverNonlinearProblem.F">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NewtonSolverNonlinearProblem.F">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble the residual F into the vector b.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The vector containing the latest solution</span>
<span class="sd">            b: Vector to assemble the residual into</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the residual vector</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">_zero_vector</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">assemble_vector</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">)</span>

        <span class="c1"># Apply boundary condition</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">apply_lifting</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">],</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">],</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">ghostUpdate</span><span class="p">(</span><span class="n">addv</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="n">set_bc</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">ghostUpdate</span><span class="p">(</span><span class="n">addv</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">InsertMode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">PETSc</span><span class="o">.</span><span class="n">ScatterMode</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span></div>


<div class="viewcode-block" id="NewtonSolverNonlinearProblem.J">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.NewtonSolverNonlinearProblem.J">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble the Jacobian matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The vector containing the latest solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
        <span class="n">assemble_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="n">A</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span></div>
</div>



<span class="c1"># -- Additional free helper functions (interpolations, assignments etc.) --</span>


<div class="viewcode-block" id="discrete_curl">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.discrete_curl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">discrete_curl</span><span class="p">(</span><span class="n">space0</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">,</span> <span class="n">space1</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble a discrete curl operator.</span>

<span class="sd">    Args:</span>
<span class="sd">        space0: H1 space to interpolate the gradient from.</span>
<span class="sd">        space1: H(curl) space to interpolate into.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Discrete curl operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_discrete_curl</span><span class="p">(</span><span class="n">space0</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span> <span class="n">space1</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">)</span></div>



<div class="viewcode-block" id="discrete_gradient">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.discrete_gradient">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">discrete_gradient</span><span class="p">(</span><span class="n">space0</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">,</span> <span class="n">space1</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble a discrete gradient operator.</span>

<span class="sd">    The discrete gradient operator interpolates the gradient of a H1</span>
<span class="sd">    finite element function into a H(curl) space. It is assumed that the</span>
<span class="sd">    H1 space uses an identity map and the H(curl) space uses a covariant</span>
<span class="sd">    Piola map.</span>

<span class="sd">    Args:</span>
<span class="sd">        space0: H1 space to interpolate the gradient from.</span>
<span class="sd">        space1: H(curl) space to interpolate into.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Discrete gradient operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_discrete_gradient</span><span class="p">(</span><span class="n">space0</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span> <span class="n">space1</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">)</span></div>



<div class="viewcode-block" id="interpolation_matrix">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.interpolation_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolation_matrix</span><span class="p">(</span><span class="n">V0</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">,</span> <span class="n">V1</span><span class="p">:</span> <span class="n">_FunctionSpace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">:</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Assemble an interpolation operator matrix for discreye</span>
<span class="sd">    interpolation between finite element spaces.</span>

<span class="sd">    Consider is the vector of degrees-of-freedom  :math:`u_{i}`</span>
<span class="sd">    associated with a function in :math:`V_{i}`. This function returns</span>
<span class="sd">    the matrix :math:`\Pi` sucht that</span>

<span class="sd">    .. math::</span>

<span class="sd">        u_{1} = \Pi u_{0}.</span>

<span class="sd">    Args:</span>
<span class="sd">        V0: Space to interpolate from.</span>
<span class="sd">        V1: Space to interpolate into.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The interpolation matrix :math:`\Pi`.</span>

<span class="sd">    Note:</span>
<span class="sd">        The returned matrix is not finalised, i.e. ghost values are not</span>
<span class="sd">        accumulated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_interpolation_matrix</span><span class="p">(</span><span class="n">V0</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">,</span> <span class="n">V1</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">)</span></div>



<div class="viewcode-block" id="assign">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.assign">[docs]</a>
<span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">assign</span><span class="p">(</span><span class="n">u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">):</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign :class:`Function` degrees-of-freedom to a vector.</span>

<span class="sd">    Assigns degree-of-freedom values in ``u``, which is possibly a</span>
<span class="sd">    sequence of ``Function``s, to ``x``. When ``u`` is a sequence of</span>
<span class="sd">    ``Function``s, degrees-of-freedom for the ``Function``s in ``u`` are</span>
<span class="sd">    &#39;stacked&#39; and assigned to ``x``. See :func:`assign` for</span>
<span class="sd">    documentation on how stacked assignment is handled.</span>

<span class="sd">    Args:</span>
<span class="sd">        u: ``Function`` (s) to assign degree-of-freedom value from.</span>
<span class="sd">        x: Vector to assign degree-of-freedom values in ``u`` to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="p">()</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">bs</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">index_map</span><span class="o">.</span><span class="n">size_local</span>
                <span class="n">data0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span> <span class="n">bs</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span>
                <span class="n">data1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">bs</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:])</span>
            <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">data0</span> <span class="o">+</span> <span class="n">data1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>



<span class="nd">@assign</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">_Function</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_Function</span><span class="p">]):</span>  <span class="c1"># type: ignore[name-defined]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign vector entries to :class:`Function` degrees-of-freedom.</span>

<span class="sd">    Assigns values in ``x`` to the degrees-of-freedom of ``u``, which is</span>
<span class="sd">    possibly a Sequence of ``Function``s. When ``u`` is a Sequence of</span>
<span class="sd">    ``Function``s, values in ``x`` are assigned block-wise to the</span>
<span class="sd">    ``Function``s. See :func:`assign` for documentation on how blocked</span>
<span class="sd">    assignment is handled.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Vector with values to assign values from.</span>
<span class="sd">        u: ``Function`` (s) to assign degree-of-freedom values to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="o">.</span><span class="n">Type</span><span class="p">()</span><span class="o">.</span><span class="n">NEST</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">bs</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">index_map</span><span class="o">.</span><span class="n">size_local</span>
                <span class="n">data0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span> <span class="n">bs</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span>
                <span class="n">data1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">bs</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:])</span>
            <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data0</span> <span class="o">+</span> <span class="n">data1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dolfinx</span><span class="o">.</span><span class="n">la</span><span class="o">.</span><span class="n">petsc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_petsc_lib</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the full path of the PETSc shared library.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Full path to the PETSc shared library.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If PETSc library cannot be found for if more than</span>
<span class="sd">            one library is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_petsc4py</span>

    <span class="n">petsc_dir</span> <span class="o">=</span> <span class="n">_petsc4py</span><span class="o">.</span><span class="n">get_config</span><span class="p">()[</span><span class="s2">&quot;PETSC_DIR&quot;</span><span class="p">]</span>
    <span class="n">petsc_arch</span> <span class="o">=</span> <span class="n">_petsc4py</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">getPathArchPETSc</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">candidate_paths</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">petsc_dir</span><span class="p">,</span> <span class="n">petsc_arch</span><span class="p">,</span> <span class="s2">&quot;lib&quot;</span><span class="p">,</span> <span class="s2">&quot;libpetsc.so&quot;</span><span class="p">),</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">petsc_dir</span><span class="p">,</span> <span class="n">petsc_arch</span><span class="p">,</span> <span class="s2">&quot;lib&quot;</span><span class="p">,</span> <span class="s2">&quot;libpetsc.dylib&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">exists_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">candidate_path</span> <span class="ow">in</span> <span class="n">candidate_paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">candidate_path</span><span class="p">):</span>
            <span class="n">exists_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exists_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Could not find a PETSc shared library. Candidate paths: </span><span class="si">{</span><span class="n">candidate_paths</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">exists_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one PETSc shared library found. Paths: </span><span class="si">{</span><span class="n">exists_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">exists_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<div class="viewcode-block" id="numba_utils">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.numba_utils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">numba_utils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility attributes for working with Numba and PETSc.</span>

<span class="sd">    These attributes are convenience functions for calling PETSc C</span>
<span class="sd">    functions from within Numba functions.</span>

<span class="sd">    Note:</span>
<span class="sd">        `Numba &lt;https://numba.pydata.org/&gt;`_ must be available</span>
<span class="sd">        to use these utilities.</span>

<span class="sd">    Examples:</span>
<span class="sd">        A typical use of these utility functions is::</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            import numpy.typing as npt</span>
<span class="sd">            def set_vals(A: int,</span>
<span class="sd">                         m: int, rows: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         n: int, cols: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         data: npt.NDArray[PETSc.ScalarTYpe], mode: int):</span>
<span class="sd">                MatSetValuesLocal(A, m, rows.ctypes, n, cols.ctypes,</span>
<span class="sd">                                  data.ctypes, mode)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">petsc4py.PETSc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_PETSc</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">llvmlite</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_llvmlite</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_numba</span>

        <span class="n">_llvmlite</span><span class="o">.</span><span class="n">binding</span><span class="o">.</span><span class="n">load_library_permanently</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">get_petsc_lib</span><span class="p">()))</span>

        <span class="n">_int</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">IntType</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">_scalar</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">_real</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">RealType</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">_int_ptr</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">_int</span><span class="p">)</span>
        <span class="n">_scalar_ptr</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">_scalar</span><span class="p">)</span>
        <span class="n">_MatSetValues_sig</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span>
            <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
            <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">uintp</span><span class="p">,</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_int_ptr</span><span class="p">,</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_int_ptr</span><span class="p">,</span>
            <span class="n">_scalar_ptr</span><span class="p">,</span>
            <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">MatSetValuesLocal</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ExternalFunction</span><span class="p">(</span>
            <span class="s2">&quot;MatSetValuesLocal&quot;</span><span class="p">,</span> <span class="n">_MatSetValues_sig</span>
        <span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>

        <span class="n">MatSetValuesBlockedLocal</span> <span class="o">=</span> <span class="n">_numba</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ExternalFunction</span><span class="p">(</span>
            <span class="s2">&quot;MatSetValuesBlockedLocal&quot;</span><span class="p">,</span> <span class="n">_MatSetValues_sig</span>
        <span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesBlockedLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesBlockedLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="ctypes_utils">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.ctypes_utils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ctypes_utils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility attributes for working with ctypes and PETSc.</span>

<span class="sd">    These attributes are convenience functions for calling PETSc C</span>
<span class="sd">    functions, typically from within Numba functions.</span>

<span class="sd">    Examples:</span>
<span class="sd">        A typical use of these utility functions is::</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            import numpy.typing as npt</span>
<span class="sd">            def set_vals(A: int,</span>
<span class="sd">                         m: int, rows: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         n: int, cols: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         data: npt.NDArray[PETSc.ScalarTYpe], mode: int):</span>
<span class="sd">                MatSetValuesLocal(A, m, rows.ctypes, n, cols.ctypes,</span>
<span class="sd">                                  data.ctypes, mode)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">petsc4py.PETSc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_PETSc</span>

        <span class="n">_lib_ctypes</span> <span class="o">=</span> <span class="n">_ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">get_petsc_lib</span><span class="p">()))</span>

        <span class="c1"># Note: ctypes does not have complex types, hence we use void* for</span>
        <span class="c1"># scalar data</span>
        <span class="n">_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_ctypes_type</span><span class="p">(</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">IntType</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">MatSetValuesLocal</span> <span class="o">=</span> <span class="n">_lib_ctypes</span><span class="o">.</span><span class="n">MatSetValuesLocal</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>
        <span class="n">MatSetValuesLocal</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">_int</span><span class="p">),</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">_int</span><span class="p">),</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">MatSetValuesBlockedLocal</span> <span class="o">=</span> <span class="n">_lib_ctypes</span><span class="o">.</span><span class="n">MatSetValuesBlockedLocal</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesBlockedLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesBlockedLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>
        <span class="n">MatSetValuesBlockedLocal</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">_int</span><span class="p">),</span>
            <span class="n">_int</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">_int</span><span class="p">),</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span>
            <span class="n">_ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="cffi_utils">
<a class="viewcode-back" href="../../../generated/dolfinx.fem.petsc.html#dolfinx.fem.petsc.cffi_utils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">cffi_utils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility attributes for working with CFFI (ABI mode) and Numba.</span>

<span class="sd">    Registers Numba&#39;s complex types with CFFI.</span>

<span class="sd">    If PETSc is available, CFFI convenience functions for calling PETSc C</span>
<span class="sd">    functions are also created. These are typically called from within</span>
<span class="sd">    Numba functions.</span>

<span class="sd">    Note:</span>
<span class="sd">        `CFFI &lt;https://cffi.readthedocs.io/&gt;`_ and  `Numba</span>
<span class="sd">        &lt;https://numba.pydata.org/&gt;`_ must be available to use these</span>
<span class="sd">        utilities.</span>

<span class="sd">    Examples:</span>
<span class="sd">        A typical use of these utility functions is::</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            import numpy.typing as npt</span>
<span class="sd">            def set_vals(A: int,</span>
<span class="sd">                         m: int, rows: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         n: int, cols: npt.NDArray[PETSc.IntType],</span>
<span class="sd">                         data: npt.NDArray[PETSc.ScalarType], mode: int):</span>
<span class="sd">                MatSetValuesLocal(A, m, ffi.from_buffer(rows), n,</span>
<span class="sd">                                  ffi.from_buffer(cols),</span>
<span class="sd">                                  ffi.from_buffer(rows(data), mode)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">cffi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_cffi</span>

    <span class="n">_ffi</span> <span class="o">=</span> <span class="n">_cffi</span><span class="o">.</span><span class="n">FFI</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_numba</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numba.core.typing.cffi_utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_cffi_support</span>

        <span class="c1"># Register complex types</span>
        <span class="n">_cffi_support</span><span class="o">.</span><span class="n">register_type</span><span class="p">(</span><span class="n">_ffi</span><span class="o">.</span><span class="n">typeof</span><span class="p">(</span><span class="s2">&quot;float _Complex&quot;</span><span class="p">),</span> <span class="n">_numba</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="n">_cffi_support</span><span class="o">.</span><span class="n">register_type</span><span class="p">(</span><span class="n">_ffi</span><span class="o">.</span><span class="n">typeof</span><span class="p">(</span><span class="s2">&quot;double _Complex&quot;</span><span class="p">),</span> <span class="n">_numba</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">LogLevel</span><span class="p">,</span> <span class="n">log</span>

        <span class="n">log</span><span class="p">(</span>
            <span class="n">LogLevel</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
            <span class="s2">&quot;Could not import numba, so cffi/numba complex types were not registered.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">PETSc</span> <span class="k">as</span> <span class="n">_PETSc</span>

        <span class="n">_lib_cffi</span> <span class="o">=</span> <span class="n">_ffi</span><span class="o">.</span><span class="n">dlopen</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">get_petsc_lib</span><span class="p">()))</span>

        <span class="n">_CTYPES</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span> <span class="s2">&quot;float _Complex&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">:</span> <span class="s2">&quot;double _Complex&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">longlong</span><span class="p">:</span> <span class="s2">&quot;long long&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">_c_int_t</span> <span class="o">=</span> <span class="n">_CTYPES</span><span class="p">[</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">IntType</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">_c_scalar_t</span> <span class="o">=</span> <span class="n">_CTYPES</span><span class="p">[</span><span class="n">_PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">_ffi</span><span class="o">.</span><span class="n">cdef</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                int MatSetValuesLocal(void* mat, </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2"> nrow, const </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2">* irow,</span>
<span class="s2">                                    </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2"> ncol, const </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2">* icol,</span>
<span class="s2">                                    const </span><span class="si">{</span><span class="n">_c_scalar_t</span><span class="si">}</span><span class="s2">* y, int addv);</span>
<span class="s2">                int MatSetValuesBlockedLocal(void* mat, </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2"> nrow, const </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2">* irow,</span>
<span class="s2">                                    </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2"> ncol, const </span><span class="si">{</span><span class="n">_c_int_t</span><span class="si">}</span><span class="s2">* icol,</span>
<span class="s2">                                    const </span><span class="si">{</span><span class="n">_c_scalar_t</span><span class="si">}</span><span class="s2">* y, int addv);</span>
<span class="s2">                                    &quot;&quot;&quot;</span>
        <span class="p">)</span>

        <span class="n">MatSetValuesLocal</span> <span class="o">=</span> <span class="n">_lib_cffi</span><span class="o">.</span><span class="n">MatSetValuesLocal</span>  <span class="c1"># type: ignore[attr-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>

        <span class="n">MatSetValuesBlockedLocal</span> <span class="o">=</span> <span class="n">_lib_cffi</span><span class="o">.</span><span class="n">MatSetValuesBlockedLocal</span>  <span class="c1"># type: ignore[attr-defined]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See PETSc `MatSetValuesBlockedLocal</span>
<span class="sd">        &lt;https://petsc.org/release/manualpages/Mat/MatSetValuesBlockedLocal&gt;`_</span>
<span class="sd">        documentation.&quot;&quot;&quot;</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">LogLevel</span><span class="p">,</span> <span class="n">log</span>

        <span class="n">log</span><span class="p">(</span>
            <span class="n">LogLevel</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
            <span class="s2">&quot;Could not import petsc4py, so cffi/PETSc ABI mode interface was not created.&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, FEniCS Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFIN-X: dolfinx::fem Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFIN-X
   </div>
   <div id="projectbrief">DOLFIN-X C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dolfinx</b></li><li class="navelem"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dolfinx::fem Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Finite element method functionality.  
<a href="../../d8/dbf/namespacedolfinx_1_1fem.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild.html">sparsitybuild</a></td></tr>
<tr class="memdesc:db/dcc/namespacedolfinx_1_1fem_1_1sparsitybuild"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to build sparsity patterns from degree-of-freedom maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant value which can be attached to a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a>. Constants may be scalar (rank 0), vector (rank 1), or tensor valued.  <a href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">CoordinateElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages coordinate mappings for isoparametric cells.  <a href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for setting (strong) Dirichlet boundary conditions.  <a href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d41/classdolfinx_1_1fem_1_1DiscreteOperators.html">DiscreteOperators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete gradient operators providing derivatives of functions.  <a href="../../d4/d41/classdolfinx_1_1fem_1_1DiscreteOperators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree-of-freedom map.  <a href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh entity. This class also handles sub-space dofs, which are views into the parent dofs.  <a href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell. This class closely follows the concept of a UFC <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html" title="Represents a mathematical expression evaluated at a pre-defined set of points on the reference cell....">Expression</a>.  <a href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html">FiniteElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite Element, containing the dof layout on a reference element, and various methods for evaluating and transforming the basis.  <a href="../../df/d27/classdolfinx_1_1fem_1_1FiniteElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for variational forms.  <a href="../../df/d02/classdolfinx_1_1fem_1_1Form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a function \( u_h \) in a finite element function space \( V_h \), given by.  <a href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a finite element function space defined by a mesh, a finite element, and a local-to-global map of the degrees of freedom (dofmap).  <a href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d48/classdolfinx_1_1fem_1_1ReferenceCellGeometry.html">ReferenceCellGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulates the vertex positions for the reference cell.  <a href="../../de/d48/classdolfinx_1_1fem_1_1ReferenceCellGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afc30329eb0140cb5f16d715fa4eedd76"><td class="memItemLeft" align="right" valign="top"><a id="afc30329eb0140cb5f16d715fa4eedd76"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a> : std::int8_t { <b>cell</b> = 0, 
<b>exterior_facet</b> = 1, 
<b>interior_facet</b> = 2, 
<b>vertex</b> = 3
 }</td></tr>
<tr class="memdesc:afc30329eb0140cb5f16d715fa4eedd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of integral. <br /></td></tr>
<tr class="separator:afc30329eb0140cb5f16d715fa4eedd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a1bf9501710367c63159980f429bda3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a1bf9501710367c63159980f429bda3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a1bf9501710367c63159980f429bda3">assemble_scalar</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a7a1bf9501710367c63159980f429bda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble functional into scalar. Caller is responsible for accumulation across processes.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a7a1bf9501710367c63159980f429bda3">More...</a><br /></td></tr>
<tr class="separator:a7a1bf9501710367c63159980f429bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbb2bf558822ad0e8b12e0a998b341c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefbb2bf558822ad0e8b12e0a998b341c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aefbb2bf558822ad0e8b12e0a998b341c">assemble_vector</a> (Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt; b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;L)</td></tr>
<tr class="memdesc:aefbb2bf558822ad0e8b12e0a998b341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into an Eigen vector.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aefbb2bf558822ad0e8b12e0a998b341c">More...</a><br /></td></tr>
<tr class="separator:aefbb2bf558822ad0e8b12e0a998b341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5eb7874066177b1a7d3531431a0e88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d5eb7874066177b1a7d3531431a0e88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6d5eb7874066177b1a7d3531431a0e88">apply_lifting</a> (Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; Eigen::Ref&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt;&gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a6d5eb7874066177b1a7d3531431a0e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6d5eb7874066177b1a7d3531431a0e88">More...</a><br /></td></tr>
<tr class="separator:a6d5eb7874066177b1a7d3531431a0e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3a1fadafb513e38d9176835746c6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60d3a1fadafb513e38d9176835746c6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60d3a1fadafb513e38d9176835746c6b">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs)</td></tr>
<tr class="memdesc:a60d3a1fadafb513e38d9176835746c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a60d3a1fadafb513e38d9176835746c6b">More...</a><br /></td></tr>
<tr class="separator:a60d3a1fadafb513e38d9176835746c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf99ae072832072ed604cae6520c1e78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf99ae072832072ed604cae6520c1e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#abf99ae072832072ed604cae6520c1e78">assemble_matrix</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a, const std::vector&lt; bool &gt; &amp;dof_marker0, const std::vector&lt; bool &gt; &amp;dof_marker1)</td></tr>
<tr class="memdesc:abf99ae072832072ed604cae6520c1e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#abf99ae072832072ed604cae6520c1e78">More...</a><br /></td></tr>
<tr class="separator:abf99ae072832072ed604cae6520c1e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fe28ab22e0501f9b45a81383879c53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64fe28ab22e0501f9b45a81383879c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a64fe28ab22e0501f9b45a81383879c53">add_diagonal</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const Eigen::Ref&lt; const Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;&gt; &amp;rows, T diagonal=1.0)</td></tr>
<tr class="memdesc:a64fe28ab22e0501f9b45a81383879c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value to the diagonal of a matrix for specified rows. It is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a64fe28ab22e0501f9b45a81383879c53">More...</a><br /></td></tr>
<tr class="separator:a64fe28ab22e0501f9b45a81383879c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175f0a078c133bae316835934d6cf09f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a175f0a078c133bae316835934d6cf09f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a175f0a078c133bae316835934d6cf09f">add_diagonal</a> (const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;mat_add, const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, T diagonal=1.0)</td></tr>
<tr class="memdesc:a175f0a078c133bae316835934d6cf09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a175f0a078c133bae316835934d6cf09f">More...</a><br /></td></tr>
<tr class="separator:a175f0a078c133bae316835934d6cf09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709c20a980dbc395f014a4c99e0da149"><td class="memTemplParams" colspan="2"><a id="a709c20a980dbc395f014a4c99e0da149"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a709c20a980dbc395f014a4c99e0da149"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a709c20a980dbc395f014a4c99e0da149">set_bc</a> (Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, const Eigen::Ref&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt; &amp;x0, double scale=1.0)</td></tr>
<tr class="memdesc:a709c20a980dbc395f014a4c99e0da149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the PETScVector, multiplied by 'scale'. The vectors b and x0 must have the same local size. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a709c20a980dbc395f014a4c99e0da149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee394668e6948abdda2f736278351304"><td class="memTemplParams" colspan="2"><a id="aee394668e6948abdda2f736278351304"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee394668e6948abdda2f736278351304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aee394668e6948abdda2f736278351304">set_bc</a> (Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt; b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs, double scale=1.0)</td></tr>
<tr class="memdesc:aee394668e6948abdda2f736278351304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the PETScVector, multiplied by 'scale'. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:aee394668e6948abdda2f736278351304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a9cbb3ea5b561750d327b15ae44e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a850a9cbb3ea5b561750d327b15ae44e7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a850a9cbb3ea5b561750d327b15ae44e7">bcs_rows</a> (const std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; * &gt; &amp;L, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs)</td></tr>
<tr class="memdesc:a850a9cbb3ea5b561750d327b15ae44e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange boundary conditions by block.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a850a9cbb3ea5b561750d327b15ae44e7">More...</a><br /></td></tr>
<tr class="separator:a850a9cbb3ea5b561750d327b15ae44e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f856e311a91eab169aa08cc5af4ef18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f856e311a91eab169aa08cc5af4ef18"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt; T &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8f856e311a91eab169aa08cc5af4ef18">bcs_cols</a> (const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt;&gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;bcs)</td></tr>
<tr class="memdesc:a8f856e311a91eab169aa08cc5af4ef18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange boundary conditions by block.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8f856e311a91eab169aa08cc5af4ef18">More...</a><br /></td></tr>
<tr class="separator:a8f856e311a91eab169aa08cc5af4ef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d40a08055994ab2d379e39ee4793a3"><td class="memItemLeft" align="right" valign="top">std::array&lt; Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a01d40a08055994ab2d379e39ee4793a3">locate_dofs_topological</a> (const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;V, const int dim, const Eigen::Ref&lt; const Eigen::ArrayXi &gt; &amp;entities, bool remote=true)</td></tr>
<tr class="memdesc:a01d40a08055994ab2d379e39ee4793a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a01d40a08055994ab2d379e39ee4793a3">More...</a><br /></td></tr>
<tr class="separator:a01d40a08055994ab2d379e39ee4793a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32154e731dd2a9838c312f4ea914cba9"><td class="memItemLeft" align="right" valign="top">Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a32154e731dd2a9838c312f4ea914cba9">locate_dofs_topological</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, const int dim, const Eigen::Ref&lt; const Eigen::ArrayXi &gt; &amp;entities, bool remote=true)</td></tr>
<tr class="memdesc:a32154e731dd2a9838c312f4ea914cba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a32154e731dd2a9838c312f4ea914cba9">More...</a><br /></td></tr>
<tr class="separator:a32154e731dd2a9838c312f4ea914cba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070e597fd9233679d78d299615922e5"><td class="memItemLeft" align="right" valign="top">std::array&lt; Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5070e597fd9233679d78d299615922e5">locate_dofs_geometrical</a> (const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;V, const std::function&lt; Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;marker_fn)</td></tr>
<tr class="memdesc:a5070e597fd9233679d78d299615922e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds degrees of freedom whose geometric coordinate is true for the provided marking function.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5070e597fd9233679d78d299615922e5">More...</a><br /></td></tr>
<tr class="separator:a5070e597fd9233679d78d299615922e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791dfb702c5fd1876bc2bef141146c0"><td class="memItemLeft" align="right" valign="top">Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9791dfb702c5fd1876bc2bef141146c0">locate_dofs_geometrical</a> (const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;V, const std::function&lt; Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;marker_fn)</td></tr>
<tr class="memdesc:a9791dfb702c5fd1876bc2bef141146c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds degrees of freedom whose geometric coordinate is true for the provided marking function.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a9791dfb702c5fd1876bc2bef141146c0">More...</a><br /></td></tr>
<tr class="separator:a9791dfb702c5fd1876bc2bef141146c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4e47c2e856ec9b2d43e8a386a0ff61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ade4e47c2e856ec9b2d43e8a386a0ff61">transpose_dofmap</a> (<a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;dofmap, std::int32_t num_cells)</td></tr>
<tr class="memdesc:ade4e47c2e856ec9b2d43e8a386a0ff61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ade4e47c2e856ec9b2d43e8a386a0ff61">More...</a><br /></td></tr>
<tr class="separator:ade4e47c2e856ec9b2d43e8a386a0ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4686b146b3274c580b056a947ecb1ca4"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a4686b146b3274c580b056a947ecb1ca4">build_dofmap_data</a> (MPI_Comm comm, const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;element_dof_layout)</td></tr>
<tr class="memdesc:a4686b146b3274c580b056a947ecb1ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build dofmap data for an element on a mesh topology.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a4686b146b3274c580b056a947ecb1ca4">More...</a><br /></td></tr>
<tr class="separator:a4686b146b3274c580b056a947ecb1ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4704c14b27bf55e6660ef92042427d"><td class="memItemLeft" align="right" valign="top">Eigen::Array&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a4d4704c14b27bf55e6660ef92042427d">compute_dof_permutations</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;dof_layout)</td></tr>
<tr class="memdesc:a4d4704c14b27bf55e6660ef92042427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dof permutations for all cells. Each row contains the numbers from 0 to (number of dofs on reference - 1) permuted so that edges are oriented towards the higher global vertex index.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a4d4704c14b27bf55e6660ef92042427d">More...</a><br /></td></tr>
<tr class="separator:a4d4704c14b27bf55e6660ef92042427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fce6fd18d359bf2f67f71ac952b8e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5fce6fd18d359bf2f67f71ac952b8e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ae5fce6fd18d359bf2f67f71ac952b8e0">eval</a> (Eigen::Ref&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; values, const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T &gt; &amp;e, const std::vector&lt; std::int32_t &gt; &amp;active_cells)</td></tr>
<tr class="memdesc:ae5fce6fd18d359bf2f67f71ac952b8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a UFC expression.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ae5fce6fd18d359bf2f67f71ac952b8e0">More...</a><br /></td></tr>
<tr class="separator:ae5fce6fd18d359bf2f67f71ac952b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt; &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa3f56a7d7c65eb949973e8d75ae0c57b">common_function_spaces</a> (const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt;, 2 &gt;&gt;&gt; &amp;V)</td></tr>
<tr class="memdesc:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa3f56a7d7c65eb949973e8d75ae0c57b">More...</a><br /></td></tr>
<tr class="separator:aa3f56a7d7c65eb949973e8d75ae0c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab586fb783800561657947349543c7b97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab586fb783800561657947349543c7b97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab586fb783800561657947349543c7b97">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ab586fb783800561657947349543c7b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> (on possibly non-matching meshes)  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab586fb783800561657947349543c7b97">More...</a><br /></td></tr>
<tr class="separator:ab586fb783800561657947349543c7b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077eac3332276aa981e35f96f1d92b49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a077eac3332276aa981e35f96f1d92b49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a077eac3332276aa981e35f96f1d92b49">interpolate</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const std::function&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;f)</td></tr>
<tr class="memdesc:a077eac3332276aa981e35f96f1d92b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an expression.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a077eac3332276aa981e35f96f1d92b49">More...</a><br /></td></tr>
<tr class="separator:a077eac3332276aa981e35f96f1d92b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a081146d5dc1472f5cdf36f556a793"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1a081146d5dc1472f5cdf36f556a793"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab1a081146d5dc1472f5cdf36f556a793">interpolate_c</a> (<a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;u, const std::function&lt; void(Eigen::Ref&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt;, const Eigen::Ref&lt; const Eigen::Array&lt; double, Eigen::Dynamic, 3, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;f)</td></tr>
<tr class="memdesc:ab1a081146d5dc1472f5cdf36f556a793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate an expression f(x). This interface uses an expression function f that has an in/out argument for the expression values. It is primarily to support C code implementations of the expression, e.g. using Numba. Generally the interface where the expression function is a pure function, i.e. the expression values are the return argument, should be preferred.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab1a081146d5dc1472f5cdf36f556a793">More...</a><br /></td></tr>
<tr class="separator:ab1a081146d5dc1472f5cdf36f556a793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84a7f13165718f74b1c3640434f8ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dfa/classdolfinx_1_1la_1_1PETScMatrix.html">la::PETScMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af84a7f13165718f74b1c3640434f8ad3">create_matrix</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;a, const std::string &amp;type=std::string())</td></tr>
<tr class="memdesc:af84a7f13165718f74b1c3640434f8ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#af84a7f13165718f74b1c3640434f8ad3">More...</a><br /></td></tr>
<tr class="separator:af84a7f13165718f74b1c3640434f8ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1425519f27729ce63733de1b531148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dfa/classdolfinx_1_1la_1_1PETScMatrix.html">la::PETScMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6d1425519f27729ce63733de1b531148">create_matrix_block</a> (const Eigen::Ref&lt; const Eigen::Array&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; *, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;a, const std::string &amp;type=std::string())</td></tr>
<tr class="memdesc:a6d1425519f27729ce63733de1b531148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a monolithic matrix for an array of bilinear forms.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6d1425519f27729ce63733de1b531148">More...</a><br /></td></tr>
<tr class="separator:a6d1425519f27729ce63733de1b531148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c38c143a4f7d3af772780d573b61daa"><td class="memItemLeft" align="right" valign="top"><a id="a2c38c143a4f7d3af772780d573b61daa"></a>
<a class="el" href="../../d5/dfa/classdolfinx_1_1la_1_1PETScMatrix.html">la::PETScMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2c38c143a4f7d3af772780d573b61daa">create_matrix_nest</a> (const Eigen::Ref&lt; const Eigen::Array&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; *, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;types)</td></tr>
<tr class="memdesc:a2c38c143a4f7d3af772780d573b61daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create nested (MatNest) matrix. <br /></td></tr>
<tr class="separator:a2c38c143a4f7d3af772780d573b61daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b8f143e58a86f49a34e76e52b66d4"><td class="memItemLeft" align="right" valign="top"><a id="a2c5b8f143e58a86f49a34e76e52b66d4"></a>
<a class="el" href="../../d0/da6/classdolfinx_1_1la_1_1PETScVector.html">la::PETScVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a2c5b8f143e58a86f49a34e76e52b66d4">create_vector_block</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:a2c5b8f143e58a86f49a34e76e52b66d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise monolithic vector. Vector is not zeroed. <br /></td></tr>
<tr class="separator:a2c5b8f143e58a86f49a34e76e52b66d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace74e5d1c7503e13156f787d7a6c8482"><td class="memItemLeft" align="right" valign="top"><a id="ace74e5d1c7503e13156f787d7a6c8482"></a>
<a class="el" href="../../d0/da6/classdolfinx_1_1la_1_1PETScVector.html">la::PETScVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ace74e5d1c7503e13156f787d7a6c8482">create_vector_nest</a> (const std::vector&lt; std::pair&lt; std::reference_wrapper&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int &gt;&gt; &amp;maps)</td></tr>
<tr class="memdesc:ace74e5d1c7503e13156f787d7a6c8482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create nested (VecNest) vector. Vector is not zeroed. <br /></td></tr>
<tr class="separator:ace74e5d1c7503e13156f787d7a6c8482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3244047c43f91367032ec2568c613dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3244047c43f91367032ec2568c613dd3">assemble_vector_petsc</a> (Vec b, const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;L)</td></tr>
<tr class="memdesc:a3244047c43f91367032ec2568c613dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a3244047c43f91367032ec2568c613dd3">More...</a><br /></td></tr>
<tr class="separator:a3244047c43f91367032ec2568c613dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8057875ef52f435031ee4b338923be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8e8057875ef52f435031ee4b338923be">apply_lifting_petsc</a> (Vec b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;a, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;bcs1, const std::vector&lt; Vec &gt; &amp;x0, double scale)</td></tr>
<tr class="memdesc:a8e8057875ef52f435031ee4b338923be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify b such that:  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a8e8057875ef52f435031ee4b338923be">More...</a><br /></td></tr>
<tr class="separator:a8e8057875ef52f435031ee4b338923be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="memItemLeft" align="right" valign="top"><a id="a73dd695c33e25c38ded0c8664a2f4d8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a73dd695c33e25c38ded0c8664a2f4d8c">set_bc_petsc</a> (Vec b, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt; &amp;bcs, const Vec x0, double scale=1.0)</td></tr>
<tr class="memdesc:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc values in owned (local) part of the PETScVector, multiplied by 'scale'. The vectors b and x0 must have the same local size. The bcs should be on (sub-)spaces of the form L that b represents. <br /></td></tr>
<tr class="separator:a73dd695c33e25c38ded0c8664a2f4d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453c186ac134116bbcb3a266ee8ddd82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a453c186ac134116bbcb3a266ee8ddd82"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a453c186ac134116bbcb3a266ee8ddd82">extract_function_spaces</a> (const Eigen::Ref&lt; const Eigen::Array&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; T &gt; *, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;a)</td></tr>
<tr class="memdesc:a453c186ac134116bbcb3a266ee8ddd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a453c186ac134116bbcb3a266ee8ddd82">More...</a><br /></td></tr>
<tr class="separator:a453c186ac134116bbcb3a266ee8ddd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefced23767b97f6cc040b07627f9522"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afefced23767b97f6cc040b07627f9522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afefced23767b97f6cc040b07627f9522">create_sparsity_pattern</a> (const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:afefced23767b97f6cc040b07627f9522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#afefced23767b97f6cc040b07627f9522">More...</a><br /></td></tr>
<tr class="separator:afefced23767b97f6cc040b07627f9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400279d9a8403a2acc8cc4e55bfd9d19"><td class="memItemLeft" align="right" valign="top"><a id="a400279d9a8403a2acc8cc4e55bfd9d19"></a>
<a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a400279d9a8403a2acc8cc4e55bfd9d19">create_sparsity_pattern</a> (const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology, const std::array&lt; const <a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a> *, 2 &gt; &amp;dofmaps, const std::set&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a> &gt; &amp;integrals)</td></tr>
<tr class="memdesc:a400279d9a8403a2acc8cc4e55bfd9d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. <br /></td></tr>
<tr class="separator:a400279d9a8403a2acc8cc4e55bfd9d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a036e445b82a114f05794c73203953e"><td class="memItemLeft" align="right" valign="top"><a id="a5a036e445b82a114f05794c73203953e"></a>
<a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a5a036e445b82a114f05794c73203953e">create_element_dof_layout</a> (const ufc_dofmap &amp;dofmap, const <a class="el" href="../../dd/d7d/namespacedolfinx_1_1mesh.html#a9e741697bed34b75e9564e99feac4367">mesh::CellType</a> cell_type, const std::vector&lt; int &gt; &amp;parent_map={})</td></tr>
<tr class="memdesc:a5a036e445b82a114f05794c73203953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html" title="The class represents the degree-of-freedom (dofs) for an element. Dofs are associated with a mesh ent...">ElementDofLayout</a> from a ufc_dofmap. <br /></td></tr>
<tr class="separator:a5a036e445b82a114f05794c73203953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96266b91a3df6e8b072f40155c45a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">DofMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa96266b91a3df6e8b072f40155c45a86">create_dofmap</a> (MPI_Comm comm, const ufc_dofmap &amp;dofmap, <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;topology)</td></tr>
<tr class="memdesc:aa96266b91a3df6e8b072f40155c45a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create dof map on mesh from a ufc_dofmap.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aa96266b91a3df6e8b072f40155c45a86">More...</a><br /></td></tr>
<tr class="separator:aa96266b91a3df6e8b072f40155c45a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1922184233dd7810487d11b7a8a041b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad1922184233dd7810487d11b7a8a041b">get_coefficient_names</a> (const ufc_form &amp;ufc_form)</td></tr>
<tr class="memdesc:ad1922184233dd7810487d11b7a8a041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each coefficient in a UFC form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad1922184233dd7810487d11b7a8a041b">More...</a><br /></td></tr>
<tr class="separator:ad1922184233dd7810487d11b7a8a041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aeef8c5d7afb948b36c9c3e73bdf0d57c">get_constant_names</a> (const ufc_form &amp;ufc_form)</td></tr>
<tr class="memdesc:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of each constant in a UFC form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aeef8c5d7afb948b36c9c3e73bdf0d57c">More...</a><br /></td></tr>
<tr class="separator:aeef8c5d7afb948b36c9c3e73bdf0d57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e81a6709aca5199ecc943520543b80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52e81a6709aca5199ecc943520543b80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a52e81a6709aca5199ecc943520543b80">create_form</a> (const ufc_form &amp;ufc_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:a52e81a6709aca5199ecc943520543b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a52e81a6709aca5199ecc943520543b80">More...</a><br /></td></tr>
<tr class="separator:a52e81a6709aca5199ecc943520543b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#aee048b92a2f1d3ab229f04a1e1adad98">create_form</a> (const ufc_form &amp;ufc_form, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:aee048b92a2f1d3ab229f04a1e1adad98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#aee048b92a2f1d3ab229f04a1e1adad98">More...</a><br /></td></tr>
<tr class="separator:aee048b92a2f1d3ab229f04a1e1adad98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534371b86f32e225d84540bc39b2ee36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a534371b86f32e225d84540bc39b2ee36"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a534371b86f32e225d84540bc39b2ee36">create_form</a> (ufc_form *(*fptr)(), const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;spaces, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;coefficients, const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;constants, const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;subdomains, const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;mesh=nullptr)</td></tr>
<tr class="memdesc:a534371b86f32e225d84540bc39b2ee36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> using a factory function that returns a pointer to a ufc_form.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a534371b86f32e225d84540bc39b2ee36">More...</a><br /></td></tr>
<tr class="separator:a534371b86f32e225d84540bc39b2ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a2f617d1ec2975eb41dd2bd24f19cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#af3a2f617d1ec2975eb41dd2bd24f19cc">create_coordinate_map</a> (const ufc_coordinate_mapping &amp;ufc_cmap)</td></tr>
<tr class="memdesc:af3a2f617d1ec2975eb41dd2bd24f19cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html" title="This class manages coordinate mappings for isoparametric cells.">CoordinateElement</a> from ufc.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#af3a2f617d1ec2975eb41dd2bd24f19cc">More...</a><br /></td></tr>
<tr class="separator:af3a2f617d1ec2975eb41dd2bd24f19cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad054263045b42a9fb5438f4ecea9a999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad054263045b42a9fb5438f4ecea9a999">create_coordinate_map</a> (ufc_coordinate_mapping *(*fptr)())</td></tr>
<tr class="memdesc:ad054263045b42a9fb5438f4ecea9a999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html" title="This class manages coordinate mappings for isoparametric cells.">CoordinateElement</a> from ufc.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#ad054263045b42a9fb5438f4ecea9a999">More...</a><br /></td></tr>
<tr class="separator:ad054263045b42a9fb5438f4ecea9a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6945e14af84d7cfa415a09fb09ce59e8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6945e14af84d7cfa415a09fb09ce59e8">create_functionspace</a> (ufc_function_space *(*fptr)(const char *), const std::string function_name, std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; mesh)</td></tr>
<tr class="memdesc:a6945e14af84d7cfa415a09fb09ce59e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC.  <a href="../../d8/dbf/namespacedolfinx_1_1fem.html#a6945e14af84d7cfa415a09fb09ce59e8">More...</a><br /></td></tr>
<tr class="separator:a6945e14af84d7cfa415a09fb09ce59e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72fd82b0e57a041f34bab1f6aa9d7ca"><td class="memTemplParams" colspan="2"><a id="ab72fd82b0e57a041f34bab1f6aa9d7ca"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab72fd82b0e57a041f34bab1f6aa9d7ca"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Array&lt; typename U::scalar_type, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#ab72fd82b0e57a041f34bab1f6aa9d7ca">pack_coefficients</a> (const U &amp;u)</td></tr>
<tr class="memdesc:ab72fd82b0e57a041f34bab1f6aa9d7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack coefficients of u of generic type U ready for assembly. <br /></td></tr>
<tr class="separator:ab72fd82b0e57a041f34bab1f6aa9d7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675726ec5a50e752509a9d913c0ac3da"><td class="memTemplParams" colspan="2"><a id="a675726ec5a50e752509a9d913c0ac3da"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a675726ec5a50e752509a9d913c0ac3da"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Array&lt; typename U::scalar_type, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#a675726ec5a50e752509a9d913c0ac3da">pack_constants</a> (const U &amp;u)</td></tr>
<tr class="memdesc:a675726ec5a50e752509a9d913c0ac3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack constants of u of generic type U ready for assembly. <br /></td></tr>
<tr class="separator:a675726ec5a50e752509a9d913c0ac3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finite element method functionality. </p>
<p>Classes and algorithms for finite element method spaces and operations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a64fe28ab22e0501f9b45a81383879c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fe28ab22e0501f9b45a81383879c53">&#9670;&nbsp;</a></span>add_diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::add_diagonal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a value to the diagonal of a matrix for specified rows. It is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row blocks, in local indices, for which to add a value to the diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for the specified rows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175f0a078c133bae316835934d6cf09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175f0a078c133bae316835934d6cf09f">&#9670;&nbsp;</a></span>add_diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::add_diagonal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a value to the diagonal of the matrix for rows with a Dirichlet boundary conditions applied. This function is typically called after assembly. The assembly function zeroes Dirichlet rows and columns. This function adds the value only to rows that are locally owned, and therefore does not create a need for parallel communication. For block matrices, this function should normally be called only on the diagonal blocks, i.e. blocks for which the test and trial spaces are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values to a matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space for the rows and columns of the matrix. It is used to extract only the Dirichlet boundary conditions that are define on V or subspaces of V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>The Dirichlet boundary condtions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonal</td><td>The value to add to the diagonal for rows with a boundary condition applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d5eb7874066177b1a7d3531431a0e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5eb7874066177b1a7d3531431a0e88">&#9670;&nbsp;</a></span>apply_lifting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Ref&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="a8e8057875ef52f435031ee4b338923be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8057875ef52f435031ee4b338923be">&#9670;&nbsp;</a></span>apply_lifting_petsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::apply_lifting_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; PetscScalar &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify b such that: </p>
<p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
<p>where j is a block (nest) index. For a non-blocked problem j = 0. The boundary conditions bcs1 are on the trial spaces V_j. The forms in [a] must have the same test space as L (from which b was built), but the trial space may differ. If x0 is not supplied, then it is treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>

</div>
</div>
<a id="abf99ae072832072ed604cae6520c1e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf99ae072832072ed604cae6520c1e78">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_marker1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. Matrix must already be initialised. Does not zero or finalise the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear form to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker0</td><td>Boundary condition markers for the rows. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_marker1</td><td>Boundary condition markers for the columns. If bc[i] is true then rows i in A will be zeroed. The index i is a local index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60d3a1fadafb513e38d9176835746c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d3a1fadafb513e38d9176835746c6b">&#9670;&nbsp;</a></span>assemble_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; int(std::int32_t, const std::int32_t *, std::int32_t, const std::int32_t *, const T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble bilinear form into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_add</td><td>The function for adding values into the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The bilinear from to assemble </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions to apply. For boundary condition dofs the row and column are zeroed. The diagonal entry is not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a1bf9501710367c63159980f429bda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1bf9501710367c63159980f429bda3">&#9670;&nbsp;</a></span>assemble_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dolfinx::fem::assemble_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble functional into scalar. Caller is responsible for accumulation across processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The form (functional) to assemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution to the form (functional) from the local process </dd></dl>

</div>
</div>
<a id="aefbb2bf558822ad0e8b12e0a998b341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbb2bf558822ad0e8b12e0a998b341c">&#9670;&nbsp;</a></span>assemble_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into an Eigen vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The Eigen vector to be assembled. It will not be zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear forms to assemble into b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3244047c43f91367032ec2568c613dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3244047c43f91367032ec2568c613dd3">&#9670;&nbsp;</a></span>assemble_vector_petsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::assemble_vector_petsc </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble linear form into an already allocated PETSc vector. Ghost contributions are not accumulated (not sent to owner). Caller is responsible for calling VecGhostUpdateBegin/End. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The PETsc vector to assemble the form into. The vector must already be initialised with the correct size. The process-local contribution of the form is assembled into this vector. It is not zeroed before assembly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The linear form to assemble </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f856e311a91eab169aa08cc5af4ef18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f856e311a91eab169aa08cc5af4ef18">&#9670;&nbsp;</a></span>bcs_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;std::vector&lt;std::shared_ptr&lt;const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt;T&gt; &gt; &gt; &gt; &gt; dolfinx::fem::bcs_cols </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arrange boundary conditions by block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Biinear forms for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boundary conditions collected by block, i.e. bcs_block[i] is the list of boundary conditions applied to the trial space of a[i]. The order within bcs_block[i] preserves the input order of the bcs array. </dd></dl>

</div>
</div>
<a id="a850a9cbb3ea5b561750d327b15ae44e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850a9cbb3ea5b561750d327b15ae44e7">&#9670;&nbsp;</a></span>bcs_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::shared_ptr&lt;const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt;T&gt; &gt; &gt; &gt; dolfinx::fem::bcs_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">fem::DirichletBC</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arrange boundary conditions by block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Linear forms for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcs</td><td>Boundary conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boundary conditions collected by block, i.e. bcs_block[i] is the list of boundary conditions applied to L[i]. The order within bcs_block[i] preserves the input order of the bcs array. </dd></dl>

</div>
</div>
<a id="a4686b146b3274c580b056a947ecb1ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4686b146b3274c580b056a947ecb1ca4">&#9670;&nbsp;</a></span>build_dofmap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;, int, <a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &gt; dolfinx::fem::build_dofmap_data </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">ElementDofLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>element_dof_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build dofmap data for an element on a mesh topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_dof_layout</td><td>The element dof layout for the function space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index map and local to global DOF data for the DOF map. </dd></dl>

</div>
</div>
<a id="aa3f56a7d7c65eb949973e8d75ae0c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f56a7d7c65eb949973e8d75ae0c57b">&#9670;&nbsp;</a></span>common_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt; &gt;, 2 &gt; dolfinx::fem::common_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::array&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a> &gt;, 2 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract FunctionSpaces for (0) rows blocks and (1) columns blocks from a rectangular array of (test, trial) space pairs. The test space must be the same for each row and the trial spaces must be the same for each column. Raises an exception if there is an inconsistency. e.g. if each form in row i does not have the same test space then an exception is raised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>Vector function spaces for (0) each row block and (1) each column block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d4704c14b27bf55e6660ef92042427d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4704c14b27bf55e6660ef92042427d">&#9670;&nbsp;</a></span>compute_dof_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Array&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; dolfinx::fem::compute_dof_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d80/classdolfinx_1_1fem_1_1ElementDofLayout.html">fem::ElementDofLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dof permutations for all cells. Each row contains the numbers from 0 to (number of dofs on reference - 1) permuted so that edges are oriented towards the higher global vertex index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_layout</td><td>The layout of dofs on a each cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutations </dd></dl>

</div>
</div>
<a id="af3a2f617d1ec2975eb41dd2bd24f19cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a2f617d1ec2975eb41dd2bd24f19cc">&#9670;&nbsp;</a></span>create_coordinate_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> dolfinx::fem::create_coordinate_map </td>
          <td>(</td>
          <td class="paramtype">const ufc_coordinate_mapping &amp;&#160;</td>
          <td class="paramname"><em>ufc_cmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html" title="This class manages coordinate mappings for isoparametric cells.">CoordinateElement</a> from ufc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_cmap</td><td>UFC coordinate mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A DOLFINX coordinate map </dd></dl>

</div>
</div>
<a id="ad054263045b42a9fb5438f4ecea9a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad054263045b42a9fb5438f4ecea9a999">&#9670;&nbsp;</a></span>create_coordinate_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html">fem::CoordinateElement</a> dolfinx::fem::create_coordinate_map </td>
          <td>(</td>
          <td class="paramtype">ufc_coordinate_mapping *(*)()&#160;</td>
          <td class="paramname"><em>fptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../d9/d35/classdolfinx_1_1fem_1_1CoordinateElement.html" title="This class manages coordinate mappings for isoparametric cells.">CoordinateElement</a> from ufc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> Pointer to a ufc_function_coordinate_map function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A DOLFINX coordinate map </dd></dl>

</div>
</div>
<a id="aa96266b91a3df6e8b072f40155c45a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96266b91a3df6e8b072f40155c45a86">&#9670;&nbsp;</a></span>create_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3c/classdolfinx_1_1fem_1_1DofMap.html">fem::DofMap</a> dolfinx::fem::create_dofmap </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ufc_dofmap &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d02/classdolfinx_1_1mesh_1_1Topology.html">mesh::Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topology</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create dof map on mesh from a ufc_dofmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td><a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The ufc_dofmap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">topology</td><td>The mesh topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee048b92a2f1d3ab229f04a1e1adad98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee048b92a2f1d3ab229f04a1e1adad98">&#9670;&nbsp;</a></span>create_form() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>The function spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain makers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a52e81a6709aca5199ecc943520543b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e81a6709aca5199ecc943520543b80">&#9670;&nbsp;</a></span>create_form() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> from UFC input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>Vector of function spaces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a534371b86f32e225d84540bc39b2ee36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534371b86f32e225d84540bc39b2ee36">&#9670;&nbsp;</a></span>create_form() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt;T&gt; &gt; dolfinx::fem::create_form </td>
          <td>(</td>
          <td class="paramtype">ufc_form *(*)()&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">fem::Function</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">fem::Constant</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html#afc30329eb0140cb5f16d715fa4eedd76">IntegralType</a>, const <a class="el" href="../../d4/d31/classdolfinx_1_1mesh_1_1MeshTags.html">mesh::MeshTags</a>&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> using a factory function that returns a pointer to a ufc_form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td>pointer to a function returning a pointer to ufc_form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spaces</td><td>The function spaces for the <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>Coefficient fields in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Spatial constants in the form (by name) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomains</td><td>Subdomain markers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh of the domain. This is required if the form has no arguments, e.g. a functional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html" title="Class for variational forms.">Form</a> </dd></dl>

</div>
</div>
<a id="a6945e14af84d7cfa415a09fb09ce59e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6945e14af84d7cfa415a09fb09ce59e8">&#9670;&nbsp;</a></span>create_functionspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt; dolfinx::fem::create_functionspace </td>
          <td>(</td>
          <td class="paramtype">ufc_function_space *(*)(const char *)&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d0/ddf/classdolfinx_1_1mesh_1_1Mesh.html">mesh::Mesh</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> from UFC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fptr</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> Pointer to a ufc_function_space_create function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_name</td><td>Name of a function whose function space to create. <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> name is the name of Python variable for ufl.Coefficient, ufl.TrialFunction or ufl.TestFunction as defined in the UFL file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">FunctionSpace</a> </dd></dl>

</div>
</div>
<a id="af84a7f13165718f74b1c3640434f8ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84a7f13165718f74b1c3640434f8ad3">&#9670;&nbsp;</a></span>create_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dfa/classdolfinx_1_1la_1_1PETScMatrix.html">la::PETScMatrix</a> dolfinx::fem::create_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The PETSc matrix type to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse matrix with a layout and sparsity that matches the bilinear form </dd></dl>

</div>
</div>
<a id="a6d1425519f27729ce63733de1b531148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1425519f27729ce63733de1b531148">&#9670;&nbsp;</a></span>create_matrix_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dfa/classdolfinx_1_1la_1_1PETScMatrix.html">la::PETScMatrix</a> dolfinx::fem::create_matrix_block </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; PetscScalar &gt; *, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a monolithic matrix for an array of bilinear forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Rectangular array of bilinear forms. The <code>a(i, j)</code> form will correspond to the <code>(i, j)</code> block in the returned matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of PETSc Mat. If empty the PETSc default is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse matrix with a layout and sparsity that matches the bilinear forms </dd></dl>

</div>
</div>
<a id="afefced23767b97f6cc040b07627f9522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefced23767b97f6cc040b07627f9522">&#9670;&nbsp;</a></span>create_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/df9/classdolfinx_1_1la_1_1SparsityPattern.html">la::SparsityPattern</a> dolfinx::fem::create_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">Form</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparsity pattern for a given form. The pattern is not finalised, i.e. the caller is responsible for calling SparsityPattern::assemble. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A bilinear form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding sparsity pattern </dd></dl>

</div>
</div>
<a id="ae5fce6fd18d359bf2f67f71ac952b8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fce6fd18d359bf2f67f71ac952b8e0">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::eval </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db9/classdolfinx_1_1fem_1_1Expression.html">fem::Expression</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a UFC expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>An array to evaluate the expression into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The expression to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">active_cells</td><td>The cells on which to evaluate the expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a453c186ac134116bbcb3a266ee8ddd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453c186ac134116bbcb3a266ee8ddd82">&#9670;&nbsp;</a></span>extract_function_spaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;std::array&lt;std::shared_ptr&lt;const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a>&gt;, 2&gt; &gt; &gt; dolfinx::fem::extract_function_spaces </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; const <a class="el" href="../../df/d02/classdolfinx_1_1fem_1_1Form.html">fem::Form</a>&lt; T &gt; *, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract test (0) and trial (1) function spaces pairs for each bilinear form for a rectangular array of forms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A rectangular block on bilinear forms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular array of the same shape as <code>a</code> with a pair of function spaces in each array entry. If a form is null, then the returned function space pair is (null, null). </dd></dl>

</div>
</div>
<a id="ad1922184233dd7810487d11b7a8a041b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1922184233dd7810487d11b7a8a041b">&#9670;&nbsp;</a></span>get_coefficient_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dolfinx::fem::get_coefficient_names </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each coefficient in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form return The name of each coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef8c5d7afb948b36c9c3e73bdf0d57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef8c5d7afb948b36c9c3e73bdf0d57c">&#9670;&nbsp;</a></span>get_constant_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; dolfinx::fem::get_constant_names </td>
          <td>(</td>
          <td class="paramtype">const ufc_form &amp;&#160;</td>
          <td class="paramname"><em>ufc_form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of each constant in a UFC form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ufc_form</td><td>The UFC form return The name of each constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab586fb783800561657947349543c7b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab586fb783800561657947349543c7b97">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> (on possibly non-matching meshes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The function to be interpolated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a077eac3332276aa981e35f96f1d92b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077eac3332276aa981e35f96f1d92b49">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The expression to be interpolated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1a081146d5dc1472f5cdf36f556a793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a081146d5dc1472f5cdf36f556a793">&#9670;&nbsp;</a></span>interpolate_c()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dolfinx::fem::interpolate_c </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(Eigen::Ref&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&gt;, const Eigen::Ref&lt; const Eigen::Array&lt; double, Eigen::Dynamic, 3, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate an expression f(x). This interface uses an expression function f that has an in/out argument for the expression values. It is primarily to support C code implementations of the expression, e.g. using Numba. Generally the interface where the expression function is a pure function, i.e. the expression values are the return argument, should be preferred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>The function to interpolate into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The expression to be interpolated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9791dfb702c5fd1876bc2bef141146c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9791dfb702c5fd1876bc2bef141146c0">&#9670;&nbsp;</a></span>locate_dofs_geometrical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt; dolfinx::fem::locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees of freedom will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="a5070e597fd9233679d78d299615922e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5070e597fd9233679d78d299615922e5">&#9670;&nbsp;</a></span>locate_dofs_geometrical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;, 2 &gt; dolfinx::fem::locate_dofs_geometrical </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt;(const Eigen::Ref&lt; const Eigen::Array&lt; double, 3, Eigen::Dynamic, Eigen::RowMajor &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>marker_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds degrees of freedom whose geometric coordinate is true for the provided marking function. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is slower than the topological version</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space(s) on which degrees of freedom will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">marker_fn</td><td><a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> marking tabulated degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the correspinding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="a32154e731dd2a9838c312f4ea914cba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32154e731dd2a9838c312f4ea914cba9">&#9670;&nbsp;</a></span>locate_dofs_topological() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt; dolfinx::fem::locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::ArrayXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which degrees-of-freedom (DOFs) will be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF index blocks (local to the <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> rank) in the space V. The array uses the block size of the dofmap associated with V. </dd></dl>

</div>
</div>
<a id="a01d40a08055994ab2d379e39ee4793a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d40a08055994ab2d379e39ee4793a3">&#9670;&nbsp;</a></span>locate_dofs_topological() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Eigen::Array&lt; std::int32_t, Eigen::Dynamic, 1 &gt;, 2 &gt; dolfinx::fem::locate_dofs_topological </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::reference_wrapper&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">fem::FunctionSpace</a> &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::ArrayXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find degrees-of-freedom which belong to the provided mesh entities (topological). Note that degrees-of-freedom for discontinuous elements are associated with the cell even if they may appear to be associated with a facet/edge/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)spaces on which degrees-of-freedom (DOFs) will be located. The spaces must share the same mesh and element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Topological dimension of mesh entities on which degrees-of-freedom will be located </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entities</td><td>Indices of mesh entities. All DOFs associated with the closure of these indices will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>True to return also "remotely located" degree-of-freedom indices. Remotely located degree-of-freedom indices are local/owned by the current process, but which the current process cannot identify because it does not recognize mesh entity as a marked. For example, a boundary condition dof at a vertex where this process does not have the associated boundary facet. This commonly occurs with partitioned meshes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of DOF indices (local to the <a class="el" href="../../de/dbf/classdolfinx_1_1MPI.html" title="This class provides utility functions for easy communication with MPI and handles cases when DOLFINX ...">MPI</a> rank) in the spaces V[0] and V[1]. The array[0](i) entry is the DOF index in the space V[0] and array[1](i) is the correspinding DOF entry in the space V[1]. The returned dofs are 'unrolled', i.e. block size = 1. </dd></dl>

</div>
</div>
<a id="ade4e47c2e856ec9b2d43e8a386a0ff61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4e47c2e856ec9b2d43e8a386a0ff61">&#9670;&nbsp;</a></span>transpose_dofmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; dolfinx::fem::transpose_dofmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d84/classdolfinx_1_1graph_1_1AdjacencyList.html">graph::AdjacencyList</a>&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>num_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency list that maps a global index (process-wise) to the 'unassembled' cell-wise contributions. It is built from the usual (cell, local index) -&gt; global index dof map. An 'unassembled' vector is the stacked cell contributions, ordered by cell index. </p>
<p>If the usual dof map is:</p>
<p>Cell: 0 1 2 3 Global index: [ [0, 3, 5], [3, 2, 4], [4, 3, 2], [2, 1, 0]]</p>
<p>the 'transpose' dof map will be:</p>
<p>Global index: 0 1 2 3 4 5 Unassembled index: [ [0, 11], [10], [4, 8, 9], [1, 3, 7], [5, 6], [2] ]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dofmap</td><td>The standard dof map that for each cell (node) gives the global (process-wise) index of each local (cell-wise) index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>The number of cells (nodes) in <code>dofmap</code> to consider. The first <code>num_cells</code> are used. This is argument is typically used to exclude ghost cell contributions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map from global (process-wise) index to positions in an unaassembled array. The links for each node are sorted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>

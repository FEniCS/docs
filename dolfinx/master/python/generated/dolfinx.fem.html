
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dolfinx.fem &#8212; DOLFINX  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="dolfinx.generation" href="dolfinx.generation.html" />
    <link rel="prev" title="dolfinx.common" href="dolfinx.common.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dolfinx.generation.html" title="dolfinx.generation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dolfinx.common.html" title="dolfinx.common"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DOLFINX  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dolfinx.fem</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dolfinx.fem">
<span id="dolfinx-fem"></span><h1>dolfinx.fem<a class="headerlink" href="#module-dolfinx.fem" title="Permalink to this headline">¶</a></h1>
<p>Tools for assembling and manipulating finite element forms</p>
<dl class="py class">
<dt id="dolfinx.fem.Constant">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">Constant</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">domain</span></em>, <em class="sig-param"><span class="n">c</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>numpy.ndarray<span class="p">, </span>Sequence<span class="p">, </span>float<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.constant.Constant</span></code></p>
<p>A constant with respect to a domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<em>DOLFIN</em><em> or </em><em>UFL mesh</em>) – </p></li>
<li><p><strong>c</strong> – Value of the constant.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="dolfinx.fem.Constant.value">
<em class="property">property </em><code class="sig-name descname">value</code><a class="headerlink" href="#dolfinx.fem.Constant.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns value of the constant.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.DirichletBC">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">DirichletBC</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>ufl.coefficient.Coefficient<span class="p">, </span>dolfinx.fem.function.Function<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Function" title="dolfinx.cpp.fem.Function">dolfinx.cpp.fem.Function</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">dofs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>dolfinx.fem.function.FunctionSpace<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#DirichletBC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DirichletBC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.DirichletBC" title="dolfinx.cpp.fem.DirichletBC"><code class="xref py py-class docutils literal notranslate"><span class="pre">dolfinx.cpp.fem.DirichletBC</span></code></a></p>
<p>Representation of Dirichlet boundary condition which is imposed on
a linear system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – Lifted boundary values function.</p></li>
<li><p><strong>dofs</strong> – Local indices of degrees of freedom in function space to which
boundary condition applies.
Expects array of size (number of dofs, 2) if function space of the
problem, <code class="docutils literal notranslate"><span class="pre">V</span></code>, is passed. Otherwise assumes function space of the
problem is the same of function space of boundary values function.</p></li>
<li><p><strong>V</strong> (<em>optional</em>) – Function space of a problem to which boundary conditions are applied.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.DofMap">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">DofMap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dofmap</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.DofMap" title="dolfinx.cpp.fem.DofMap">dolfinx.cpp.fem.DofMap</a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dofmap.html#DofMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DofMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Degree-of-freedom map</p>
<p>This class handles the mapping of degrees of freedom. It builds
a dof map based on a ufc_dofmap on a specific mesh.</p>
<dl class="py method">
<dt id="dolfinx.fem.DofMap.bs">
<em class="property">property </em><code class="sig-name descname">bs</code><a class="headerlink" href="#dolfinx.fem.DofMap.bs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.cell_dofs">
<code class="sig-name descname">cell_dofs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell_index</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dofmap.html#DofMap.cell_dofs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.DofMap.cell_dofs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.dof_layout">
<em class="property">property </em><code class="sig-name descname">dof_layout</code><a class="headerlink" href="#dolfinx.fem.DofMap.dof_layout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.index_map">
<em class="property">property </em><code class="sig-name descname">index_map</code><a class="headerlink" href="#dolfinx.fem.DofMap.index_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.index_map_bs">
<em class="property">property </em><code class="sig-name descname">index_map_bs</code><a class="headerlink" href="#dolfinx.fem.DofMap.index_map_bs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.DofMap.list">
<em class="property">property </em><code class="sig-name descname">list</code><a class="headerlink" href="#dolfinx.fem.DofMap.list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.Expression">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">Expression</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ufl_expression</span><span class="p">:</span> <span class="n">ufl.core.expr.Expr</span></em>, <em class="sig-param"><span class="n">x</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">form_compiler_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">jit_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Expression"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Create dolfinx Expression.</p>
<p>Represents a mathematical expression evaluated at a pre-defined set of
points on the reference cell. This class closely follows the concept of a
UFC Expression.</p>
<p>This functionality can be used to evaluate a gradient of a Function at
the quadrature points in all cells. This evaluated gradient can then be
used as input to a non-FEniCS function that calculates a material
constitutive model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ufl_expression</strong> – Pure UFL expression</p></li>
<li><p><strong>x</strong> – Array of points of shape (num_points, tdim) on the reference
element.</p></li>
<li><p><strong>form_compiler_parameters</strong> – Parameters used in FFCX compilation of this Expression. Run <cite>ffcx
–help</cite> in the commandline to see all available options.</p></li>
<li><p><strong>jit_parameters</strong> – Parameters controlling JIT compilation of C code.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This wrapper is responsible for the FFCX compilation of the UFL Expr
and attaching the correct data to the underlying C++ Expression.</p>
</div>
<dl class="py method">
<dt id="dolfinx.fem.Expression.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cells</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">u</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>numpy.ndarray<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="../_modules/dolfinx/fem/function.html#Expression.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Expression.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate Expression in cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cells</strong> – local indices of cells to evaluate expression.</p></li>
<li><p><strong>u</strong> (<em>optional</em>) – array of shape (num_cells, num_points*value_size) to
store result of expression evaluation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u</strong> – The i-th row of u contains the expression evaluated on cells[i].</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function allocates u of the appropriate size if u is not passed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Expression.num_points">
<em class="property">property </em><code class="sig-name descname">num_points</code><a class="headerlink" href="#dolfinx.fem.Expression.num_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of evaluation points on the reference cell.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Expression.ufl_expression">
<em class="property">property </em><code class="sig-name descname">ufl_expression</code><a class="headerlink" href="#dolfinx.fem.Expression.ufl_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the original UFL Expression</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Expression.value_size">
<em class="property">property </em><code class="sig-name descname">value_size</code><a class="headerlink" href="#dolfinx.fem.Expression.value_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value size of the expression</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Expression.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#dolfinx.fem.Expression.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation points on the reference cell</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.Form">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">Form</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">form_compiler_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">jit_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/form.html#Form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Form" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Create dolfinx Form</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>form</strong> – Pure UFL form</p></li>
<li><p><strong>form_compiler_parameters</strong> – See <a class="reference internal" href="dolfinx.jit.html#dolfinx.jit.ffcx_jit" title="dolfinx.jit.ffcx_jit"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffcx_jit</span></code></a></p></li>
<li><p><strong>jit_parameters</strong> – See <a class="reference internal" href="dolfinx.jit.html#dolfinx.jit.ffcx_jit" title="dolfinx.jit.ffcx_jit"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffcx_jit</span></code></a></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This wrapper for UFL form is responsible for the actual FFCX compilation
and attaching coefficients and domains specific data to the underlying
C++ Form.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.Function">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">Function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">dolfinx.fem.function.FunctionSpace</span></em>, <em class="sig-param"><span class="n">x</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>dolfinx.cpp.la.Vector<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.coefficient.Coefficient</span></code></p>
<p>A finite element function that is represented by a function
space (domain, element and dofmap) and a vector holding the
degrees-of-freedom</p>
<p>Initialize finite element Function.</p>
<dl class="py method">
<dt id="dolfinx.fem.Function.collapse">
<code class="sig-name descname">collapse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.collapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.collapse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.compute_point_values">
<code class="sig-name descname">compute_point_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.compute_point_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.compute_point_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the Function. The FunctionSpace is shared and the
degree-of-freedom vector is copied.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">cells</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">u</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate Function at points x, where x has shape (num_points, 3),
and cells has shape (num_points,) and cell[i] is the index of the
cell containing point x[i]. If the cell index is negative the
point is ignored.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.function_space">
<em class="property">property </em><code class="sig-name descname">function_space</code><a class="headerlink" href="#dolfinx.fem.Function.function_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the FunctionSpace</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.id">
<em class="property">property </em><code class="sig-name descname">id</code><a class="headerlink" href="#dolfinx.fem.Function.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return object id index.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate an expression</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#dolfinx.fem.Function.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the Function.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract any sub functions.</p>
<p>A sub function can be extracted from a discrete function that
is in a mixed, vector, or tensor FunctionSpace. The sub
function resides in the subspace of the mixed space.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sub function.</p>
<p>The sub functions are numbered from i = 0..N-1, where N is the
total number of sub spaces.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.ufl_evaluate">
<code class="sig-name descname">ufl_evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">component</span></em>, <em class="sig-param"><span class="n">derivatives</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#Function.ufl_evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.Function.ufl_evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Function used by ufl to evaluate the Expression</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.vector">
<em class="property">property </em><code class="sig-name descname">vector</code><a class="headerlink" href="#dolfinx.fem.Function.vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector holding Function degrees-of-freedom.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.Function.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#dolfinx.fem.Function.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector holding Function degrees-of-freedom.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.FunctionSpace">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">FunctionSpace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.mesh.html#dolfinx.cpp.mesh.Mesh" title="dolfinx.cpp.mesh.Mesh">dolfinx.cpp.mesh.Mesh</a></span></em>, <em class="sig-param"><span class="n">element</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>ufl.finiteelement.finiteelementbase.FiniteElementBase<span class="p">, </span>dolfinx.fem.function.ElementMetaData<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">cppV</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.FunctionSpace" title="dolfinx.cpp.fem.FunctionSpace">dolfinx.cpp.fem.FunctionSpace</a><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">form_compiler_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">jit_parameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.functionspace.FunctionSpace</span></code></p>
<p>A space on which Functions (fields) can be defined.</p>
<p>Create a finite element function space.</p>
<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new FunctionSpace <span class="math notranslate nohighlight">\(W\)</span> which shares data with this
FunctionSpace <span class="math notranslate nohighlight">\(V\)</span>, but with a different unique integer ID.</p>
<p>This function is helpful for defining mixed problems and using
blocked linear algebra. For example, a matrix block defined on
the spaces <span class="math notranslate nohighlight">\(V \times W\)</span> where, <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(W\)</span>
are defined on the same finite element and mesh can be
identified as an off-diagonal block whereas the <span class="math notranslate nohighlight">\(V \times
V\)</span> and <span class="math notranslate nohighlight">\(V \times V\)</span> matrices can be identified as
diagonal blocks. This is relevant for the handling of boundary
conditions.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.collapse">
<code class="sig-name descname">collapse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">collapsed_dofs</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.collapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.collapse" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Collapse a subspace and return a new function space and a map from</dt><dd><p>new to old dofs.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>collapsed_dofs</dt><dd><p>Return the map from new to old dofs</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><dl class="simple">
<dt>FunctionSpace</dt><dd><p>The new function space.</p>
</dd>
<dt>dict</dt><dd><p>The map from new to old dofs (optional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.component">
<code class="sig-name descname">component</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.component"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.component" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the component relative to the parent space.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a FunctionSpace is in this FunctionSpace, or is the
same as this FunctionSpace.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#dolfinx.fem.FunctionSpace.dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.dofmap">
<em class="property">property </em><code class="sig-name descname">dofmap</code><a class="headerlink" href="#dolfinx.fem.FunctionSpace.dofmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree-of-freedom map associated with the function space.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.dolfin_element">
<code class="sig-name descname">dolfin_element</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.dolfin_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.dolfin_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the DOLFIN element.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.element">
<em class="property">property </em><code class="sig-name descname">element</code><a class="headerlink" href="#dolfinx.fem.FunctionSpace.element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.id">
<em class="property">property </em><code class="sig-name descname">id</code><a class="headerlink" href="#dolfinx.fem.FunctionSpace.id" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique identifier</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.mesh">
<em class="property">property </em><code class="sig-name descname">mesh</code><a class="headerlink" href="#dolfinx.fem.FunctionSpace.mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mesh on which the function space is defined.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.num_sub_spaces">
<code class="sig-name descname">num_sub_spaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.num_sub_spaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.num_sub_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of sub spaces.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the i-th sub space.</p>
</dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.tabulate_dof_coordinates">
<code class="sig-name descname">tabulate_dof_coordinates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.tabulate_dof_coordinates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.tabulate_dof_coordinates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.ufl_cell">
<code class="sig-name descname">ufl_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.ufl_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.ufl_cell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.FunctionSpace.ufl_function_space">
<code class="sig-name descname">ufl_function_space</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; ufl.functionspace.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/function.html#FunctionSpace.ufl_function_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.FunctionSpace.ufl_function_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the UFL function space</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="dolfinx.fem.IntegralType">
<em class="property">class </em><code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">IntegralType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.IntegralType" title="dolfinx.cpp.fem.IntegralType">dolfinx.cpp.fem.IntegralType</a></span></em>, <em class="sig-param"><span class="n">value</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#dolfinx.fem.IntegralType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>cell</p>
<p>exterior_facet</p>
<p>interior_facet</p>
<p>vertex</p>
<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.cell">
<code class="sig-name descname">cell</code><em class="property"> = &lt;IntegralType.cell: 0&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.cell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.exterior_facet">
<code class="sig-name descname">exterior_facet</code><em class="property"> = &lt;IntegralType.exterior_facet: 1&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.exterior_facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.interior_facet">
<code class="sig-name descname">interior_facet</code><em class="property"> = &lt;IntegralType.interior_facet: 2&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.interior_facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="dolfinx.fem.IntegralType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#dolfinx.fem.IntegralType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="dolfinx.fem.IntegralType.vertex">
<code class="sig-name descname">vertex</code><em class="property"> = &lt;IntegralType.vertex: 3&gt;</em><a class="headerlink" href="#dolfinx.fem.IntegralType.vertex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.TensorFunctionSpace">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">TensorFunctionSpace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.mesh.html#dolfinx.cpp.mesh.Mesh" title="dolfinx.cpp.mesh.Mesh">dolfinx.cpp.mesh.Mesh</a></span></em>, <em class="sig-param"><span class="n">element</span><span class="p">:</span> <span class="n">dolfinx.fem.function.ElementMetaData</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">symmetry</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>bool<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">restriction</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/function.html#TensorFunctionSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.TensorFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Create tensor finite element (composition of scalar elements) function space.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.VectorFunctionSpace">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">VectorFunctionSpace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span><span class="p">:</span> <span class="n"><a class="reference internal" href="dolfinx.cpp.mesh.html#dolfinx.cpp.mesh.Mesh" title="dolfinx.cpp.mesh.Mesh">dolfinx.cpp.mesh.Mesh</a></span></em>, <em class="sig-param"><span class="n">element</span><span class="p">:</span> <span class="n">dolfinx.fem.function.ElementMetaData</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">restriction</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/function.html#VectorFunctionSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.VectorFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Create vector finite element (composition of scalar elements) function space.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.adjoint">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">reordered_arguments</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; ufl.form.Form<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute adjoint of a bilinear form by changing the ordering (count)
of the test and trial functions.</p>
<p>The functions wraps <code class="docutils literal notranslate"><span class="pre">ufl.adjoint</span></code>, and by default UFL will create new
<code class="docutils literal notranslate"><span class="pre">Argument</span></code> s. To specify the <code class="docutils literal notranslate"><span class="pre">Argument</span></code> s rather than creating new ones,
pass a tuple of <code class="docutils literal notranslate"><span class="pre">Argument</span></code> s as <code class="docutils literal notranslate"><span class="pre">reordered_arguments</span></code>.
See the documentation for <code class="docutils literal notranslate"><span class="pre">ufl.adjoint</span></code> for more details.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.apply_lifting">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">apply_lifting</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>List<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#apply_lifting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.apply_lifting" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify RHS vector b for lifting of Dirichlet boundary conditions.
It modifies b such that:</p>
<blockquote>
<div><p>b &lt;- b - scale * A_j (g_j - x0_j)</p>
</div></blockquote>
<p>where j is a block (nest) index. For a non-blocked problem j = 0.
The boundary conditions bcs are on the trial spaces V_j. The forms
in [a] must have the same test space as L (from which b was built),
but the trial space may differ. If x0 is not supplied, then it is
treated as zero.</p>
<p>Ghost contributions are not accumulated (not sent to owner). Caller
is responsible for calling VecGhostUpdateBegin/End.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.apply_lifting_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">apply_lifting_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#apply_lifting_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.apply_lifting_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify nested vector for lifting of Dirichlet boundary conditions.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear form into a matrix. The returned matrix is not
finalised, i.e. ghost values are not accumulated.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix_block" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear forms into matrix</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_matrix_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">mat_types</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_matrix_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_matrix_nest" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Mat</span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">diagonal</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat</dt>
<dd><p>Assemble bilinear forms into matrix</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_scalar">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; numpy.float64<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble functional. The returned value is local and not accumulated
across processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear form into a new PETSc vector. The returned vector is
not finalised, i.e. ghost values are not accumulated on the owning
processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector_block" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear forms into a monolithic vector. The vector is not
finalised, i.e. ghost values are not accumulated.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.assemble_vector_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#assemble_vector_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.assemble_vector_nest" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">assemble_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec</dt>
<dd><p>Assemble linear forms into a new nested PETSc (VecNest) vector. The
returned vector is not finalised, i.e. ghost values are not accumulated
on the owning processes.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_coordinate_map">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_coordinate_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">comm</span></em>, <em class="sig-param"><span class="n">o</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/coordinatemapping.html#create_coordinate_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_coordinate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a compiled UFC coordinate_mapping object</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">mat_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_matrix_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_matrix_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Mat<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_matrix_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_matrix_nest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector_block">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector_block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.create_vector_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">create_vector_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Union<span class="p">[</span>dolfinx.fem.form.Form<span class="p">, </span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.Form" title="dolfinx.cpp.fem.Form">dolfinx.cpp.fem.Form</a><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; petsc4py.PETSc.Vec<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#create_vector_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.create_vector_nest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.derivative">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="p">:</span> <span class="n">ufl.form.Form</span></em>, <em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">du</span></em>, <em class="sig-param"><span class="n">coefficient_derivatives</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; ufl.form.Form<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#derivative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute derivative of from about u (coefficient) in the direction
of du (Argument)</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.increase_order">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">increase_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">dolfinx.fem.function.FunctionSpace</span></em><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#increase_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.increase_order" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given function space, return the same space, but with
polynomial degree increase by 1.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.locate_dofs_geometrical">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">locate_dofs_geometrical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.FunctionSpace" title="dolfinx.cpp.fem.FunctionSpace">dolfinx.cpp.fem.FunctionSpace</a><span class="p">, </span>dolfinx.fem.function.FunctionSpace<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">marker</span><span class="p">:</span> <span class="n">function</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#locate_dofs_geometrical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.locate_dofs_geometrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate degrees-of-freedom geometrically using a marker function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> – Function space(s) in which to search for degree-of-freedom indices.</p></li>
<li><p><strong>marker</strong> – A function that takes an array of points <code class="docutils literal notranslate"><span class="pre">x</span></code> with shape
<code class="docutils literal notranslate"><span class="pre">(gdim,</span> <span class="pre">num_points)</span></code> and returns an array of booleans of length
<code class="docutils literal notranslate"><span class="pre">num_points</span></code>, evaluating to <code class="docutils literal notranslate"><span class="pre">True</span></code> for entities whose
degree-of-freedom should be returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>An array of degree-of-freedom indices (local to the process)
for degrees-of-freedom whose coordinate evaluates to True for the
marker function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is a list of two function spaces, then a 2-D array of
shape (number of dofs, 2) is returned.</p>
<p>Returned degree-of-freedom indices are unique and ordered by the
first column.</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.locate_dofs_topological">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">locate_dofs_topological</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span><a class="reference internal" href="dolfinx.cpp.fem.html#dolfinx.cpp.fem.FunctionSpace" title="dolfinx.cpp.fem.FunctionSpace">dolfinx.cpp.fem.FunctionSpace</a><span class="p">, </span>dolfinx.fem.function.FunctionSpace<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">entity_dim</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">entities</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">remote</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/dirichletbc.html#locate_dofs_topological"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.locate_dofs_topological" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate degrees-of-freedom belonging to mesh entities topologically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> – Function space(s) in which to search for degree-of-freedom indices.</p></li>
<li><p><strong>entity_dim</strong> – Topological dimension of entities where degrees-of-freedom are located.</p></li>
<li><p><strong>entities</strong> – Indices of mesh entities of dimension <code class="docutils literal notranslate"><span class="pre">entity_dim</span></code> where
degrees-of-freedom are located.</p></li>
<li><p><strong>remote</strong> (<em>True</em>) – True to return also “remotely located” degree-of-freedom indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>An array of degree-of-freedom indices (local to the process) for
degrees-of-freedom topologically belonging to mesh entities.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is a list of two function spaces, then a 2-D array of
shape (number of dofs, 2) is returned.</p>
<p>Returned degree-of-freedom indices are unique and ordered by the
first column.</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.set_bc">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">set_bc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#set_bc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.set_bc" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert boundary condition values into vector. Only local (owned)
entries are set, hence communication after calling this function is
not required unless ghost entries need to be updated to the boundary
condition value.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.set_bc_nest">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">set_bc_nest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">petsc4py.PETSc.Vec</span></em>, <em class="sig-param"><span class="n">bcs</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>dolfinx.fem.dirichletbc.DirichletBC<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">x0</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>petsc4py.PETSc.Vec<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scale</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="../_modules/dolfinx/fem/assemble.html#set_bc_nest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.set_bc_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert boundary condition values into nested vector. Only local (owned)
entries are set, hence communication after calling this function is
not required unless the ghost entries need to be updated to the
boundary condition value.</p>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.solve">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/dolfinx/fem/solving.html#solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve variational problem a == L or F == 0.</p>
<p>The following list explains the
various ways in which the solve() function can be used.</p>
<p><em>1. Solving linear variational problems</em></p>
<p>A linear variational problem a(u, v) = L(v) for all v may be
solved by calling solve(a == L, u, …), where a is a bilinear
form, L is a linear form, u is a Function (the solution). Optional
arguments may be supplied to specify boundary conditions or solver
parameters. Some examples are given below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">])</span>

<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">},</span>
      <span class="n">form_compiler_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;optimize&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>For available choices for the ‘solver_parameters’ kwarg, look at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">LinearVariationalSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><em>2. Solving nonlinear variational problems</em></p>
<p>A nonlinear variational problem F(u; v) = 0 for all v may be
solved by calling solve(F == 0, u, …), where the residual F is a
linear form (linear in the test function v but possibly nonlinear
in the unknown u) and u is a Function (the solution). Optional
arguments may be supplied to specify boundary conditions, the
Jacobian form or solver parameters. If the Jacobian is not
supplied, it will be computed by automatic differentiation of the
residual form. Some examples are given below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">])</span>

<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span>
      <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">},</span>
      <span class="n">form_compiler_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;optimize&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>For available choices for the ‘solver_parameters’ kwarg, look at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">NonlinearVariationalSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><em>4. Solving linear/nonlinear variational problems adaptively</em></p>
<p>Linear and nonlinear variational problems maybe solved adaptively,
with automated goal-oriented error control. The automated error
control algorithm is based on adaptive mesh refinement in
combination with automated generation of dual-weighted
residual-based error estimates and error indicators.</p>
<p>An adaptive solve may be invoked by giving two additional
arguments to the solve call, a numerical error tolerance and a
goal functional (a Form).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">()</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-6</span>

<span class="c1"># Linear variational problem</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>

<span class="c1"># Nonlinear problem:</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dolfinx.fem.tear">
<code class="sig-prename descclassname">dolfinx.fem.</code><code class="sig-name descname">tear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span><span class="p">:</span> <span class="n">dolfinx.fem.function.FunctionSpace</span></em><span class="sig-paren">)</span> &#x2192; dolfinx.fem.function.FunctionSpace<a class="reference internal" href="../_modules/dolfinx/fem/formmanipulations.html#tear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfinx.fem.tear" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given function space, return the corresponding discontinuous
space</p>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="dolfinx.common.html"
                        title="previous chapter">dolfinx.common</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dolfinx.generation.html"
                        title="next chapter">dolfinx.generation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/generated/dolfinx.fem.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dolfinx.generation.html" title="dolfinx.generation"
             >next</a> |</li>
        <li class="right" >
          <a href="dolfinx.common.html" title="dolfinx.common"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DOLFINX  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" >API reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dolfinx.fem</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, FEniCS Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.0.
    </div>
  </body>
</html>
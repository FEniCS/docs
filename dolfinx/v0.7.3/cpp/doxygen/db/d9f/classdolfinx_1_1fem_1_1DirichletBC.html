<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: DirichletBC&lt; T, U &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.7.3</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a class="el" href="../../d8/dbf/namespacedolfinx_1_1fem.html">fem</a></li><li class="navelem"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d5/d91/classdolfinx_1_1fem_1_1DirichletBC-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DirichletBC&lt; T, U &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Object for setting (strong) Dirichlet boundary conditions.  
 <a href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dd/d4f/DirichletBC_8h_source.html">DirichletBC.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae50db0881a424f17fc89b41af7fcbfca" id="r_ae50db0881a424f17fc89b41af7fcbfca"><td class="memTemplParams" colspan="2">template&lt;typename S , typename X , typename  = std::enable_if_t&lt;std::is_convertible_v&lt;S, T&gt;                               or std::is_convertible_v&lt;S, std::span&lt;const T&gt;&gt;&gt;&gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</td></tr>
<tr class="memitem:ae50db0881a424f17fc89b41af7fcbfca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#ae50db0881a424f17fc89b41af7fcbfca">DirichletBC</a> (const S &amp;g, X &amp;&amp;dofs, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; V)</td></tr>
<tr class="memdesc:ae50db0881a424f17fc89b41af7fcbfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a representation of a Dirichlet boundary condition constrained by a scalar- or vector-valued constant.  <br /></td></tr>
<tr class="separator:ae50db0881a424f17fc89b41af7fcbfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572c308bed9d57743123e761e45d321a" id="r_a572c308bed9d57743123e761e45d321a"><td class="memTemplParams" colspan="2">template&lt;typename X &gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</td></tr>
<tr class="memitem:a572c308bed9d57743123e761e45d321a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a572c308bed9d57743123e761e45d321a">DirichletBC</a> (std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; g, X &amp;&amp;dofs, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; V)</td></tr>
<tr class="memdesc:a572c308bed9d57743123e761e45d321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a representation of a Dirichlet boundary condition constrained by a <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html" title="Constant value which can be attached to a Form.">fem::Constant</a>.  <br /></td></tr>
<tr class="separator:a572c308bed9d57743123e761e45d321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7da5c77e4faec07d7ca9c6e876a4a4d" id="r_ac7da5c77e4faec07d7ca9c6e876a4a4d"><td class="memTemplParams" colspan="2">template&lt;typename X &gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</td></tr>
<tr class="memitem:ac7da5c77e4faec07d7ca9c6e876a4a4d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#ac7da5c77e4faec07d7ca9c6e876a4a4d">DirichletBC</a> (std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; g, X &amp;&amp;dofs)</td></tr>
<tr class="memdesc:ac7da5c77e4faec07d7ca9c6e876a4a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a representation of a Dirichlet boundary condition where the space being constrained is the same as the function that defines the constraint <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a>, i.e. share the same <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">fem::FunctionSpace</a>.  <br /></td></tr>
<tr class="separator:ac7da5c77e4faec07d7ca9c6e876a4a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b2f4da02cc564eef156711f319dd88" id="r_af0b2f4da02cc564eef156711f319dd88"><td class="memTemplParams" colspan="2">template&lt;typename X &gt; </td></tr>
<tr class="memitem:af0b2f4da02cc564eef156711f319dd88"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#af0b2f4da02cc564eef156711f319dd88">DirichletBC</a> (std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt; g, X &amp;&amp;V_g_dofs, std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; V)</td></tr>
<tr class="memdesc:af0b2f4da02cc564eef156711f319dd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a representation of a Dirichlet boundary condition where the space being constrained and the function that defines the constraint values do not share the same <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">fem::FunctionSpace</a>.  <br /></td></tr>
<tr class="separator:af0b2f4da02cc564eef156711f319dd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7986b02ec85e7fdc6945efce2d2e840a" id="r_a7986b02ec85e7fdc6945efce2d2e840a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a7986b02ec85e7fdc6945efce2d2e840a">DirichletBC</a> (const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;bc)=default</td></tr>
<tr class="memdesc:a7986b02ec85e7fdc6945efce2d2e840a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a7986b02ec85e7fdc6945efce2d2e840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6888d88c12f3e105cca97988f8697" id="r_a7de6888d88c12f3e105cca97988f8697"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a7de6888d88c12f3e105cca97988f8697">DirichletBC</a> (<a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;&amp;bc)=default</td></tr>
<tr class="memdesc:a7de6888d88c12f3e105cca97988f8697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a7de6888d88c12f3e105cca97988f8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee143c0149a09bcc95636cbbb62f85f" id="r_abee143c0149a09bcc95636cbbb62f85f"><td class="memItemLeft" align="right" valign="top"><a id="abee143c0149a09bcc95636cbbb62f85f" name="abee143c0149a09bcc95636cbbb62f85f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~DirichletBC</b> ()=default</td></tr>
<tr class="memdesc:abee143c0149a09bcc95636cbbb62f85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:abee143c0149a09bcc95636cbbb62f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d43b3e6250861976b39c60f137a9bc" id="r_a56d43b3e6250861976b39c60f137a9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a56d43b3e6250861976b39c60f137a9bc">operator=</a> (const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;bc)=default</td></tr>
<tr class="memdesc:a56d43b3e6250861976b39c60f137a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:a56d43b3e6250861976b39c60f137a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20d01e288bd20a9ca45e3690a258e74" id="r_ae20d01e288bd20a9ca45e3690a258e74"><td class="memItemLeft" align="right" valign="top"><a id="ae20d01e288bd20a9ca45e3690a258e74" name="ae20d01e288bd20a9ca45e3690a258e74"></a>
<a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp;&amp;bc)=default</td></tr>
<tr class="memdesc:ae20d01e288bd20a9ca45e3690a258e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:ae20d01e288bd20a9ca45e3690a258e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5af04d5a5c90e55a8ae8357cc21d37" id="r_aac5af04d5a5c90e55a8ae8357cc21d37"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#aac5af04d5a5c90e55a8ae8357cc21d37">function_space</a> () const</td></tr>
<tr class="memdesc:aac5af04d5a5c90e55a8ae8357cc21d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function space to which boundary conditions are applied.  <br /></td></tr>
<tr class="separator:aac5af04d5a5c90e55a8ae8357cc21d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790b0b864c5eb283d7e340a6145c7d35" id="r_a790b0b864c5eb283d7e340a6145c7d35"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt;, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a790b0b864c5eb283d7e340a6145c7d35">value</a> () const</td></tr>
<tr class="memdesc:a790b0b864c5eb283d7e340a6145c7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return boundary value function g.  <br /></td></tr>
<tr class="separator:a790b0b864c5eb283d7e340a6145c7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4c54405fafc0077a69a41c9126b11" id="r_a88d4c54405fafc0077a69a41c9126b11"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::span&lt; const std::int32_t &gt;, std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a88d4c54405fafc0077a69a41c9126b11">dof_indices</a> () const</td></tr>
<tr class="memdesc:a88d4c54405fafc0077a69a41c9126b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access dof indices (local indices, unrolled), including ghosts, to which a Dirichlet condition is applied, and the index to the first non-owned (ghost) index. The array of indices is sorted.  <br /></td></tr>
<tr class="separator:a88d4c54405fafc0077a69a41c9126b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2220a3a00900256c7fbb27b48d69168b" id="r_a2220a3a00900256c7fbb27b48d69168b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a2220a3a00900256c7fbb27b48d69168b">set</a> (std::span&lt; T &gt; x, T scale=1) const</td></tr>
<tr class="memdesc:a2220a3a00900256c7fbb27b48d69168b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc entries in <code>x</code> to <code>scale * x_bc</code>  <br /></td></tr>
<tr class="separator:a2220a3a00900256c7fbb27b48d69168b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecc00f571eb0c9d752c733e6a3b2bf4" id="r_aaecc00f571eb0c9d752c733e6a3b2bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#aaecc00f571eb0c9d752c733e6a3b2bf4">set</a> (std::span&lt; T &gt; x, std::span&lt; const T &gt; x0, T scale=1) const</td></tr>
<tr class="memdesc:aaecc00f571eb0c9d752c733e6a3b2bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bc entries in <code>x</code> to <code>scale * (x0 - x_bc)</code>  <br /></td></tr>
<tr class="separator:aaecc00f571eb0c9d752c733e6a3b2bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ae7a0d033bf199b5956f7f111b0b4" id="r_a104ae7a0d033bf199b5956f7f111b0b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a104ae7a0d033bf199b5956f7f111b0b4">dof_values</a> (std::span&lt; T &gt; values) const</td></tr>
<tr class="separator:a104ae7a0d033bf199b5956f7f111b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae566db907232be8a0a2bc0527c4c7ebd" id="r_ae566db907232be8a0a2bc0527c4c7ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#ae566db907232be8a0a2bc0527c4c7ebd">mark_dofs</a> (std::span&lt; std::int8_t &gt; markers) const</td></tr>
<tr class="memdesc:ae566db907232be8a0a2bc0527c4c7ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set markers[i] = true if dof i has a boundary condition applied. Value of markers[i] is not changed otherwise.  <br /></td></tr>
<tr class="separator:ae566db907232be8a0a2bc0527c4c7ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt;<br />
class dolfinx::fem::DirichletBC&lt; T, U &gt;</div><p>Object for setting (strong) Dirichlet boundary conditions. </p>
<p>\(u = g \ \text{on} \ G\),</p>
<p>where \(u\) is the solution to be computed, \(g\) is a function and \(G\) is a sub domain of the mesh.</p>
<p>A <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html" title="Object for setting (strong) Dirichlet boundary conditions.">DirichletBC</a> is specified by the function \(g\), the function space (trial space) and degrees of freedom to which the boundary condition applies. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae50db0881a424f17fc89b41af7fcbfca" name="ae50db0881a424f17fc89b41af7fcbfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50db0881a424f17fc89b41af7fcbfca">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename S , typename X , typename  = std::enable_if_t&lt;std::is_convertible_v&lt;S, T&gt;                               or std::is_convertible_v&lt;S, std::span&lt;const T&gt;&gt;&gt;&gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a representation of a Dirichlet boundary condition constrained by a scalar- or vector-valued constant. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>dofs</code> must be sorted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The boundary condition value (<code>T</code> or convertible to <code>std::span&lt;const T&gt;</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofs</td><td>Degree-of-freedom block indices to be constrained. The indices must be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space to be constrained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used only with point-evaluation elements. </dd>
<dd>
The indices in <code>dofs</code> are for <em>blocks</em>, e.g. a block index corresponds to 3 degrees-of-freedom if the dofmap associated with <code>g</code> has block size 3. </dd>
<dd>
The size of of <code>g</code> must be equal to the block size if <code>V</code>. Use the <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> version if this is not the case, e.g. for some mixed spaces. </dd></dl>

</div>
</div>
<a id="a572c308bed9d57743123e761e45d321a" name="a572c308bed9d57743123e761e45d321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572c308bed9d57743123e761e45d321a">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename X &gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a representation of a Dirichlet boundary condition constrained by a <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html" title="Constant value which can be attached to a Form.">fem::Constant</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>dofs</code> must be sorted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The boundary condition value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofs</td><td>Degree-of-freedom block indices to be constrained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function space to be constrained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used only with point-evaluation elements. </dd>
<dd>
The indices in <code>dofs</code> are for <em>blocks</em>, e.g. a block index corresponds to 3 degrees-of-freedom if the dofmap associated with <code>g</code> has block size 3. </dd>
<dd>
The size of of <code>g</code> must be equal to the block size if <code>V</code>. Use the <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> version if this is not the case, e.g. for some mixed spaces. </dd></dl>

</div>
</div>
<a id="ac7da5c77e4faec07d7ca9c6e876a4a4d" name="ac7da5c77e4faec07d7ca9c6e876a4a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7da5c77e4faec07d7ca9c6e876a4a4d">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename X &gt; <br />
requires std::is_convertible_v&lt;std::remove_cvref_t&lt;X&gt;, std::vector&lt;std::int32_t&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a representation of a Dirichlet boundary condition where the space being constrained is the same as the function that defines the constraint <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a>, i.e. share the same <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">fem::FunctionSpace</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>dofs</code> must be sorted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The boundary condition value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofs</td><td>Degree-of-freedom block indices to be constrained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indices in <code>dofs</code> are for <em>blocks</em>, e.g. a block index corresponds to 3 degrees-of-freedom if the dofmap associated with <code>g</code> has block size 3. </dd></dl>

</div>
</div>
<a id="af0b2f4da02cc564eef156711f319dd88" name="af0b2f4da02cc564eef156711f319dd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b2f4da02cc564eef156711f319dd88">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>V_g_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a representation of a Dirichlet boundary condition where the space being constrained and the function that defines the constraint values do not share the same <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html" title="This class represents a finite element function space defined by a mesh, a finite element,...">fem::FunctionSpace</a>. </p>
<p>A typical example is when applying a constraint on a subspace. The (sub)space and the constrain function must have the same finite element.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two degree-of-freedom arrays in <code>V_g_dofs</code> must be sorted by the indices in the first array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The boundary condition value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_g_dofs</td><td>Two arrays of degree-of-freedom indices (<code>std::array&lt;std::vector&lt;std::int32_t&gt;, 2&gt;</code>). First array are indices in the space where boundary condition is applied (V), second array are indices in the space of the boundary condition value function g. The dof indices are unrolled, i.e. are not by dof block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>The function (sub)space on which the boundary condition is applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indices in <code>dofs</code> are unrolled and not for blocks. </dd></dl>

</div>
</div>
<a id="a7986b02ec85e7fdc6945efce2d2e840a" name="a7986b02ec85e7fdc6945efce2d2e840a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7986b02ec85e7fdc6945efce2d2e840a">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>The object to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7de6888d88c12f3e105cca97988f8697" name="a7de6888d88c12f3e105cca97988f8697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6888d88c12f3e105cca97988f8697">&#9670;&#160;</a></span>DirichletBC() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>The object to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88d4c54405fafc0077a69a41c9126b11" name="a88d4c54405fafc0077a69a41c9126b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d4c54405fafc0077a69a41c9126b11">&#9670;&#160;</a></span>dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::span&lt; const std::int32_t &gt;, std::int32_t &gt; dof_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access dof indices (local indices, unrolled), including ghosts, to which a Dirichlet condition is applied, and the index to the first non-owned (ghost) index. The array of indices is sorted. </p>
<dl class="section return"><dt>Returns</dt><dd>Sorted array of dof indices (unrolled) and index to the first entry in the dof index array that is not owned. Entries <code>dofs[:pos]</code> are owned and entries <code>dofs[pos:]</code> are ghosts. </dd></dl>

</div>
</div>
<a id="a104ae7a0d033bf199b5956f7f111b0b4" name="a104ae7a0d033bf199b5956f7f111b0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104ae7a0d033bf199b5956f7f111b0b4">&#9670;&#160;</a></span>dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dof_values </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000003">Todo:</a></b></dt><dd>Review this function - it is almost identical to the '<a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html#a2220a3a00900256c7fbb27b48d69168b" title="Set bc entries in x to scale * x_bc">DirichletBC::set</a>' function</dd></dl>
<p>Set boundary condition value for entries with an applied boundary condition. Other entries are not modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The array in which to set the dof values. The array must be at least as long as the array associated with V1 (the space of the function that provides the dof values) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac5af04d5a5c90e55a8ae8357cc21d37" name="aac5af04d5a5c90e55a8ae8357cc21d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5af04d5a5c90e55a8ae8357cc21d37">&#9670;&#160;</a></span>function_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../d9/d69/classdolfinx_1_1fem_1_1FunctionSpace.html">FunctionSpace</a>&lt; U &gt; &gt; function_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function space to which boundary conditions are applied. </p>
<dl class="section return"><dt>Returns</dt><dd>The function space </dd></dl>

</div>
</div>
<a id="ae566db907232be8a0a2bc0527c4c7ebd" name="ae566db907232be8a0a2bc0527c4c7ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae566db907232be8a0a2bc0527c4c7ebd">&#9670;&#160;</a></span>mark_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mark_dofs </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::int8_t &gt;&#160;</td>
          <td class="paramname"><em>markers</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set markers[i] = true if dof i has a boundary condition applied. Value of markers[i] is not changed otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">markers</td><td>Entry makers[i] is set to true if dof i in V0 had a boundary condition applied, i.e. dofs which are fixed by a boundary condition. Other entries in <code>markers</code> are left unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d43b3e6250861976b39c60f137a9bc" name="a56d43b3e6250861976b39c60f137a9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d43b3e6250861976b39c60f137a9bc">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html">DirichletBC</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>Another <a class="el" href="../../db/d9f/classdolfinx_1_1fem_1_1DirichletBC.html" title="Object for setting (strong) Dirichlet boundary conditions.">DirichletBC</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaecc00f571eb0c9d752c733e6a3b2bf4" name="aaecc00f571eb0c9d752c733e6a3b2bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecc00f571eb0c9d752c733e6a3b2bf4">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bc entries in <code>x</code> to <code>scale * (x0 - x_bc)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The array in which to set <code>scale * (x0 - x_bc)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>The array used in compute the value to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scaling value to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2220a3a00900256c7fbb27b48d69168b" name="a2220a3a00900256c7fbb27b48d69168b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2220a3a00900256c7fbb27b48d69168b">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bc entries in <code>x</code> to <code>scale * x_bc</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The array in which to set <code>scale * x_bc[i]</code>, where x_bc[i] is the boundary value of x[i]. Entries in x that do not have a Dirichlet condition applied to them are unchanged. The length of x must be less than or equal to the index of the greatest boundary dof index. To set values only for degrees-of-freedom that are owned by the calling rank, the length of the array <code>x</code> should be equal to the number of dofs owned by this rank. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scaling value to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790b0b864c5eb283d7e340a6145c7d35" name="a790b0b864c5eb283d7e340a6145c7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790b0b864c5eb283d7e340a6145c7d35">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../da/d5d/conceptdolfinx_1_1scalar.html">dolfinx::scalar</a> T, std::floating_point U = dolfinx::scalar_value_type_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::shared_ptr&lt; const <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html">Function</a>&lt; T, U &gt; &gt;, std::shared_ptr&lt; const <a class="el" href="../../d6/d06/classdolfinx_1_1fem_1_1Constant.html">Constant</a>&lt; T &gt; &gt; &gt; value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return boundary value function g. </p>
<dl class="section return"><dt>Returns</dt><dd>The boundary values <a class="el" href="../../d7/d76/classdolfinx_1_1fem_1_1Function.html" title="This class represents a function  in a finite element function space , given by.">Function</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/fem/<a class="el" href="../../d4/dec/assembler_8h_source.html">assembler.h</a></li>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/fem/<a class="el" href="../../dd/d4f/DirichletBC_8h_source.html">DirichletBC.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

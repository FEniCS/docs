<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFINx: Vector&lt; T, Container, ScatterContainer &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DOLFINx<span id="projectnumber">&#160;0.10.0</span>
   </div>
   <div id="projectbrief">DOLFINx C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="../../d2/dc7/namespacedolfinx.html">dolfinx</a></li><li class="navelem"><a href="../../d6/dfa/namespacedolfinx_1_1la.html">la</a></li><li class="navelem"><a href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../df/d4c/classdolfinx_1_1la_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Vector&lt; T, Container, ScatterContainer &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A vector that can be distributed across processes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/dbe/Vector_8h_source.html">Vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c2014b8eab41918aa55438cb370dd55" id="r_a9c2014b8eab41918aa55438cb370dd55"><td class="memItemLeft" align="right" valign="top"><a id="a9c2014b8eab41918aa55438cb370dd55" name="a9c2014b8eab41918aa55438cb370dd55"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = Container</td></tr>
<tr class="memdesc:a9c2014b8eab41918aa55438cb370dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type. <br /></td></tr>
<tr class="memitem:a1952c1b8061d096ce3aab37a796e7df5" id="r_a1952c1b8061d096ce3aab37a796e7df5"><td class="memItemLeft" align="right" valign="top"><a id="a1952c1b8061d096ce3aab37a796e7df5" name="a1952c1b8061d096ce3aab37a796e7df5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = container_type::value_type</td></tr>
<tr class="memdesc:a1952c1b8061d096ce3aab37a796e7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e05669c7cdb76c40cf5260bee4682be" id="r_a5e05669c7cdb76c40cf5260bee4682be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e05669c7cdb76c40cf5260bee4682be">Vector</a> (std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt; map, int <a class="el" href="#a48ddad8b3b7b898f02a7e99332a2ac4e">bs</a>)</td></tr>
<tr class="memdesc:a5e05669c7cdb76c40cf5260bee4682be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a distributed vector.  <br /></td></tr>
<tr class="memitem:ae6dfe382b0653b9282ad56ec3c3ff17e" id="r_ae6dfe382b0653b9282ad56ec3c3ff17e"><td class="memItemLeft" align="right" valign="top"><a id="ae6dfe382b0653b9282ad56ec3c3ff17e" name="ae6dfe382b0653b9282ad56ec3c3ff17e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (const <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;x)=default</td></tr>
<tr class="memdesc:ae6dfe382b0653b9282ad56ec3c3ff17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="memitem:abb4bc159ceec64c5dfff2d9c705d135a" id="r_abb4bc159ceec64c5dfff2d9c705d135a"><td class="memItemLeft" align="right" valign="top"><a id="abb4bc159ceec64c5dfff2d9c705d135a" name="abb4bc159ceec64c5dfff2d9c705d135a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;&amp;x)=default</td></tr>
<tr class="memdesc:abb4bc159ceec64c5dfff2d9c705d135a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="memitem:a43eeee26647538435811ab84696bcc98" id="r_a43eeee26647538435811ab84696bcc98"><td class="memTemplParams" colspan="2">template&lt;typename T0, typename Container0, typename ScatterContainer0&gt; </td></tr>
<tr class="memitem:a43eeee26647538435811ab84696bcc98 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43eeee26647538435811ab84696bcc98">Vector</a> (const <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a>&lt; T0, Container0, ScatterContainer0 &gt; &amp;x)</td></tr>
<tr class="memdesc:a43eeee26647538435811ab84696bcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-convert vector, possibly using to different container types.  <br /></td></tr>
<tr class="memitem:aea1aa247d19f323f98b71cf834335d74" id="r_aea1aa247d19f323f98b71cf834335d74"><td class="memItemLeft" align="right" valign="top"><a id="aea1aa247d19f323f98b71cf834335d74" name="aea1aa247d19f323f98b71cf834335d74"></a>
<a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;x)=delete</td></tr>
<tr class="memitem:a776a08fdde16fc24c1de53bbb115f71f" id="r_a776a08fdde16fc24c1de53bbb115f71f"><td class="memItemLeft" align="right" valign="top"><a id="a776a08fdde16fc24c1de53bbb115f71f" name="a776a08fdde16fc24c1de53bbb115f71f"></a>
<a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> &amp;&amp;x)=default</td></tr>
<tr class="memdesc:a776a08fdde16fc24c1de53bbb115f71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="memitem:ab4a809e8bd73a28e6bbe63aec58cda6a" id="r_ab4a809e8bd73a28e6bbe63aec58cda6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a809e8bd73a28e6bbe63aec58cda6a">set</a> (<a class="el" href="#a1952c1b8061d096ce3aab37a796e7df5">value_type</a> v)</td></tr>
<tr class="memdesc:ab4a809e8bd73a28e6bbe63aec58cda6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries (including ghosts).  <br /></td></tr>
<tr class="memitem:ab07d9857e0d635d27f7ea915262c11a6" id="r_ab07d9857e0d635d27f7ea915262c11a6"><td class="memTemplParams" colspan="2">template&lt;typename U, typename GetPtr&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt; and GetPtrConcept&lt;GetPtr, Container, T&gt;</td></tr>
<tr class="memitem:ab07d9857e0d635d27f7ea915262c11a6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab07d9857e0d635d27f7ea915262c11a6">scatter_fwd_begin</a> (U pack, GetPtr get_ptr)</td></tr>
<tr class="memdesc:ab07d9857e0d635d27f7ea915262c11a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin scatter (send) of local data that is ghosted on other processes.  <br /></td></tr>
<tr class="memitem:ada646adaa18ddbaed19b60e3e2dad6ce" id="r_ada646adaa18ddbaed19b60e3e2dad6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada646adaa18ddbaed19b60e3e2dad6ce">scatter_fwd_begin</a> ()</td></tr>
<tr class="memdesc:ada646adaa18ddbaed19b60e3e2dad6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin scatter (send) of local data that is ghosted on other processes (simplified CPU version).  <br /></td></tr>
<tr class="memitem:a69e66e0d1a3ab2ef39506e38001c339a" id="r_a69e66e0d1a3ab2ef39506e38001c339a"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt;</td></tr>
<tr class="memitem:a69e66e0d1a3ab2ef39506e38001c339a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e66e0d1a3ab2ef39506e38001c339a">scatter_fwd_end</a> (U unpack)</td></tr>
<tr class="memdesc:a69e66e0d1a3ab2ef39506e38001c339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">End scatter (send) of local data values that are ghosted on other processes.  <br /></td></tr>
<tr class="memitem:a87d2509d857a40b8c696c896ef3adbdd" id="r_a87d2509d857a40b8c696c896ef3adbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d2509d857a40b8c696c896ef3adbdd">scatter_fwd_end</a> ()</td></tr>
<tr class="memdesc:a87d2509d857a40b8c696c896ef3adbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">End scatter (send) of local data values that are ghosted on other processes (simplified CPU version).  <br /></td></tr>
<tr class="memitem:a913455928bb202d138e185228b8fe488" id="r_a913455928bb202d138e185228b8fe488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a913455928bb202d138e185228b8fe488">scatter_fwd</a> ()</td></tr>
<tr class="memdesc:a913455928bb202d138e185228b8fe488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter (send) of local data values that are ghosted on other processes and update ghost entry values (simplified CPU version).  <br /></td></tr>
<tr class="memitem:a2849d0f2db352096a2fe68935a218a68" id="r_a2849d0f2db352096a2fe68935a218a68"><td class="memTemplParams" colspan="2">template&lt;typename U, typename GetPtr&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt; and GetPtrConcept&lt;GetPtr, Container, T&gt;</td></tr>
<tr class="memitem:a2849d0f2db352096a2fe68935a218a68 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2849d0f2db352096a2fe68935a218a68">scatter_rev_begin</a> (U pack, GetPtr get_ptr)</td></tr>
<tr class="memdesc:a2849d0f2db352096a2fe68935a218a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start scatter (send) of ghost entry data to the owning process of an index.  <br /></td></tr>
<tr class="memitem:ae7726d782f9b67d20d5cf5b22414305b" id="r_ae7726d782f9b67d20d5cf5b22414305b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7726d782f9b67d20d5cf5b22414305b">scatter_rev_begin</a> ()</td></tr>
<tr class="memdesc:ae7726d782f9b67d20d5cf5b22414305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start scatter (send) of ghost entry data to the owning process of an index (simplified CPU version).  <br /></td></tr>
<tr class="memitem:a70df360bc6aacc28b6124d1a99bf39f7" id="r_a70df360bc6aacc28b6124d1a99bf39f7"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt;</td></tr>
<tr class="memitem:a70df360bc6aacc28b6124d1a99bf39f7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70df360bc6aacc28b6124d1a99bf39f7">scatter_rev_end</a> (U unpack)</td></tr>
<tr class="memdesc:a70df360bc6aacc28b6124d1a99bf39f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">End scatter of ghost data to owner and update owned entries.  <br /></td></tr>
<tr class="memitem:a61f543b1aa833487e2a9f94a59a8acfe" id="r_a61f543b1aa833487e2a9f94a59a8acfe"><td class="memTemplParams" colspan="2">template&lt;class BinaryOperation&gt; <br />
requires requires(Container c) { { c.data() } -&gt; std::same_as&lt;T*&gt;; }</td></tr>
<tr class="memitem:a61f543b1aa833487e2a9f94a59a8acfe template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f543b1aa833487e2a9f94a59a8acfe">scatter_rev</a> (BinaryOperation op)</td></tr>
<tr class="memdesc:a61f543b1aa833487e2a9f94a59a8acfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter (send) of ghost data values to the owning process and assign/accumulate into the owned data entries (simplified CPU version).  <br /></td></tr>
<tr class="memitem:a8293d9aee560cf478b9c9e3def1d0255" id="r_a8293d9aee560cf478b9c9e3def1d0255"><td class="memItemLeft" align="right" valign="top"><a id="a8293d9aee560cf478b9c9e3def1d0255" name="a8293d9aee560cf478b9c9e3def1d0255"></a>
std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>index_map</b> () const</td></tr>
<tr class="memdesc:a8293d9aee560cf478b9c9e3def1d0255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get IndexMap. <br /></td></tr>
<tr class="memitem:a48ddad8b3b7b898f02a7e99332a2ac4e" id="r_a48ddad8b3b7b898f02a7e99332a2ac4e"><td class="memItemLeft" align="right" valign="top"><a id="a48ddad8b3b7b898f02a7e99332a2ac4e" name="a48ddad8b3b7b898f02a7e99332a2ac4e"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>bs</b> () const</td></tr>
<tr class="memdesc:a48ddad8b3b7b898f02a7e99332a2ac4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block size. <br /></td></tr>
<tr class="memitem:a138cacaeb58bb73d0c223d48bb946d00" id="r_a138cacaeb58bb73d0c223d48bb946d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a138cacaeb58bb73d0c223d48bb946d00">array</a> ()</td></tr>
<tr class="memdesc:a138cacaeb58bb73d0c223d48bb946d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the process-local part of the vector.  <br /></td></tr>
<tr class="memitem:a1a487a589e6a018d1d4aa65d645edd5f" id="r_a1a487a589e6a018d1d4aa65d645edd5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a487a589e6a018d1d4aa65d645edd5f">array</a> () const</td></tr>
<tr class="memdesc:a1a487a589e6a018d1d4aa65d645edd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the process-local part of the vector (const version).  <br /></td></tr>
<tr class="memitem:a0ade3a27614cf09ae1133dbecf75a882" id="r_a0ade3a27614cf09ae1133dbecf75a882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ade3a27614cf09ae1133dbecf75a882">mutable_array</a> ()</td></tr>
<tr class="memdesc:a0ade3a27614cf09ae1133dbecf75a882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local part of the vector.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt;<br />
class dolfinx::la::Vector&lt; T, Container, ScatterContainer &gt;</div><p>A vector that can be distributed across processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the vector. </td></tr>
    <tr><td class="paramname">Container</td><td>Data container type. This is typically <span class="tt">std::vector&lt;T&gt;</span> on CPUs, and <span class="tt">thrust::device_vector&lt;T&gt;</span> on GPUs. </td></tr>
    <tr><td class="paramname">ScatterContainer</td><td>Storage container type for the scatterer indices. This is typically <span class="tt">std::vector&lt;std::int32_t&gt;</span> on CPUs, and <span class="tt">thrust::device_vector&lt;std::int32_t&gt;</span> on GPUs. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e05669c7cdb76c40cf5260bee4682be" name="a5e05669c7cdb76c40cf5260bee4682be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e05669c7cdb76c40cf5260bee4682be">&#9670;&#160;</a></span>Vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../d2/d30/classdolfinx_1_1common_1_1IndexMap.html">common::IndexMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a distributed vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Index map that describes the parallel layout of the data. </td></tr>
    <tr><td class="paramname">bs</td><td>Number of entries per index map 'index' (block size). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43eeee26647538435811ab84696bcc98" name="a43eeee26647538435811ab84696bcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eeee26647538435811ab84696bcc98">&#9670;&#160;</a></span>Vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T0, typename Container0, typename ScatterContainer0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html">Vector</a>&lt; T0, Container0, ScatterContainer0 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-convert vector, possibly using to different container types. </p>
<p>Examples of use include copying a <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html" title="A vector that can be distributed across processes.">Vector</a> to a different value type, e.g. double to float, or copying a <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html" title="A vector that can be distributed across processes.">Vector</a> from a CPU to a GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vec</td><td>Type of the <a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html" title="A vector that can be distributed across processes.">Vector</a> being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="../../d2/d0b/classdolfinx_1_1la_1_1Vector.html" title="A vector that can be distributed across processes.">Vector</a> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a138cacaeb58bb73d0c223d48bb946d00" name="a138cacaeb58bb73d0c223d48bb946d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138cacaeb58bb73d0c223d48bb946d00">&#9670;&#160;</a></span>array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp; array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the process-local part of the vector. </p>
<p>Owned entries appear first, followed by ghosted entries. </p>

</div>
</div>
<a id="a1a487a589e6a018d1d4aa65d645edd5f" name="a1a487a589e6a018d1d4aa65d645edd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a487a589e6a018d1d4aa65d645edd5f">&#9670;&#160;</a></span>array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp; array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the process-local part of the vector (const version). </p>
<p>Owned entries appear first, followed by ghosted entries. </p>

</div>
</div>
<a id="a0ade3a27614cf09ae1133dbecf75a882" name="a0ade3a27614cf09ae1133dbecf75a882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ade3a27614cf09ae1133dbecf75a882">&#9670;&#160;</a></span>mutable_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a> &amp; mutable_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local part of the vector. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Use <a class="el" href="#a138cacaeb58bb73d0c223d48bb946d00" title="Get the process-local part of the vector.">array</a> instead. </dd></dl>

</div>
</div>
<a id="a913455928bb202d138e185228b8fe488" name="a913455928bb202d138e185228b8fe488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913455928bb202d138e185228b8fe488">&#9670;&#160;</a></span>scatter_fwd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_fwd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter (send) of local data values that are ghosted on other processes and update ghost entry values (simplified CPU version). </p>
<p>Suitable for scatter operations on a CPU with <span class="tt">std::vector</span> storage. The send buffer is packed and the receive buffer unpacked by a function that is suitable for use on a CPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation </dd></dl>

</div>
</div>
<a id="ada646adaa18ddbaed19b60e3e2dad6ce" name="ada646adaa18ddbaed19b60e3e2dad6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada646adaa18ddbaed19b60e3e2dad6ce">&#9670;&#160;</a></span>scatter_fwd_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_fwd_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin scatter (send) of local data that is ghosted on other processes (simplified CPU version). </p>
<p>Suitable for scatter operations on a CPU with <span class="tt">std::vector</span> storage. The send buffer is packed internally by a function that is suitable for use on a CPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation. </dd></dl>

</div>
</div>
<a id="ab07d9857e0d635d27f7ea915262c11a6" name="ab07d9857e0d635d27f7ea915262c11a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d9857e0d635d27f7ea915262c11a6">&#9670;&#160;</a></span>scatter_fwd_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U, typename GetPtr&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt; and GetPtrConcept&lt;GetPtr, Container, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_fwd_begin </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>pack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetPtr</td>          <td class="paramname"><span class="paramname"><em>get_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin scatter (send) of local data that is ghosted on other processes. </p>
<p>The user provides the function to pack to the send buffer. Typically usage would be a specialised function to pack data that resides on a GPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Pack function type. </td></tr>
    <tr><td class="paramname">GetPtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>Function that packs owned data into a send buffer. </td></tr>
    <tr><td class="paramname">get_ptr</td><td>Function that for a <span class="tt">Container</span> type returns the pointer to the underlying data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87d2509d857a40b8c696c896ef3adbdd" name="a87d2509d857a40b8c696c896ef3adbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d2509d857a40b8c696c896ef3adbdd">&#9670;&#160;</a></span>scatter_fwd_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_fwd_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End scatter (send) of local data values that are ghosted on other processes (simplified CPU version). </p>
<p>Suitable for scatter operations on a CPU with <span class="tt">std::vector</span> storage. The receive buffer is unpacked internally by a function that is suitable for use on a CPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation. </dd></dl>

</div>
</div>
<a id="a69e66e0d1a3ab2ef39506e38001c339a" name="a69e66e0d1a3ab2ef39506e38001c339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e66e0d1a3ab2ef39506e38001c339a">&#9670;&#160;</a></span>scatter_fwd_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_fwd_end </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>unpack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End scatter (send) of local data values that are ghosted on other processes. </p>
<p>The user provides the function to unpack the receive buffer. Typically usage would be a specialised function to unpack data that resides on a GPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unpack</td><td>Function to unpack the receive buffer into the ghost entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61f543b1aa833487e2a9f94a59a8acfe" name="a61f543b1aa833487e2a9f94a59a8acfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f543b1aa833487e2a9f94a59a8acfe">&#9670;&#160;</a></span>scatter_rev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class BinaryOperation&gt; <br />
requires requires(Container c) { { c.data() } -&gt; std::same_as&lt;T*&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev </td>
          <td>(</td>
          <td class="paramtype">BinaryOperation</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter (send) of ghost data values to the owning process and assign/accumulate into the owned data entries (simplified CPU version). </p>
<p>For an owned entry, data from more than one process may be received. The received data can be summed or inserted into the owning entry. The this is controlled by the <span class="tt">op</span> function.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>IndexMap operation (add or insert). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7726d782f9b67d20d5cf5b22414305b" name="ae7726d782f9b67d20d5cf5b22414305b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7726d782f9b67d20d5cf5b22414305b">&#9670;&#160;</a></span>scatter_rev_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start scatter (send) of ghost entry data to the owning process of an index (simplified CPU version). </p>
<p>Suitable for scatter operations on a CPU with <span class="tt">std::vector</span> storage. The send buffer is packed internally by a function that is suitable for use on a CPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation </dd></dl>

</div>
</div>
<a id="a2849d0f2db352096a2fe68935a218a68" name="a2849d0f2db352096a2fe68935a218a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2849d0f2db352096a2fe68935a218a68">&#9670;&#160;</a></span>scatter_rev_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U, typename GetPtr&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt; and GetPtrConcept&lt;GetPtr, Container, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev_begin </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>pack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetPtr</td>          <td class="paramname"><span class="paramname"><em>get_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start scatter (send) of ghost entry data to the owning process of an index. </p>
<p>The user provides the function to pack to the send buffer. Typically usage would be a specialised function to pack data that resides on a GPU.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Pack function type. </td></tr>
    <tr><td class="paramname">GetPtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>Function that packs ghost data into a send buffer. </td></tr>
    <tr><td class="paramname">get_ptr</td><td>Function that for a <span class="tt">Container</span> type returns the pointer to the underlying data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70df360bc6aacc28b6124d1a99bf39f7" name="a70df360bc6aacc28b6124d1a99bf39f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70df360bc6aacc28b6124d1a99bf39f7">&#9670;&#160;</a></span>scatter_rev_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; <br />
requires VectorPackKernel&lt;U, <a class="el" href="#a9c2014b8eab41918aa55438cb370dd55">container_type</a>, ScatterContainer&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_rev_end </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>unpack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End scatter of ghost data to owner and update owned entries. </p>
<p>For an owned entry, data from more than one process may be received. The received data can be summed or inserted into the owning entry by the <span class="tt">unpack</span> function.</p>
<dl class="section note"><dt>Note</dt><dd>Collective <a class="el" href="../../da/dfe/namespacedolfinx_1_1MPI.html" title="MPI support functionality.">MPI</a> operation </dd></dl>

</div>
</div>
<a id="ab4a809e8bd73a28e6bbe63aec58cda6a" name="ab4a809e8bd73a28e6bbe63aec58cda6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a809e8bd73a28e6bbe63aec58cda6a">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename ScatterContainer = std::vector&lt;std::int32_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1952c1b8061d096ce3aab37a796e7df5">value_type</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries (including ghosts). </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>Use <span class="tt">std::ranges::fill(u.array(), v)</span> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value to set all entries to (on calling rank). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/dolfinx/dolfinx/cpp/dolfinx/la/<a class="el" href="../../d6/dbe/Vector_8h_source.html">Vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
